# Метод предиктора-корректора
Метод предиктора-корректора - семейство одношаговых методов, которые используют неявные схемы. Суть состоит в следующем:

На каждом шаге вводдятся два этапа, использующих многошаговые методы:

1. С помощью явного метода (предиктора) по известным значениям функции в предыдущих узлах находится начальное приближение $y_{i+1} = y^{(0)}_{i+1}$ в новом узле
2. Используя неявный метод (корректор), в результате итераций находятся приближения $y^{(1)}_{i+1}, y^{(2)}_{i+1}, ...$

Один из вариантов метода прогноза и коррекции может быть получен на основе метода Адамса четвертого порядка:

На этапе предиктора: $y_{i+1} = y_i + \frac{h}{24}(55f_i - 59f_{i-1} + 37f_{i-2} - 9f_{i-3})$

На этапе корректора: $y_{i+1} = y_i + \frac{h}{24}(9f_{i+1} + 19f_i - 5f_{i-1} + f_{i-2})$

Явная схема используется на каждом шаге один раз, а с помощью неявной схемы строится итерационный процесс вычисления $y_{i+1}$,

поскольку это значение входит в правую часть выражения $f_{i+1} = f(x_{i+1}, y_{i+1})$. Расчет по этому методу может быть начат только со значения $y_4$.

Необходимые при этом $y_1, y_2, y_3$ находятся по методу Рунге-Кутта, $y_0$ задается начальным условием.

Точность численного решения можно повысить различными способами. Например, путем уменьшения значения шага h.

Однако этот путь ограничен требованием экономичности, поскольку получение решения с необходимой точностью может потребовать огромного объема вычислений.


```python
import numpy as np
import matplotlib.pyplot as plt

# Определяем функцию f(t, y)
def f(t, y):
    return y  # Пример: y' = y

# Метод Рунге-Кутты для получения начальных значений
def runge_kutta(y0, t0, h, n):
    y = [y0]
    t = t0
    for _ in range(n):
        k1 = h * f(t, y[-1])
        k2 = h * f(t + h / 2, y[-1] + k1 / 2)
        k3 = h * f(t + h / 2, y[-1] + k2 / 2)
        k4 = h * f(t + h, y[-1] + k3)
        y_next = y[-1] + (k1 + 2 * k2 + 2 * k3 + k4) / 6
        y.append(y_next)
        t += h
    return y

# Метод предиктора-корректора
def predictor_corrector(y0, t0, h, n):
    # Получаем первые три значения с помощью метода Рунге-Кутты
    y_values = runge_kutta(y0, t0, h, 3)
    t_values = [t0 + i * h for i in range(4)]  # t0, t0+h, t0+2h, t0+3h

    for i in range(3, n):
        # Предсказание (метод Адамса-Бэшфорта)
        y_pred = y_values[i - 1] + h * f(t_values[i - 1], y_values[i - 1])
        
        # Корректировка (метод Адамса-Мултона)
        y_next = y_values[i - 1] + (h / 2) * (f(t_values[i], y_pred) + f(t_values[i - 1], y_values[i - 1]))

        # Добавляем значения в списки
        y_values.append(y_next)
        t_values.append(t_values[i - 1] + h)

    return t_values, y_values

# Параметры
y0 = 1    # начальное значение
t0 = 0    # начальное время
h = 0.1   # шаг по времени
n = 20    # количество шагов

# Запуск метода предиктора-корректора
t_values, y_values = predictor_corrector(y0, t0, h, n)

# Печать результатов
for t, y in zip(t_values, y_values):
    print(f"t = {t:.2f}, y = {y:.6f}")

# Построение графика
plt.plot(t_values, y_values, label='Метод предиктора-корректора', marker='o')
plt.xlabel('t')
plt.ylabel('y')
plt.title('Решение ODU методом предиктора-корректора')
plt.legend()
plt.grid()
plt.show()
```