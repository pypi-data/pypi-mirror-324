# # 18. Метод предиктора-корректора.

# Метод предиктора-корректора - семейство одношаговых методов, которые используют неявные схемы. Суть состоит в следующем:
# 
# На каждом шаге вводдятся два этапа, использующих многошаговые методы:
# 
# 1. С помощью явного метода (предиктора) по известным значениям функции в предыдущих узлах находится начальное приближение $y_{i+1} = y^{(0)}_{i+1}$ в новом узле
# 2. Используя неявный метод (корректор), в результате итераций находятся приближения $y^{(1)}_{i+1}, y^{(2)}_{i+1}, ...$
# 
# Один из вариантов метода прогноза и коррекции может быть получен на основе метода Адамса четвертого порядка:
# 
# На этапе предиктора: $y_{i+1} = y_i + \frac{h}{24}(55f_i - 59f_{i-1} + 37f_{i-2} - 9f_{i-3})$
# 
# На этапе корректора: $y_{i+1} = y_i + \frac{h}{24}(9f_{i+1} + 19f_i - 5f_{i-1} + f_{i-2})$
# 
# Явная схема используется на каждом шаге один раз, а с помощью неявной схемы строится итерационный процесс вычисления $y_{i+1}$,
# 
# поскольку это значение входит в правую часть выражения $f_{i+1} = f(x_{i+1}, y_{i+1})$. Расчет по этому методу может быть начат только со значения $y_4$.
# 
# Необходимые при этом $y_1, y_2, y_3$ находятся по методу Рунге-Кутта, $y_0$ задается начальным условием.
# 
# Точность численного решения можно повысить различными способами. Например, путем уменьшения значения шага h.
# 
# Однако этот путь ограничен требованием экономичности, поскольку получение решения с необходимой точностью может потребовать огромного объема вычислений.



import numpy as np
import matplotlib.pyplot as plt

# Задаем параметры
h = 0.05  # шаг
a, b = 0, 3  # интервал
n_steps = int((b - a) / h)  # число шагов
x_values = [x0 + i * h for i in range(n_steps + 1)]
y_values = np.zeros(n_steps + 1)

# Начальное условие
y_values[0] = 1

def f(x, y):
    return 2*y - x**2

# Метод Рунге-Кутты для начальных значений (y_0, y_1, y_2, y_3)
for i in range(3):
    x_n, y_n = x_values[i], y_values[i]
    k1 = f(x_n, y_n)
    k2 = f(x_n + h / 2, y_n + h * k1 / 2)
    k3 = f(x_n + h / 2, y_n + h * k2 / 2)
    k4 = f(x_n + h, y_n + h * k3)
    y_values[i + 1] = y_n + (h / 6) * (k1 + 2 * k2 + 2 * k3 + k4)
    print(f"x = {x_values[i + 1]:.2f}, y = {y_values[i + 1]:.5f}")

# методом предиктора-корректора
for i in range(3, n_steps):
    # Предиктор (метод Адамса-Бэшфорта)
    f_i = f(x_values[i], y_values[i])
    f_i1 = f(x_values[i - 1], y_values[i - 1])
    f_i2 = f(x_values[i - 2], y_values[i - 2])
    f_i3 = f(x_values[i - 3], y_values[i - 3])
    y_pred = y_values[i] + (h / 24) * (55 * f_i - 59 * f_i1 + 37 * f_i2 - 9 * f_i3)

    # Корректор (метод Адамса-Мултона)
    f_pred = f(x_values[i + 1], y_pred)
    y_values[i + 1] = y_values[i] + (h / 24) * (9 * f_pred + 19 * f_i - 5 * f_i1 + f_i2)
    print(f"x = {x_values[i + 1]:.2f}, y = {y_values[i + 1]:.5f}")

# Построение графика
plt.plot(x_values, y_values, label="Численное решение (Адамс)")
plt.xlabel("x")
plt.ylabel("y(x)")
plt.title("Решение методом предиктора-корректора")
plt.legend()
plt.grid()
plt.show()