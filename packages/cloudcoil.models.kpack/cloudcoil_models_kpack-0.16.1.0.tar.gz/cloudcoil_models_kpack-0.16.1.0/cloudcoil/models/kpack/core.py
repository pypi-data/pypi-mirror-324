# Generated by cloudcoil-model-codegen v0.4.6
# DO NOT EDIT

from __future__ import annotations

from typing import Annotated, Callable, List, Optional, Type, overload

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.models.kubernetes.core import v1
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)


class Blob(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Blob"]:
            return Blob

        def build(self) -> "Blob":
            return Blob(**self._attrs)

        def auth(self, value: Optional[str], /) -> Self:
            return self._set("auth", value)

        def strip_components(self, value: Optional[int], /) -> Self:
            return self._set("strip_components", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Blob.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Blob.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Blob."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Blob", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Blob.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auth: Optional[str] = None
    strip_components: Annotated[Optional[int], Field(alias="stripComponents")] = None
    url: Optional[str] = ""


class BuildBuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildBuilderSpec"]:
            return BuildBuilderSpec

        def build(self) -> "BuildBuilderSpec":
            return BuildBuilderSpec(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[v1.LocalObjectReference], /
        ) -> "BuildBuilderSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.LocalObjectReference, v1.LocalObjectReference.Builder]],
                GenericListBuilder[v1.LocalObjectReference, v1.LocalObjectReference.Builder]
                | List[v1.LocalObjectReference],
            ],
            /,
        ) -> "BuildBuilderSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.LocalObjectReference.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.LocalObjectReference.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.LocalObjectReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

    class BuilderContext(BuilderContextBase["BuildBuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildBuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildBuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildBuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildBuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None
    image_pull_secrets: Annotated[
        Optional[List[v1.LocalObjectReference]], Field(alias="imagePullSecrets")
    ] = None


class BuildStack(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildStack"]:
            return BuildStack

        def build(self) -> "BuildStack":
            return BuildStack(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def run_image(self, value: Optional[str], /) -> Self:
            return self._set("run_image", value)

    class BuilderContext(BuilderContextBase["BuildStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = None
    run_image: Annotated[Optional[str], Field(alias="runImage")] = None


class BuildpackInfo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackInfo"]:
            return BuildpackInfo

        def build(self) -> "BuildpackInfo":
            return BuildpackInfo(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["BuildpackInfo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackInfo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackInfo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackInfo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackInfo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = ""
    version: Optional[str] = None


class BuildpackMetadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackMetadata"]:
            return BuildpackMetadata

        def build(self) -> "BuildpackMetadata":
            return BuildpackMetadata(**self._attrs)

        def homepage(self, value: Optional[str], /) -> Self:
            return self._set("homepage", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["BuildpackMetadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackMetadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackMetadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackMetadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackMetadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    homepage: Optional[str] = None
    id: Optional[str] = ""
    version: Optional[str] = ""


class BuildpackRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackRef"]:
            return BuildpackRef

        def build(self) -> "BuildpackRef":
            return BuildpackRef(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def optional(self, value: Optional[bool], /) -> Self:
            return self._set("optional", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["BuildpackRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = ""
    optional: Optional[bool] = None
    version: Optional[str] = None


class BuildpackStack(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackStack"]:
            return BuildpackStack

        def build(self) -> "BuildpackStack":
            return BuildpackStack(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def mixins(self, value: Optional[List[str]], /) -> Self:
            return self._set("mixins", value)

    class BuilderContext(BuilderContextBase["BuildpackStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = ""
    mixins: Optional[List[str]] = None


class BuildpackageInfo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackageInfo"]:
            return BuildpackageInfo

        def build(self) -> "BuildpackageInfo":
            return BuildpackageInfo(**self._attrs)

        def homepage(self, value: Optional[str], /) -> Self:
            return self._set("homepage", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["BuildpackageInfo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackageInfo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackageInfo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackageInfo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackageInfo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    homepage: Optional[str] = None
    id: Optional[str] = None
    version: Optional[str] = None


class CNBBinding(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CNBBinding"]:
            return CNBBinding

        def build(self) -> "CNBBinding":
            return CNBBinding(**self._attrs)

        @overload
        def metadata_ref(
            self, value_or_callback: Optional[v1.LocalObjectReference], /
        ) -> "CNBBinding.Builder": ...

        @overload
        def metadata_ref(
            self,
            value_or_callback: Callable[
                [v1.LocalObjectReference.Builder],
                v1.LocalObjectReference.Builder | v1.LocalObjectReference,
            ],
            /,
        ) -> "CNBBinding.Builder": ...

        @overload
        def metadata_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.LocalObjectReference.BuilderContext": ...

        def metadata_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.LocalObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.LocalObjectReference.builder())
                if isinstance(output, v1.LocalObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata_ref", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[v1.LocalObjectReference], /
        ) -> "CNBBinding.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [v1.LocalObjectReference.Builder],
                v1.LocalObjectReference.Builder | v1.LocalObjectReference,
            ],
            /,
        ) -> "CNBBinding.Builder": ...

        @overload
        def secret_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.LocalObjectReference.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.LocalObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.LocalObjectReference.builder())
                if isinstance(output, v1.LocalObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["CNBBinding.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CNBBinding.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CNBBinding."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CNBBinding", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CNBBinding.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata_ref: Annotated[Optional[v1.LocalObjectReference], Field(alias="metadataRef")] = None
    name: Optional[str] = None
    secret_ref: Annotated[Optional[v1.LocalObjectReference], Field(alias="secretRef")] = None


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: Optional[str] = ""
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: Optional[str] = ""
    """
    Type of condition.
    """


class Git(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Git"]:
            return Git

        def build(self) -> "Git":
            return Git(**self._attrs)

        def initialize_submodules(self, value: Optional[bool], /) -> Self:
            return self._set("initialize_submodules", value)

        def revision(self, value: Optional[str], /) -> Self:
            return self._set("revision", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Git.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Git.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Git."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Git", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Git.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    initialize_submodules: Annotated[Optional[bool], Field(alias="initializeSubmodules")] = None
    revision: Optional[str] = ""
    url: Optional[str] = ""


class ImageSource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageSource"]:
            return ImageSource

        def build(self) -> "ImageSource":
            return ImageSource(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

    class BuilderContext(BuilderContextBase["ImageSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None


class NotarySecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NotarySecretRef"]:
            return NotarySecretRef

        def build(self) -> "NotarySecretRef":
            return NotarySecretRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["NotarySecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NotarySecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NotarySecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NotarySecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NotarySecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""


class NotaryV1Config(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NotaryV1Config"]:
            return NotaryV1Config

        def build(self) -> "NotaryV1Config":
            return NotaryV1Config(**self._attrs)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[NotarySecretRef], /
        ) -> "NotaryV1Config.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[
                [NotarySecretRef.Builder], NotarySecretRef.Builder | NotarySecretRef
            ],
            /,
        ) -> "NotaryV1Config.Builder": ...

        @overload
        def secret_ref(
            self, value_or_callback: Never = ...
        ) -> "NotarySecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = NotarySecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NotarySecretRef.builder())
                if isinstance(output, NotarySecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["NotaryV1Config.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NotaryV1Config.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NotaryV1Config."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NotaryV1Config", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NotaryV1Config.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_ref: Annotated[Optional[NotarySecretRef], Field(alias="secretRef")] = (
        NotarySecretRef.model_validate({})
    )
    url: Optional[str] = ""


class OrderEntry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OrderEntry"]:
            return OrderEntry

        def build(self) -> "OrderEntry":
            return OrderEntry(**self._attrs)

        @overload
        def group(self, value_or_callback: List[BuildpackRef], /) -> "OrderEntry.Builder": ...

        @overload
        def group(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuildpackRef, BuildpackRef.Builder]],
                GenericListBuilder[BuildpackRef, BuildpackRef.Builder] | List[BuildpackRef],
            ],
            /,
        ) -> "OrderEntry.Builder": ...

        @overload
        def group(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuildpackRef.Builder]: ...

        def group(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuildpackRef.Builder]()
                context._parent_builder = self
                context._field_name = "group"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildpackRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("group", value)

    class BuilderContext(BuilderContextBase["OrderEntry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OrderEntry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OrderEntry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OrderEntry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OrderEntry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[List[BuildpackRef]] = None


class Registry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Registry"]:
            return Registry

        def build(self) -> "Registry":
            return Registry(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[v1.LocalObjectReference], /
        ) -> "Registry.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.LocalObjectReference, v1.LocalObjectReference.Builder]],
                GenericListBuilder[v1.LocalObjectReference, v1.LocalObjectReference.Builder]
                | List[v1.LocalObjectReference],
            ],
            /,
        ) -> "Registry.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.LocalObjectReference.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.LocalObjectReference.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.LocalObjectReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

    class BuilderContext(BuilderContextBase["Registry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Registry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Registry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Registry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Registry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = ""
    image_pull_secrets: Annotated[
        Optional[List[v1.LocalObjectReference]], Field(alias="imagePullSecrets")
    ] = None


class ResolvedBlobSource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResolvedBlobSource"]:
            return ResolvedBlobSource

        def build(self) -> "ResolvedBlobSource":
            return ResolvedBlobSource(**self._attrs)

        def strip_components(self, value: Optional[int], /) -> Self:
            return self._set("strip_components", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            return self._set("sub_path", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["ResolvedBlobSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResolvedBlobSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResolvedBlobSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResolvedBlobSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResolvedBlobSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    strip_components: Annotated[Optional[int], Field(alias="stripComponents")] = None
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None
    url: Optional[str] = ""


class ResolvedGitSource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResolvedGitSource"]:
            return ResolvedGitSource

        def build(self) -> "ResolvedGitSource":
            return ResolvedGitSource(**self._attrs)

        def initialize_submodules(self, value: Optional[bool], /) -> Self:
            return self._set("initialize_submodules", value)

        def revision(self, value: Optional[str], /) -> Self:
            return self._set("revision", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            return self._set("sub_path", value)

        def type(self, value: Optional[str], /) -> Self:
            return self._set("type", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["ResolvedGitSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResolvedGitSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResolvedGitSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResolvedGitSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResolvedGitSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    initialize_submodules: Annotated[Optional[bool], Field(alias="initializeSubmodules")] = None
    revision: Optional[str] = ""
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None
    type: Optional[str] = ""
    url: Optional[str] = ""


class ResolvedRegistrySource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResolvedRegistrySource"]:
            return ResolvedRegistrySource

        def build(self) -> "ResolvedRegistrySource":
            return ResolvedRegistrySource(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[v1.LocalObjectReference], /
        ) -> "ResolvedRegistrySource.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.LocalObjectReference, v1.LocalObjectReference.Builder]],
                GenericListBuilder[v1.LocalObjectReference, v1.LocalObjectReference.Builder]
                | List[v1.LocalObjectReference],
            ],
            /,
        ) -> "ResolvedRegistrySource.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.LocalObjectReference.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.LocalObjectReference.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.LocalObjectReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            return self._set("sub_path", value)

    class BuilderContext(BuilderContextBase["ResolvedRegistrySource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResolvedRegistrySource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResolvedRegistrySource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResolvedRegistrySource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResolvedRegistrySource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = ""
    image_pull_secrets: Annotated[
        Optional[List[v1.LocalObjectReference]], Field(alias="imagePullSecrets")
    ] = None
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None


class ResolvedSourceConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResolvedSourceConfig"]:
            return ResolvedSourceConfig

        def build(self) -> "ResolvedSourceConfig":
            return ResolvedSourceConfig(**self._attrs)

        @overload
        def blob(
            self, value_or_callback: Optional[ResolvedBlobSource], /
        ) -> "ResolvedSourceConfig.Builder": ...

        @overload
        def blob(
            self,
            value_or_callback: Callable[
                [ResolvedBlobSource.Builder],
                ResolvedBlobSource.Builder | ResolvedBlobSource,
            ],
            /,
        ) -> "ResolvedSourceConfig.Builder": ...

        @overload
        def blob(self, value_or_callback: Never = ...) -> "ResolvedBlobSource.BuilderContext": ...

        def blob(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ResolvedBlobSource.BuilderContext()
                context._parent_builder = self
                context._field_name = "blob"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResolvedBlobSource.builder())
                if isinstance(output, ResolvedBlobSource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("blob", value)

        @overload
        def git(
            self, value_or_callback: Optional[ResolvedGitSource], /
        ) -> "ResolvedSourceConfig.Builder": ...

        @overload
        def git(
            self,
            value_or_callback: Callable[
                [ResolvedGitSource.Builder],
                ResolvedGitSource.Builder | ResolvedGitSource,
            ],
            /,
        ) -> "ResolvedSourceConfig.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> "ResolvedGitSource.BuilderContext": ...

        def git(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ResolvedGitSource.BuilderContext()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResolvedGitSource.builder())
                if isinstance(output, ResolvedGitSource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def registry(
            self, value_or_callback: Optional[ResolvedRegistrySource], /
        ) -> "ResolvedSourceConfig.Builder": ...

        @overload
        def registry(
            self,
            value_or_callback: Callable[
                [ResolvedRegistrySource.Builder],
                ResolvedRegistrySource.Builder | ResolvedRegistrySource,
            ],
            /,
        ) -> "ResolvedSourceConfig.Builder": ...

        @overload
        def registry(
            self, value_or_callback: Never = ...
        ) -> "ResolvedRegistrySource.BuilderContext": ...

        def registry(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ResolvedRegistrySource.BuilderContext()
                context._parent_builder = self
                context._field_name = "registry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResolvedRegistrySource.builder())
                if isinstance(output, ResolvedRegistrySource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("registry", value)

    class BuilderContext(BuilderContextBase["ResolvedSourceConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResolvedSourceConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResolvedSourceConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResolvedSourceConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResolvedSourceConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    blob: Optional[ResolvedBlobSource] = None
    git: Optional[ResolvedGitSource] = None
    registry: Optional[ResolvedRegistrySource] = None


class SourceConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceConfig"]:
            return SourceConfig

        def build(self) -> "SourceConfig":
            return SourceConfig(**self._attrs)

        @overload
        def blob(self, value_or_callback: Optional[Blob], /) -> "SourceConfig.Builder": ...

        @overload
        def blob(
            self, value_or_callback: Callable[[Blob.Builder], Blob.Builder | Blob], /
        ) -> "SourceConfig.Builder": ...

        @overload
        def blob(self, value_or_callback: Never = ...) -> "Blob.BuilderContext": ...

        def blob(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Blob.BuilderContext()
                context._parent_builder = self
                context._field_name = "blob"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Blob.builder())
                if isinstance(output, Blob.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("blob", value)

        @overload
        def git(self, value_or_callback: Optional[Git], /) -> "SourceConfig.Builder": ...

        @overload
        def git(
            self, value_or_callback: Callable[[Git.Builder], Git.Builder | Git], /
        ) -> "SourceConfig.Builder": ...

        @overload
        def git(self, value_or_callback: Never = ...) -> "Git.BuilderContext": ...

        def git(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Git.BuilderContext()
                context._parent_builder = self
                context._field_name = "git"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Git.builder())
                if isinstance(output, Git.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("git", value)

        @overload
        def registry(self, value_or_callback: Optional[Registry], /) -> "SourceConfig.Builder": ...

        @overload
        def registry(
            self,
            value_or_callback: Callable[[Registry.Builder], Registry.Builder | Registry],
            /,
        ) -> "SourceConfig.Builder": ...

        @overload
        def registry(self, value_or_callback: Never = ...) -> "Registry.BuilderContext": ...

        def registry(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Registry.BuilderContext()
                context._parent_builder = self
                context._field_name = "registry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Registry.builder())
                if isinstance(output, Registry.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("registry", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            return self._set("sub_path", value)

    class BuilderContext(BuilderContextBase["SourceConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    blob: Optional[Blob] = None
    git: Optional[Git] = None
    registry: Optional[Registry] = None
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None


class Status(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Status"]:
            return Status

        def build(self) -> "Status":
            return Status(**self._attrs)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "Status.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "Status.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["Status.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Status.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Status."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Status", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Status.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class VolatileTime(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolatileTime"]:
            return VolatileTime

        def build(self) -> "VolatileTime":
            return VolatileTime(**self._attrs)

        @overload
        def inner(self, value_or_callback: apimachinery.Time, /) -> "VolatileTime.Builder": ...

        @overload
        def inner(
            self,
            value_or_callback: Callable[
                [apimachinery.Time.Builder],
                apimachinery.Time.Builder | apimachinery.Time,
            ],
            /,
        ) -> "VolatileTime.Builder": ...

        @overload
        def inner(self, value_or_callback: Never = ...) -> "apimachinery.Time.BuilderContext": ...

        def inner(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.Time.BuilderContext()
                context._parent_builder = self
                context._field_name = "inner"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.Time.builder())
                if isinstance(output, apimachinery.Time.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("inner", value)

    class BuilderContext(BuilderContextBase["VolatileTime.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolatileTime.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolatileTime."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolatileTime", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolatileTime.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    inner: apimachinery.Time


class BuildpackStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackStatus"]:
            return BuildpackStatus

        def build(self) -> "BuildpackStatus":
            return BuildpackStatus(**self._attrs)

        def api(self, value: Optional[str], /) -> Self:
            return self._set("api", value)

        @overload
        def buildpackage(
            self, value_or_callback: Optional[BuildpackageInfo], /
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def buildpackage(
            self,
            value_or_callback: Callable[
                [BuildpackageInfo.Builder], BuildpackageInfo.Builder | BuildpackageInfo
            ],
            /,
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def buildpackage(
            self, value_or_callback: Never = ...
        ) -> "BuildpackageInfo.BuilderContext": ...

        def buildpackage(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildpackageInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "buildpackage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildpackageInfo.builder())
                if isinstance(output, BuildpackageInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("buildpackage", value)

        def diff_id(self, value: Optional[str], /) -> Self:
            return self._set("diff_id", value)

        def digest(self, value: Optional[str], /) -> Self:
            return self._set("digest", value)

        def homepage(self, value: Optional[str], /) -> Self:
            return self._set("homepage", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        @overload
        def order(self, value_or_callback: List[OrderEntry], /) -> "BuildpackStatus.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OrderEntry, OrderEntry.Builder]],
                GenericListBuilder[OrderEntry, OrderEntry.Builder] | List[OrderEntry],
            ],
            /,
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        def size(self, value: Optional[int], /) -> Self:
            return self._set("size", value)

        @overload
        def stacks(
            self, value_or_callback: List[BuildpackStack], /
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def stacks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuildpackStack, BuildpackStack.Builder]],
                GenericListBuilder[BuildpackStack, BuildpackStack.Builder] | List[BuildpackStack],
            ],
            /,
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def stacks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuildpackStack.Builder]: ...

        def stacks(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuildpackStack.Builder]()
                context._parent_builder = self
                context._field_name = "stacks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildpackStack.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("stacks", value)

        @overload
        def store_image(
            self, value_or_callback: Optional[ImageSource], /
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def store_image(
            self,
            value_or_callback: Callable[[ImageSource.Builder], ImageSource.Builder | ImageSource],
            /,
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def store_image(self, value_or_callback: Never = ...) -> "ImageSource.BuilderContext": ...

        def store_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageSource.BuilderContext()
                context._parent_builder = self
                context._field_name = "store_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageSource.builder())
                if isinstance(output, ImageSource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store_image", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["BuildpackStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api: Optional[str] = None
    buildpackage: Optional[BuildpackageInfo] = BuildpackageInfo.model_validate({})
    diff_id: Annotated[Optional[str], Field(alias="diffId")] = None
    digest: Optional[str] = None
    homepage: Optional[str] = None
    id: Optional[str] = ""
    order: Optional[List[OrderEntry]] = None
    size: Optional[int] = None
    stacks: Optional[List[BuildpackStack]] = None
    store_image: Annotated[Optional[ImageSource], Field(alias="storeImage")] = (
        ImageSource.model_validate({})
    )
    version: Optional[str] = None


class NotaryConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NotaryConfig"]:
            return NotaryConfig

        def build(self) -> "NotaryConfig":
            return NotaryConfig(**self._attrs)

        @overload
        def v1(self, value_or_callback: Optional[NotaryV1Config], /) -> "NotaryConfig.Builder": ...

        @overload
        def v1(
            self,
            value_or_callback: Callable[
                [NotaryV1Config.Builder], NotaryV1Config.Builder | NotaryV1Config
            ],
            /,
        ) -> "NotaryConfig.Builder": ...

        @overload
        def v1(self, value_or_callback: Never = ...) -> "NotaryV1Config.BuilderContext": ...

        def v1(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = NotaryV1Config.BuilderContext()
                context._parent_builder = self
                context._field_name = "v1"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NotaryV1Config.builder())
                if isinstance(output, NotaryV1Config.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("v1", value)

    class BuilderContext(BuilderContextBase["NotaryConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NotaryConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NotaryConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NotaryConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NotaryConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    v1: Optional[NotaryV1Config] = None
