# Generated by cloudcoil-model-codegen v0.4.6
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.models.kubernetes.core import v1
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource, ResourceList

from . import core


class BuildCache(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildCache"]:
            return BuildCache

        def build(self) -> "BuildCache":
            return BuildCache(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

    class BuilderContext(BuilderContextBase["BuildCache.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildCache.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildCache."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildCache", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildCache.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None


class BuildPersistentVolumeCache(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildPersistentVolumeCache"]:
            return BuildPersistentVolumeCache

        def build(self) -> "BuildPersistentVolumeCache":
            return BuildPersistentVolumeCache(**self._attrs)

        def persistent_volume_claim_name(self, value: Optional[str], /) -> Self:
            return self._set("persistent_volume_claim_name", value)

    class BuilderContext(BuilderContextBase["BuildPersistentVolumeCache.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildPersistentVolumeCache.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildPersistentVolumeCache."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildPersistentVolumeCache", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildPersistentVolumeCache.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    persistent_volume_claim_name: Annotated[
        Optional[str], Field(alias="persistentVolumeClaimName")
    ] = None


class BuildSpecImage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildSpecImage"]:
            return BuildSpecImage

        def build(self) -> "BuildSpecImage":
            return BuildSpecImage(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

    class BuilderContext(BuilderContextBase["BuildSpecImage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildSpecImage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildSpecImage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildSpecImage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildSpecImage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None


class BuildStack(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildStack"]:
            return BuildStack

        def build(self) -> "BuildStack":
            return BuildStack(**self._attrs)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def run_image(self, value: Optional[str], /) -> Self:
            return self._set("run_image", value)

    class BuilderContext(BuilderContextBase["BuildStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    id: Optional[str] = None
    run_image: Annotated[Optional[str], Field(alias="runImage")] = None


class BuilderBuildpackRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderBuildpackRef"]:
            return BuilderBuildpackRef

        def build(self) -> "BuilderBuildpackRef":
            return BuilderBuildpackRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
            """
            return self._set("field_path", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def optional(self, value: Optional[bool], /) -> Self:
            return self._set("optional", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["BuilderBuildpackRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderBuildpackRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderBuildpackRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderBuildpackRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderBuildpackRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
    """
    id: Optional[str] = ""
    image: Optional[str] = None
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    optional: Optional[bool] = None
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """
    version: Optional[str] = None


class BuilderOrderEntry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderOrderEntry"]:
            return BuilderOrderEntry

        def build(self) -> "BuilderOrderEntry":
            return BuilderOrderEntry(**self._attrs)

        @overload
        def group(
            self, value_or_callback: List[BuilderBuildpackRef], /
        ) -> "BuilderOrderEntry.Builder": ...

        @overload
        def group(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuilderBuildpackRef, BuilderBuildpackRef.Builder]],
                GenericListBuilder[BuilderBuildpackRef, BuilderBuildpackRef.Builder]
                | List[BuilderBuildpackRef],
            ],
            /,
        ) -> "BuilderOrderEntry.Builder": ...

        @overload
        def group(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuilderBuildpackRef.Builder]: ...

        def group(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuilderBuildpackRef.Builder]()
                context._parent_builder = self
                context._field_name = "group"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderBuildpackRef.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("group", value)

    class BuilderContext(BuilderContextBase["BuilderOrderEntry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderOrderEntry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderOrderEntry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderOrderEntry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderOrderEntry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[List[BuilderBuildpackRef]] = None


class BuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderSpec"]:
            return BuilderSpec

        def build(self) -> "BuilderSpec":
            return BuilderSpec(**self._attrs)

        def additional_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("additional_labels", value)

        @overload
        def order(self, value_or_callback: List[BuilderOrderEntry], /) -> "BuilderSpec.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuilderOrderEntry, BuilderOrderEntry.Builder]],
                GenericListBuilder[BuilderOrderEntry, BuilderOrderEntry.Builder]
                | List[BuilderOrderEntry],
            ],
            /,
        ) -> "BuilderSpec.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuilderOrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuilderOrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderOrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        @overload
        def stack(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "BuilderSpec.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "BuilderSpec.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def store(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "BuilderSpec.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "BuilderSpec.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["BuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_labels: Annotated[Optional[Dict[str, str]], Field(alias="additionalLabels")] = None
    order: Optional[List[BuilderOrderEntry]] = None
    stack: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    store: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    tag: Optional[str] = None


class BuildpackSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackSpec"]:
            return BuildpackSpec

        def build(self) -> "BuildpackSpec":
            return BuildpackSpec(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            return self._set("service_account_name", value)

    class BuilderContext(BuilderContextBase["BuildpackSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None


class ClusterBuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuilderSpec"]:
            return ClusterBuilderSpec

        def build(self) -> "ClusterBuilderSpec":
            return ClusterBuilderSpec(**self._attrs)

        def additional_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("additional_labels", value)

        @overload
        def order(
            self, value_or_callback: List[BuilderOrderEntry], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuilderOrderEntry, BuilderOrderEntry.Builder]],
                GenericListBuilder[BuilderOrderEntry, BuilderOrderEntry.Builder]
                | List[BuilderOrderEntry],
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuilderOrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuilderOrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderOrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        @overload
        def service_account_ref(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

        @overload
        def stack(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def store(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["ClusterBuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_labels: Annotated[Optional[Dict[str, str]], Field(alias="additionalLabels")] = None
    order: Optional[List[BuilderOrderEntry]] = None
    service_account_ref: Annotated[
        Optional[v1.ObjectReference], Field(alias="serviceAccountRef")
    ] = v1.ObjectReference.model_validate({})
    stack: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    store: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    tag: Optional[str] = None


class ClusterBuildpackSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuildpackSpec"]:
            return ClusterBuildpackSpec

        def build(self) -> "ClusterBuildpackSpec":
            return ClusterBuildpackSpec(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        @overload
        def service_account_ref(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuildpackSpec.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuildpackSpec.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

    class BuilderContext(BuilderContextBase["ClusterBuildpackSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuildpackSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuildpackSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuildpackSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuildpackSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None
    service_account_ref: Annotated[
        Optional[v1.ObjectReference], Field(alias="serviceAccountRef")
    ] = None


class ClusterStackSpecImage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackSpecImage"]:
            return ClusterStackSpecImage

        def build(self) -> "ClusterStackSpecImage":
            return ClusterStackSpecImage(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

    class BuilderContext(BuilderContextBase["ClusterStackSpecImage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackSpecImage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackSpecImage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackSpecImage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackSpecImage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None


class ClusterStackStatusImage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackStatusImage"]:
            return ClusterStackStatusImage

        def build(self) -> "ClusterStackStatusImage":
            return ClusterStackStatusImage(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

    class BuilderContext(BuilderContextBase["ClusterStackStatusImage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackStatusImage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackStatusImage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackStatusImage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackStatusImage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None


class CosignAnnotation(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CosignAnnotation"]:
            return CosignAnnotation

        def build(self) -> "CosignAnnotation":
            return CosignAnnotation(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["CosignAnnotation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CosignAnnotation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CosignAnnotation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CosignAnnotation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CosignAnnotation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    value: Optional[str] = None


class CosignConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CosignConfig"]:
            return CosignConfig

        def build(self) -> "CosignConfig":
            return CosignConfig(**self._attrs)

        @overload
        def annotations(
            self, value_or_callback: List[CosignAnnotation], /
        ) -> "CosignConfig.Builder": ...

        @overload
        def annotations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CosignAnnotation, CosignAnnotation.Builder]],
                GenericListBuilder[CosignAnnotation, CosignAnnotation.Builder]
                | List[CosignAnnotation],
            ],
            /,
        ) -> "CosignConfig.Builder": ...

        @overload
        def annotations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CosignAnnotation.Builder]: ...

        def annotations(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CosignAnnotation.Builder]()
                context._parent_builder = self
                context._field_name = "annotations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CosignAnnotation.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("annotations", value)

    class BuilderContext(BuilderContextBase["CosignConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CosignConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CosignConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CosignConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CosignConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[List[CosignAnnotation]] = None


class CosignSignature(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CosignSignature"]:
            return CosignSignature

        def build(self) -> "CosignSignature":
            return CosignSignature(**self._attrs)

        def signing_secret(self, value: Optional[str], /) -> Self:
            return self._set("signing_secret", value)

        def target_digest(self, value: Optional[str], /) -> Self:
            return self._set("target_digest", value)

    class BuilderContext(BuilderContextBase["CosignSignature.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CosignSignature.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CosignSignature."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CosignSignature", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CosignSignature.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    signing_secret: Annotated[Optional[str], Field(alias="signingSecret")] = ""
    target_digest: Annotated[Optional[str], Field(alias="targetDigest")] = ""


class ImageBuilder(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageBuilder"]:
            return ImageBuilder

        def build(self) -> "ImageBuilder":
            return ImageBuilder(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ImageBuilder.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageBuilder.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageBuilder."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageBuilder", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageBuilder.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = ""


class ImagePersistentVolumeCache(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePersistentVolumeCache"]:
            return ImagePersistentVolumeCache

        def build(self) -> "ImagePersistentVolumeCache":
            return ImagePersistentVolumeCache(**self._attrs)

        @overload
        def size(
            self, value_or_callback: Optional[apimachinery.Quantity], /
        ) -> "ImagePersistentVolumeCache.Builder": ...

        @overload
        def size(
            self,
            value_or_callback: Callable[
                [apimachinery.Quantity.Builder],
                apimachinery.Quantity.Builder | apimachinery.Quantity,
            ],
            /,
        ) -> "ImagePersistentVolumeCache.Builder": ...

        @overload
        def size(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.Quantity.BuilderContext": ...

        def size(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.Quantity.BuilderContext()
                context._parent_builder = self
                context._field_name = "size"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.Quantity.builder())
                if isinstance(output, apimachinery.Quantity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("size", value)

        def storage_class_name(self, value: Optional[str], /) -> Self:
            return self._set("storage_class_name", value)

    class BuilderContext(BuilderContextBase["ImagePersistentVolumeCache.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePersistentVolumeCache.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePersistentVolumeCache."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePersistentVolumeCache", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePersistentVolumeCache.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    size: Optional[apimachinery.Quantity] = None
    storage_class_name: Annotated[Optional[str], Field(alias="storageClassName")] = None


class LastBuild(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LastBuild"]:
            return LastBuild

        def build(self) -> "LastBuild":
            return LastBuild(**self._attrs)

        @overload
        def cache(self, value_or_callback: Optional[BuildCache], /) -> "LastBuild.Builder": ...

        @overload
        def cache(
            self,
            value_or_callback: Callable[[BuildCache.Builder], BuildCache.Builder | BuildCache],
            /,
        ) -> "LastBuild.Builder": ...

        @overload
        def cache(self, value_or_callback: Never = ...) -> "BuildCache.BuilderContext": ...

        def cache(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildCache.BuilderContext()
                context._parent_builder = self
                context._field_name = "cache"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildCache.builder())
                if isinstance(output, BuildCache.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cache", value)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        def stack_id(self, value: Optional[str], /) -> Self:
            return self._set("stack_id", value)

    class BuilderContext(BuilderContextBase["LastBuild.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LastBuild.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LastBuild."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LastBuild", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LastBuild.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cache: Optional[BuildCache] = BuildCache.model_validate({})
    image: Optional[str] = None
    stack_id: Annotated[Optional[str], Field(alias="stackId")] = None


class NamespacedBuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespacedBuilderSpec"]:
            return NamespacedBuilderSpec

        def build(self) -> "NamespacedBuilderSpec":
            return NamespacedBuilderSpec(**self._attrs)

        def additional_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("additional_labels", value)

        @overload
        def order(
            self, value_or_callback: List[BuilderOrderEntry], /
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuilderOrderEntry, BuilderOrderEntry.Builder]],
                GenericListBuilder[BuilderOrderEntry, BuilderOrderEntry.Builder]
                | List[BuilderOrderEntry],
            ],
            /,
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuilderOrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuilderOrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderOrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        def service_account(self, value: Optional[str], /) -> Self:
            return self._set("service_account", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            return self._set("service_account_name", value)

        @overload
        def stack(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def store(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["NamespacedBuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespacedBuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespacedBuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespacedBuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespacedBuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_labels: Annotated[Optional[Dict[str, str]], Field(alias="additionalLabels")] = None
    order: Optional[List[BuilderOrderEntry]] = None
    service_account: Annotated[Optional[str], Field(alias="serviceAccount")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    stack: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    store: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    tag: Optional[str] = None


class RegistryCache(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RegistryCache"]:
            return RegistryCache

        def build(self) -> "RegistryCache":
            return RegistryCache(**self._attrs)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["RegistryCache.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RegistryCache.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RegistryCache."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RegistryCache", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RegistryCache.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    tag: Optional[str] = ""


class ResolvedClusterStack(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResolvedClusterStack"]:
            return ResolvedClusterStack

        def build(self) -> "ResolvedClusterStack":
            return ResolvedClusterStack(**self._attrs)

        @overload
        def build_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def build_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def build_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def build_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "build_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_image", value)

        def group_id(self, value: Optional[int], /) -> Self:
            return self._set("group_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def mixins(self, value: Optional[List[str]], /) -> Self:
            return self._set("mixins", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def run_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

        def user_id(self, value: Optional[int], /) -> Self:
            return self._set("user_id", value)

    class BuilderContext(BuilderContextBase["ResolvedClusterStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResolvedClusterStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResolvedClusterStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResolvedClusterStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResolvedClusterStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="buildImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    group_id: Annotated[Optional[int], Field(alias="groupId")] = None
    id: Optional[str] = None
    mixins: Optional[List[str]] = None
    run_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="runImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    user_id: Annotated[Optional[int], Field(alias="userId")] = None


class BuildCacheConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildCacheConfig"]:
            return BuildCacheConfig

        def build(self) -> "BuildCacheConfig":
            return BuildCacheConfig(**self._attrs)

        @overload
        def registry(
            self, value_or_callback: Optional[RegistryCache], /
        ) -> "BuildCacheConfig.Builder": ...

        @overload
        def registry(
            self,
            value_or_callback: Callable[
                [RegistryCache.Builder], RegistryCache.Builder | RegistryCache
            ],
            /,
        ) -> "BuildCacheConfig.Builder": ...

        @overload
        def registry(self, value_or_callback: Never = ...) -> "RegistryCache.BuilderContext": ...

        def registry(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RegistryCache.BuilderContext()
                context._parent_builder = self
                context._field_name = "registry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RegistryCache.builder())
                if isinstance(output, RegistryCache.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("registry", value)

        @overload
        def volume(
            self, value_or_callback: Optional[BuildPersistentVolumeCache], /
        ) -> "BuildCacheConfig.Builder": ...

        @overload
        def volume(
            self,
            value_or_callback: Callable[
                [BuildPersistentVolumeCache.Builder],
                BuildPersistentVolumeCache.Builder | BuildPersistentVolumeCache,
            ],
            /,
        ) -> "BuildCacheConfig.Builder": ...

        @overload
        def volume(
            self, value_or_callback: Never = ...
        ) -> "BuildPersistentVolumeCache.BuilderContext": ...

        def volume(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildPersistentVolumeCache.BuilderContext()
                context._parent_builder = self
                context._field_name = "volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildPersistentVolumeCache.builder())
                if isinstance(output, BuildPersistentVolumeCache.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume", value)

    class BuilderContext(BuilderContextBase["BuildCacheConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildCacheConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildCacheConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildCacheConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildCacheConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    registry: Optional[RegistryCache] = None
    volume: Optional[BuildPersistentVolumeCache] = None


class BuilderStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderStatus"]:
            return BuilderStatus

        def build(self) -> "BuilderStatus":
            return BuilderStatus(**self._attrs)

        @overload
        def builder_metadata(
            self, value_or_callback: List[core.BuildpackMetadata], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def builder_metadata(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]],
                GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]
                | List[core.BuildpackMetadata],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def builder_metadata(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackMetadata.Builder]: ...

        def builder_metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackMetadata.Builder]()
                context._parent_builder = self
                context._field_name = "builder_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackMetadata.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("builder_metadata", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def observed_stack_generation(self, value: Optional[int], /) -> Self:
            return self._set("observed_stack_generation", value)

        def observed_store_generation(self, value: Optional[int], /) -> Self:
            return self._set("observed_store_generation", value)

        @overload
        def order(self, value_or_callback: List[core.OrderEntry], /) -> "BuilderStatus.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]],
                GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]
                | List[core.OrderEntry],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.OrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.OrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.OrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        def os(self, value: Optional[str], /) -> Self:
            return self._set("os", value)

        @overload
        def signature_paths(
            self, value_or_callback: List[CosignSignature], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def signature_paths(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CosignSignature, CosignSignature.Builder]],
                GenericListBuilder[CosignSignature, CosignSignature.Builder]
                | List[CosignSignature],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def signature_paths(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CosignSignature.Builder]: ...

        def signature_paths(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CosignSignature.Builder]()
                context._parent_builder = self
                context._field_name = "signature_paths"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CosignSignature.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("signature_paths", value)

        @overload
        def stack(
            self, value_or_callback: Optional[core.BuildStack], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [core.BuildStack.Builder], core.BuildStack.Builder | core.BuildStack
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "core.BuildStack.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.BuildStack.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildStack.builder())
                if isinstance(output, core.BuildStack.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

    class BuilderContext(BuilderContextBase["BuilderStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    builder_metadata: Annotated[
        Optional[List[core.BuildpackMetadata]], Field(alias="builderMetadata")
    ] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    observed_stack_generation: Annotated[Optional[int], Field(alias="observedStackGeneration")] = (
        None
    )
    observed_store_generation: Annotated[Optional[int], Field(alias="observedStoreGeneration")] = (
        None
    )
    order: Optional[List[core.OrderEntry]] = None
    os: Optional[str] = None
    signature_paths: Annotated[Optional[List[CosignSignature]], Field(alias="signaturePaths")] = (
        None
    )
    stack: Optional[core.BuildStack] = core.BuildStack.model_validate({})


class ClusterStackSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackSpec"]:
            return ClusterStackSpec

        def build(self) -> "ClusterStackSpec":
            return ClusterStackSpec(**self._attrs)

        @overload
        def build_image(
            self, value_or_callback: Optional[ClusterStackSpecImage], /
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def build_image(
            self,
            value_or_callback: Callable[
                [ClusterStackSpecImage.Builder],
                ClusterStackSpecImage.Builder | ClusterStackSpecImage,
            ],
            /,
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def build_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackSpecImage.BuilderContext": ...

        def build_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackSpecImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "build_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackSpecImage.builder())
                if isinstance(output, ClusterStackSpecImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_image", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[ClusterStackSpecImage], /
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [ClusterStackSpecImage.Builder],
                ClusterStackSpecImage.Builder | ClusterStackSpecImage,
            ],
            /,
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def run_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackSpecImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackSpecImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackSpecImage.builder())
                if isinstance(output, ClusterStackSpecImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

        @overload
        def service_account_ref(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

    class BuilderContext(BuilderContextBase["ClusterStackSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_image: Annotated[Optional[ClusterStackSpecImage], Field(alias="buildImage")] = (
        ClusterStackSpecImage.model_validate({})
    )
    id: Optional[str] = None
    run_image: Annotated[Optional[ClusterStackSpecImage], Field(alias="runImage")] = (
        ClusterStackSpecImage.model_validate({})
    )
    service_account_ref: Annotated[
        Optional[v1.ObjectReference], Field(alias="serviceAccountRef")
    ] = None


class ClusterStackStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackStatus"]:
            return ClusterStackStatus

        def build(self) -> "ClusterStackStatus":
            return ClusterStackStatus(**self._attrs)

        @overload
        def build_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def build_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def build_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def build_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "build_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_image", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def group_id(self, value: Optional[int], /) -> Self:
            return self._set("group_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def mixins(self, value: Optional[List[str]], /) -> Self:
            return self._set("mixins", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def run_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

        def user_id(self, value: Optional[int], /) -> Self:
            return self._set("user_id", value)

    class BuilderContext(BuilderContextBase["ClusterStackStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="buildImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    group_id: Annotated[Optional[int], Field(alias="groupId")] = None
    id: Optional[str] = None
    mixins: Optional[List[str]] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    run_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="runImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    user_id: Annotated[Optional[int], Field(alias="userId")] = None


class ClusterStoreSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStoreSpec"]:
            return ClusterStoreSpec

        def build(self) -> "ClusterStoreSpec":
            return ClusterStoreSpec(**self._attrs)

        @overload
        def service_account_ref(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterStoreSpec.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterStoreSpec.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

        @overload
        def sources(
            self, value_or_callback: List[core.ImageSource], /
        ) -> "ClusterStoreSpec.Builder": ...

        @overload
        def sources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.ImageSource, core.ImageSource.Builder]],
                GenericListBuilder[core.ImageSource, core.ImageSource.Builder]
                | List[core.ImageSource],
            ],
            /,
        ) -> "ClusterStoreSpec.Builder": ...

        @overload
        def sources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.ImageSource.Builder]: ...

        def sources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.ImageSource.Builder]()
                context._parent_builder = self
                context._field_name = "sources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.ImageSource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sources", value)

    class BuilderContext(BuilderContextBase["ClusterStoreSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStoreSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStoreSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStoreSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStoreSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_ref: Annotated[
        Optional[v1.ObjectReference], Field(alias="serviceAccountRef")
    ] = None
    sources: Optional[List[core.ImageSource]] = None


class ImageCacheConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageCacheConfig"]:
            return ImageCacheConfig

        def build(self) -> "ImageCacheConfig":
            return ImageCacheConfig(**self._attrs)

        @overload
        def registry(
            self, value_or_callback: Optional[RegistryCache], /
        ) -> "ImageCacheConfig.Builder": ...

        @overload
        def registry(
            self,
            value_or_callback: Callable[
                [RegistryCache.Builder], RegistryCache.Builder | RegistryCache
            ],
            /,
        ) -> "ImageCacheConfig.Builder": ...

        @overload
        def registry(self, value_or_callback: Never = ...) -> "RegistryCache.BuilderContext": ...

        def registry(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RegistryCache.BuilderContext()
                context._parent_builder = self
                context._field_name = "registry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RegistryCache.builder())
                if isinstance(output, RegistryCache.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("registry", value)

        @overload
        def volume(
            self, value_or_callback: Optional[ImagePersistentVolumeCache], /
        ) -> "ImageCacheConfig.Builder": ...

        @overload
        def volume(
            self,
            value_or_callback: Callable[
                [ImagePersistentVolumeCache.Builder],
                ImagePersistentVolumeCache.Builder | ImagePersistentVolumeCache,
            ],
            /,
        ) -> "ImageCacheConfig.Builder": ...

        @overload
        def volume(
            self, value_or_callback: Never = ...
        ) -> "ImagePersistentVolumeCache.BuilderContext": ...

        def volume(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImagePersistentVolumeCache.BuilderContext()
                context._parent_builder = self
                context._field_name = "volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePersistentVolumeCache.builder())
                if isinstance(output, ImagePersistentVolumeCache.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume", value)

    class BuilderContext(BuilderContextBase["ImageCacheConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageCacheConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageCacheConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageCacheConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageCacheConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    registry: Optional[RegistryCache] = None
    volume: Optional[ImagePersistentVolumeCache] = None


class ImageStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageStatus"]:
            return ImageStatus

        def build(self) -> "ImageStatus":
            return ImageStatus(**self._attrs)

        def build_cache_name(self, value: Optional[str], /) -> Self:
            return self._set("build_cache_name", value)

        def build_counter(self, value: Optional[int], /) -> Self:
            return self._set("build_counter", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ImageStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ImageStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_build_image_generation(self, value: Optional[int], /) -> Self:
            return self._set("latest_build_image_generation", value)

        def latest_build_reason(self, value: Optional[str], /) -> Self:
            return self._set("latest_build_reason", value)

        def latest_build_ref(self, value: Optional[str], /) -> Self:
            return self._set("latest_build_ref", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

        def latest_stack(self, value: Optional[str], /) -> Self:
            return self._set("latest_stack", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ImageStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_cache_name: Annotated[Optional[str], Field(alias="buildCacheName")] = None
    build_counter: Annotated[Optional[int], Field(alias="buildCounter")] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_build_image_generation: Annotated[
        Optional[int], Field(alias="latestBuildImageGeneration")
    ] = None
    latest_build_reason: Annotated[Optional[str], Field(alias="latestBuildReason")] = None
    latest_build_ref: Annotated[Optional[str], Field(alias="latestBuildRef")] = None
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    latest_stack: Annotated[Optional[str], Field(alias="latestStack")] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class SourceResolverSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceResolverSpec"]:
            return SourceResolverSpec

        def build(self) -> "SourceResolverSpec":
            return SourceResolverSpec(**self._attrs)

        def service_account(self, value: Optional[str], /) -> Self:
            return self._set("service_account", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.SourceConfig], /
        ) -> "SourceResolverSpec.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.SourceConfig.Builder],
                core.SourceConfig.Builder | core.SourceConfig,
            ],
            /,
        ) -> "SourceResolverSpec.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "core.SourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.SourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.SourceConfig.builder())
                if isinstance(output, core.SourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["SourceResolverSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceResolverSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceResolverSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceResolverSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceResolverSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account: Annotated[Optional[str], Field(alias="serviceAccount")] = None
    source: Optional[core.SourceConfig] = core.SourceConfig.model_validate({})


class SourceResolverStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceResolverStatus"]:
            return SourceResolverStatus

        def build(self) -> "SourceResolverStatus":
            return SourceResolverStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.ResolvedSourceConfig], /
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.ResolvedSourceConfig.Builder],
                core.ResolvedSourceConfig.Builder | core.ResolvedSourceConfig,
            ],
            /,
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def source(
            self, value_or_callback: Never = ...
        ) -> "core.ResolvedSourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.ResolvedSourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.ResolvedSourceConfig.builder())
                if isinstance(output, core.ResolvedSourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["SourceResolverStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceResolverStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceResolverStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceResolverStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceResolverStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    source: Optional[core.ResolvedSourceConfig] = core.ResolvedSourceConfig.model_validate({})


class BuildStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildStatus"]:
            return BuildStatus

        def build(self) -> "BuildStatus":
            return BuildStatus(**self._attrs)

        @overload
        def build_metadata(
            self, value_or_callback: List[core.BuildpackMetadata], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def build_metadata(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]],
                GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]
                | List[core.BuildpackMetadata],
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def build_metadata(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackMetadata.Builder]: ...

        def build_metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackMetadata.Builder]()
                context._parent_builder = self
                context._field_name = "build_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackMetadata.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_metadata", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_attestation_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_attestation_image", value)

        def latest_cache_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_cache_image", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def pod_name(self, value: Optional[str], /) -> Self:
            return self._set("pod_name", value)

        @overload
        def stack(
            self, value_or_callback: Optional[core.BuildStack], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [core.BuildStack.Builder], core.BuildStack.Builder | core.BuildStack
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "core.BuildStack.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.BuildStack.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildStack.builder())
                if isinstance(output, core.BuildStack.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def step_states(
            self, value_or_callback: List[v1.ContainerState], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def step_states(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.ContainerState, v1.ContainerState.Builder]],
                GenericListBuilder[v1.ContainerState, v1.ContainerState.Builder]
                | List[v1.ContainerState],
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def step_states(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.ContainerState.Builder]: ...

        def step_states(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.ContainerState.Builder]()
                context._parent_builder = self
                context._field_name = "step_states"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ContainerState.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("step_states", value)

        def steps_completed(self, value: Optional[List[str]], /) -> Self:
            return self._set("steps_completed", value)

    class BuilderContext(BuilderContextBase["BuildStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_metadata: Annotated[
        Optional[List[core.BuildpackMetadata]], Field(alias="buildMetadata")
    ] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_attestation_image: Annotated[Optional[str], Field(alias="latestAttestationImage")] = None
    latest_cache_image: Annotated[Optional[str], Field(alias="latestCacheImage")] = None
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    pod_name: Annotated[Optional[str], Field(alias="podName")] = None
    stack: Optional[core.BuildStack] = core.BuildStack.model_validate({})
    step_states: Annotated[Optional[List[v1.ContainerState]], Field(alias="stepStates")] = None
    steps_completed: Annotated[Optional[List[str]], Field(alias="stepsCompleted")] = None


class BuilderResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderResource"]:
            return BuilderResource

        def build(self) -> "BuilderResource":
            return BuilderResource(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Builder"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BuilderResource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BuilderResource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[NamespacedBuilderSpec], /
        ) -> "BuilderResource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [NamespacedBuilderSpec.Builder],
                NamespacedBuilderSpec.Builder | NamespacedBuilderSpec,
            ],
            /,
        ) -> "BuilderResource.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "NamespacedBuilderSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = NamespacedBuilderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespacedBuilderSpec.builder())
                if isinstance(output, NamespacedBuilderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BuilderStatus], /
        ) -> "BuilderResource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BuilderStatus.Builder], BuilderStatus.Builder | BuilderStatus
            ],
            /,
        ) -> "BuilderResource.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuilderStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuilderStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderStatus.builder())
                if isinstance(output, BuilderStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BuilderResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Builder"]] = "Builder"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[NamespacedBuilderSpec] = NamespacedBuilderSpec.model_validate({})
    status: Optional[BuilderStatus] = BuilderStatus.model_validate({})


class BuilderResourceList(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderResourceList"]:
            return BuilderResourceList

        def build(self) -> "BuilderResourceList":
            return BuilderResourceList(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        @overload
        def items(
            self, value_or_callback: List[BuilderResource], /
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuilderResource, BuilderResource.Builder]],
                GenericListBuilder[BuilderResource, BuilderResource.Builder]
                | List[BuilderResource],
            ],
            /,
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuilderResource.Builder]: ...

        def items(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuilderResource.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderResource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ListMeta], /
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ListMeta.Builder],
                apimachinery.ListMeta.Builder | apimachinery.ListMeta,
            ],
            /,
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ListMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ListMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ListMeta.builder())
                if isinstance(output, apimachinery.ListMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["BuilderResourceList.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderResourceList.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderResourceList."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderResourceList", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderResourceList.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    items: List[BuilderResource]
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ListMeta] = apimachinery.ListMeta.model_validate({})


class BuildpackStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildpackStatus"]:
            return BuildpackStatus

        def build(self) -> "BuildpackStatus":
            return BuildpackStatus(**self._attrs)

        @overload
        def buildpacks(
            self, value_or_callback: List[core.BuildpackStatus], /
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def buildpacks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]],
                GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]
                | List[core.BuildpackStatus],
            ],
            /,
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def buildpacks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackStatus.Builder]: ...

        def buildpacks(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackStatus.Builder]()
                context._parent_builder = self
                context._field_name = "buildpacks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("buildpacks", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "BuildpackStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["BuildpackStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildpackStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildpackStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildpackStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildpackStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    buildpacks: Optional[List[core.BuildpackStatus]] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class ClusterBuilder(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuilder"]:
            return ClusterBuilder

        def build(self) -> "ClusterBuilder":
            return ClusterBuilder(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterBuilder"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterBuilderSpec], /
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterBuilderSpec.Builder],
                ClusterBuilderSpec.Builder | ClusterBuilderSpec,
            ],
            /,
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterBuilderSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterBuilderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterBuilderSpec.builder())
                if isinstance(output, ClusterBuilderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BuilderStatus], /
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BuilderStatus.Builder], BuilderStatus.Builder | BuilderStatus
            ],
            /,
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuilderStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuilderStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderStatus.builder())
                if isinstance(output, BuilderStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterBuilder.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuilder.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuilder."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuilder", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuilder.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterBuilder"]] = "ClusterBuilder"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterBuilderSpec] = ClusterBuilderSpec.model_validate({})
    status: Optional[BuilderStatus] = BuilderStatus.model_validate({})


ClusterBuilderList = ResourceList["ClusterBuilder"]


class ClusterBuildpackStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuildpackStatus"]:
            return ClusterBuildpackStatus

        def build(self) -> "ClusterBuildpackStatus":
            return ClusterBuildpackStatus(**self._attrs)

        @overload
        def buildpacks(
            self, value_or_callback: List[core.BuildpackStatus], /
        ) -> "ClusterBuildpackStatus.Builder": ...

        @overload
        def buildpacks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]],
                GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]
                | List[core.BuildpackStatus],
            ],
            /,
        ) -> "ClusterBuildpackStatus.Builder": ...

        @overload
        def buildpacks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackStatus.Builder]: ...

        def buildpacks(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackStatus.Builder]()
                context._parent_builder = self
                context._field_name = "buildpacks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("buildpacks", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ClusterBuildpackStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ClusterBuildpackStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ClusterBuildpackStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuildpackStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuildpackStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuildpackStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuildpackStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    buildpacks: Optional[List[core.BuildpackStatus]] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class ClusterStack(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStack"]:
            return ClusterStack

        def build(self) -> "ClusterStack":
            return ClusterStack(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterStack"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterStack.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterStack.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterStackSpec], /
        ) -> "ClusterStack.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterStackSpec.Builder], ClusterStackSpec.Builder | ClusterStackSpec
            ],
            /,
        ) -> "ClusterStack.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterStackSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackSpec.builder())
                if isinstance(output, ClusterStackSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterStackStatus], /
        ) -> "ClusterStack.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterStackStatus.Builder],
                ClusterStackStatus.Builder | ClusterStackStatus,
            ],
            /,
        ) -> "ClusterStack.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ClusterStackStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatus.builder())
                if isinstance(output, ClusterStackStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterStack"]] = "ClusterStack"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterStackSpec] = ClusterStackSpec.model_validate({})
    status: Optional[ClusterStackStatus] = ClusterStackStatus.model_validate({})


ClusterStackList = ResourceList["ClusterStack"]


class ClusterStoreStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStoreStatus"]:
            return ClusterStoreStatus

        def build(self) -> "ClusterStoreStatus":
            return ClusterStoreStatus(**self._attrs)

        @overload
        def buildpacks(
            self, value_or_callback: List[core.BuildpackStatus], /
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def buildpacks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]],
                GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]
                | List[core.BuildpackStatus],
            ],
            /,
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def buildpacks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackStatus.Builder]: ...

        def buildpacks(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackStatus.Builder]()
                context._parent_builder = self
                context._field_name = "buildpacks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("buildpacks", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ClusterStoreStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStoreStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStoreStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStoreStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStoreStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    buildpacks: Optional[List[core.BuildpackStatus]] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class SourceResolver(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceResolver"]:
            return SourceResolver

        def build(self) -> "SourceResolver":
            return SourceResolver(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["SourceResolver"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "SourceResolver.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "SourceResolver.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[SourceResolverSpec], /
        ) -> "SourceResolver.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [SourceResolverSpec.Builder],
                SourceResolverSpec.Builder | SourceResolverSpec,
            ],
            /,
        ) -> "SourceResolver.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SourceResolverSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SourceResolverSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceResolverSpec.builder())
                if isinstance(output, SourceResolverSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[SourceResolverStatus], /
        ) -> "SourceResolver.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SourceResolverStatus.Builder],
                SourceResolverStatus.Builder | SourceResolverStatus,
            ],
            /,
        ) -> "SourceResolver.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "SourceResolverStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SourceResolverStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceResolverStatus.builder())
                if isinstance(output, SourceResolverStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["SourceResolver.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceResolver.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceResolver."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceResolver", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceResolver.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["SourceResolver"]] = "SourceResolver"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[SourceResolverSpec] = SourceResolverSpec.model_validate({})
    status: Optional[SourceResolverStatus] = SourceResolverStatus.model_validate({})


SourceResolverList = ResourceList["SourceResolver"]


class Buildpack(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Buildpack"]:
            return Buildpack

        def build(self) -> "Buildpack":
            return Buildpack(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Buildpack"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Buildpack.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Buildpack.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[BuildpackSpec], /) -> "Buildpack.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BuildpackSpec.Builder], BuildpackSpec.Builder | BuildpackSpec
            ],
            /,
        ) -> "Buildpack.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BuildpackSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildpackSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildpackSpec.builder())
                if isinstance(output, BuildpackSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BuildpackStatus], /
        ) -> "Buildpack.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BuildpackStatus.Builder], BuildpackStatus.Builder | BuildpackStatus
            ],
            /,
        ) -> "Buildpack.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuildpackStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildpackStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildpackStatus.builder())
                if isinstance(output, BuildpackStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Buildpack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Buildpack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Buildpack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Buildpack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Buildpack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Buildpack"]] = "Buildpack"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[BuildpackSpec] = BuildpackSpec.model_validate({})
    status: Optional[BuildpackStatus] = BuildpackStatus.model_validate({})


BuildpackList = ResourceList["Buildpack"]


class ClusterBuildpack(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuildpack"]:
            return ClusterBuildpack

        def build(self) -> "ClusterBuildpack":
            return ClusterBuildpack(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterBuildpack"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterBuildpack.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterBuildpack.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterBuildpackSpec], /
        ) -> "ClusterBuildpack.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterBuildpackSpec.Builder],
                ClusterBuildpackSpec.Builder | ClusterBuildpackSpec,
            ],
            /,
        ) -> "ClusterBuildpack.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterBuildpackSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterBuildpackSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterBuildpackSpec.builder())
                if isinstance(output, ClusterBuildpackSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterBuildpackStatus], /
        ) -> "ClusterBuildpack.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterBuildpackStatus.Builder],
                ClusterBuildpackStatus.Builder | ClusterBuildpackStatus,
            ],
            /,
        ) -> "ClusterBuildpack.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ClusterBuildpackStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterBuildpackStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterBuildpackStatus.builder())
                if isinstance(output, ClusterBuildpackStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterBuildpack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuildpack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuildpack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuildpack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuildpack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterBuildpack"]] = "ClusterBuildpack"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterBuildpackSpec] = ClusterBuildpackSpec.model_validate({})
    status: Optional[ClusterBuildpackStatus] = ClusterBuildpackStatus.model_validate({})


ClusterBuildpackList = ResourceList["ClusterBuildpack"]


class ClusterStore(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStore"]:
            return ClusterStore

        def build(self) -> "ClusterStore":
            return ClusterStore(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterStore"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterStore.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterStore.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterStoreSpec], /
        ) -> "ClusterStore.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterStoreSpec.Builder], ClusterStoreSpec.Builder | ClusterStoreSpec
            ],
            /,
        ) -> "ClusterStore.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterStoreSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStoreSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStoreSpec.builder())
                if isinstance(output, ClusterStoreSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterStoreStatus], /
        ) -> "ClusterStore.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterStoreStatus.Builder],
                ClusterStoreStatus.Builder | ClusterStoreStatus,
            ],
            /,
        ) -> "ClusterStore.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ClusterStoreStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStoreStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStoreStatus.builder())
                if isinstance(output, ClusterStoreStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterStore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterStore"]] = "ClusterStore"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterStoreSpec] = ClusterStoreSpec.model_validate({})
    status: Optional[ClusterStoreStatus] = ClusterStoreStatus.model_validate({})


ClusterStoreList = ResourceList["ClusterStore"]


class BuildSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildSpec"]:
            return BuildSpec

        def build(self) -> "BuildSpec":
            return BuildSpec(**self._attrs)

        def active_deadline_seconds(self, value: Optional[int], /) -> Self:
            return self._set("active_deadline_seconds", value)

        @overload
        def affinity(self, value_or_callback: Optional[v1.Affinity], /) -> "BuildSpec.Builder": ...

        @overload
        def affinity(
            self,
            value_or_callback: Callable[[v1.Affinity.Builder], v1.Affinity.Builder | v1.Affinity],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def affinity(self, value_or_callback: Never = ...) -> "v1.Affinity.BuilderContext": ...

        def affinity(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.Affinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.Affinity.builder())
                if isinstance(output, v1.Affinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("affinity", value)

        @overload
        def builder_(
            self, value_or_callback: Optional[core.BuildBuilderSpec], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def builder_(
            self,
            value_or_callback: Callable[
                [core.BuildBuilderSpec.Builder],
                core.BuildBuilderSpec.Builder | core.BuildBuilderSpec,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def builder_(
            self, value_or_callback: Never = ...
        ) -> "core.BuildBuilderSpec.BuilderContext": ...

        def builder_(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.BuildBuilderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "builder_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildBuilderSpec.builder())
                if isinstance(output, core.BuildBuilderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("builder_", value)

        @overload
        def cache(
            self, value_or_callback: Optional[BuildCacheConfig], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def cache(
            self,
            value_or_callback: Callable[
                [BuildCacheConfig.Builder], BuildCacheConfig.Builder | BuildCacheConfig
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def cache(self, value_or_callback: Never = ...) -> "BuildCacheConfig.BuilderContext": ...

        def cache(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildCacheConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "cache"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildCacheConfig.builder())
                if isinstance(output, BuildCacheConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cache", value)

        @overload
        def cnb_bindings(
            self, value_or_callback: List[core.CNBBinding], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def cnb_bindings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]],
                GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]
                | List[core.CNBBinding],
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def cnb_bindings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.CNBBinding.Builder]: ...

        def cnb_bindings(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.CNBBinding.Builder]()
                context._parent_builder = self
                context._field_name = "cnb_bindings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.CNBBinding.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cnb_bindings", value)

        @overload
        def cosign(self, value_or_callback: Optional[CosignConfig], /) -> "BuildSpec.Builder": ...

        @overload
        def cosign(
            self,
            value_or_callback: Callable[
                [CosignConfig.Builder], CosignConfig.Builder | CosignConfig
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def cosign(self, value_or_callback: Never = ...) -> "CosignConfig.BuilderContext": ...

        def cosign(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CosignConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "cosign"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CosignConfig.builder())
                if isinstance(output, CosignConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cosign", value)

        def creation_time(self, value: Optional[str], /) -> Self:
            return self._set("creation_time", value)

        def default_process(self, value: Optional[str], /) -> Self:
            return self._set("default_process", value)

        @overload
        def env(self, value_or_callback: List[v1.EnvVar], /) -> "BuildSpec.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder]],
                GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder] | List[v1.EnvVar],
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[v1.EnvVar.Builder]: ...

        def env(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.EnvVar.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.EnvVar.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def last_build(self, value_or_callback: Optional[LastBuild], /) -> "BuildSpec.Builder": ...

        @overload
        def last_build(
            self,
            value_or_callback: Callable[[LastBuild.Builder], LastBuild.Builder | LastBuild],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def last_build(self, value_or_callback: Never = ...) -> "LastBuild.BuilderContext": ...

        def last_build(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LastBuild.BuilderContext()
                context._parent_builder = self
                context._field_name = "last_build"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LastBuild.builder())
                if isinstance(output, LastBuild.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("last_build", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("node_selector", value)

        @overload
        def notary(
            self, value_or_callback: Optional[core.NotaryConfig], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def notary(
            self,
            value_or_callback: Callable[
                [core.NotaryConfig.Builder],
                core.NotaryConfig.Builder | core.NotaryConfig,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def notary(self, value_or_callback: Never = ...) -> "core.NotaryConfig.BuilderContext": ...

        def notary(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.NotaryConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "notary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.NotaryConfig.builder())
                if isinstance(output, core.NotaryConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("notary", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            return self._set("priority_class_name", value)

        def project_descriptor_path(self, value: Optional[str], /) -> Self:
            return self._set("project_descriptor_path", value)

        @overload
        def resources(
            self, value_or_callback: Optional[v1.ResourceRequirements], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [v1.ResourceRequirements.Builder],
                v1.ResourceRequirements.Builder | v1.ResourceRequirements,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> "v1.ResourceRequirements.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ResourceRequirements.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ResourceRequirements.builder())
                if isinstance(output, v1.ResourceRequirements.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[BuildSpecImage], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [BuildSpecImage.Builder], BuildSpecImage.Builder | BuildSpecImage
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def run_image(self, value_or_callback: Never = ...) -> "BuildSpecImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildSpecImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildSpecImage.builder())
                if isinstance(output, BuildSpecImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

        def runtime_class_name(self, value: Optional[str], /) -> Self:
            return self._set("runtime_class_name", value)

        def scheduler_name(self, value: Optional[str], /) -> Self:
            return self._set("scheduler_name", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            return self._set("service_account_name", value)

        @overload
        def services(
            self, value_or_callback: List[v1.ObjectReference], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def services(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.ObjectReference, v1.ObjectReference.Builder]],
                GenericListBuilder[v1.ObjectReference, v1.ObjectReference.Builder]
                | List[v1.ObjectReference],
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def services(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.ObjectReference.Builder]: ...

        def services(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.ObjectReference.Builder]()
                context._parent_builder = self
                context._field_name = "services"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("services", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.SourceConfig], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.SourceConfig.Builder],
                core.SourceConfig.Builder | core.SourceConfig,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "core.SourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.SourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.SourceConfig.builder())
                if isinstance(output, core.SourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            return self._set("tags", value)

        @overload
        def tolerations(self, value_or_callback: List[v1.Toleration], /) -> "BuildSpec.Builder": ...

        @overload
        def tolerations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.Toleration, v1.Toleration.Builder]],
                GenericListBuilder[v1.Toleration, v1.Toleration.Builder] | List[v1.Toleration],
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def tolerations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.Toleration.Builder]: ...

        def tolerations(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.Toleration.Builder]()
                context._parent_builder = self
                context._field_name = "tolerations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.Toleration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tolerations", value)

    class BuilderContext(BuilderContextBase["BuildSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    active_deadline_seconds: Annotated[Optional[int], Field(alias="activeDeadlineSeconds")] = None
    affinity: Optional[v1.Affinity] = None
    builder_: Annotated[Optional[core.BuildBuilderSpec], Field(alias="builder")] = (
        core.BuildBuilderSpec.model_validate({})
    )
    cache: Optional[BuildCacheConfig] = None
    cnb_bindings: Annotated[Optional[List[core.CNBBinding]], Field(alias="cnbBindings")] = None
    cosign: Optional[CosignConfig] = None
    creation_time: Annotated[Optional[str], Field(alias="creationTime")] = None
    default_process: Annotated[Optional[str], Field(alias="defaultProcess")] = None
    env: Optional[List[v1.EnvVar]] = None
    last_build: Annotated[Optional[LastBuild], Field(alias="lastBuild")] = None
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    notary: Optional[core.NotaryConfig] = None
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    project_descriptor_path: Annotated[Optional[str], Field(alias="projectDescriptorPath")] = None
    resources: Optional[v1.ResourceRequirements] = v1.ResourceRequirements.model_validate({})
    run_image: Annotated[Optional[BuildSpecImage], Field(alias="runImage")] = (
        BuildSpecImage.model_validate({})
    )
    runtime_class_name: Annotated[Optional[str], Field(alias="runtimeClassName")] = None
    scheduler_name: Annotated[Optional[str], Field(alias="schedulerName")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    services: Optional[List[v1.ObjectReference]] = None
    source: Optional[core.SourceConfig] = core.SourceConfig.model_validate({})
    tags: Optional[List[str]] = None
    tolerations: Optional[List[v1.Toleration]] = None


class ImageBuild(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageBuild"]:
            return ImageBuild

        def build(self) -> "ImageBuild":
            return ImageBuild(**self._attrs)

        @overload
        def affinity(self, value_or_callback: Optional[v1.Affinity], /) -> "ImageBuild.Builder": ...

        @overload
        def affinity(
            self,
            value_or_callback: Callable[[v1.Affinity.Builder], v1.Affinity.Builder | v1.Affinity],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def affinity(self, value_or_callback: Never = ...) -> "v1.Affinity.BuilderContext": ...

        def affinity(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.Affinity.BuilderContext()
                context._parent_builder = self
                context._field_name = "affinity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.Affinity.builder())
                if isinstance(output, v1.Affinity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("affinity", value)

        def build_timeout(self, value: Optional[int], /) -> Self:
            return self._set("build_timeout", value)

        @overload
        def cnb_bindings(
            self, value_or_callback: List[core.CNBBinding], /
        ) -> "ImageBuild.Builder": ...

        @overload
        def cnb_bindings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]],
                GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]
                | List[core.CNBBinding],
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def cnb_bindings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.CNBBinding.Builder]: ...

        def cnb_bindings(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.CNBBinding.Builder]()
                context._parent_builder = self
                context._field_name = "cnb_bindings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.CNBBinding.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cnb_bindings", value)

        def creation_time(self, value: Optional[str], /) -> Self:
            return self._set("creation_time", value)

        @overload
        def env(self, value_or_callback: List[v1.EnvVar], /) -> "ImageBuild.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder]],
                GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder] | List[v1.EnvVar],
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[v1.EnvVar.Builder]: ...

        def env(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.EnvVar.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.EnvVar.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("node_selector", value)

        @overload
        def resources(
            self, value_or_callback: Optional[v1.ResourceRequirements], /
        ) -> "ImageBuild.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [v1.ResourceRequirements.Builder],
                v1.ResourceRequirements.Builder | v1.ResourceRequirements,
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> "v1.ResourceRequirements.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ResourceRequirements.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ResourceRequirements.builder())
                if isinstance(output, v1.ResourceRequirements.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def runtime_class_name(self, value: Optional[str], /) -> Self:
            return self._set("runtime_class_name", value)

        def scheduler_name(self, value: Optional[str], /) -> Self:
            return self._set("scheduler_name", value)

        @overload
        def services(
            self, value_or_callback: List[v1.ObjectReference], /
        ) -> "ImageBuild.Builder": ...

        @overload
        def services(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.ObjectReference, v1.ObjectReference.Builder]],
                GenericListBuilder[v1.ObjectReference, v1.ObjectReference.Builder]
                | List[v1.ObjectReference],
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def services(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.ObjectReference.Builder]: ...

        def services(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.ObjectReference.Builder]()
                context._parent_builder = self
                context._field_name = "services"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("services", value)

        @overload
        def tolerations(
            self, value_or_callback: List[v1.Toleration], /
        ) -> "ImageBuild.Builder": ...

        @overload
        def tolerations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.Toleration, v1.Toleration.Builder]],
                GenericListBuilder[v1.Toleration, v1.Toleration.Builder] | List[v1.Toleration],
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def tolerations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.Toleration.Builder]: ...

        def tolerations(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.Toleration.Builder]()
                context._parent_builder = self
                context._field_name = "tolerations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.Toleration.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tolerations", value)

    class BuilderContext(BuilderContextBase["ImageBuild.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageBuild.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageBuild."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageBuild", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageBuild.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    affinity: Optional[v1.Affinity] = None
    build_timeout: Annotated[Optional[int], Field(alias="buildTimeout")] = None
    cnb_bindings: Annotated[Optional[List[core.CNBBinding]], Field(alias="cnbBindings")] = None
    creation_time: Annotated[Optional[str], Field(alias="creationTime")] = None
    env: Optional[List[v1.EnvVar]] = None
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    resources: Optional[v1.ResourceRequirements] = v1.ResourceRequirements.model_validate({})
    runtime_class_name: Annotated[Optional[str], Field(alias="runtimeClassName")] = None
    scheduler_name: Annotated[Optional[str], Field(alias="schedulerName")] = None
    services: Optional[List[v1.ObjectReference]] = None
    tolerations: Optional[List[v1.Toleration]] = None


class ImageSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageSpec"]:
            return ImageSpec

        def build(self) -> "ImageSpec":
            return ImageSpec(**self._attrs)

        def additional_tags(self, value: Optional[List[str]], /) -> Self:
            return self._set("additional_tags", value)

        @overload
        def build_(self, value_or_callback: Optional[ImageBuild], /) -> "ImageSpec.Builder": ...

        @overload
        def build_(
            self,
            value_or_callback: Callable[[ImageBuild.Builder], ImageBuild.Builder | ImageBuild],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def build_(self, value_or_callback: Never = ...) -> "ImageBuild.BuilderContext": ...

        def build_(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageBuild.BuilderContext()
                context._parent_builder = self
                context._field_name = "build"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageBuild.builder())
                if isinstance(output, ImageBuild.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build", value)

        @overload
        def builder_(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def builder_(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def builder_(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def builder_(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "builder_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("builder_", value)

        @overload
        def cache(
            self, value_or_callback: Optional[ImageCacheConfig], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def cache(
            self,
            value_or_callback: Callable[
                [ImageCacheConfig.Builder], ImageCacheConfig.Builder | ImageCacheConfig
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def cache(self, value_or_callback: Never = ...) -> "ImageCacheConfig.BuilderContext": ...

        def cache(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageCacheConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "cache"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageCacheConfig.builder())
                if isinstance(output, ImageCacheConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cache", value)

        @overload
        def cosign(self, value_or_callback: Optional[CosignConfig], /) -> "ImageSpec.Builder": ...

        @overload
        def cosign(
            self,
            value_or_callback: Callable[
                [CosignConfig.Builder], CosignConfig.Builder | CosignConfig
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def cosign(self, value_or_callback: Never = ...) -> "CosignConfig.BuilderContext": ...

        def cosign(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CosignConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "cosign"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CosignConfig.builder())
                if isinstance(output, CosignConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cosign", value)

        def default_process(self, value: Optional[str], /) -> Self:
            return self._set("default_process", value)

        def failed_build_history_limit(self, value: Optional[int], /) -> Self:
            return self._set("failed_build_history_limit", value)

        def image_tagging_strategy(self, value: Optional[str], /) -> Self:
            return self._set("image_tagging_strategy", value)

        @overload
        def notary(
            self, value_or_callback: Optional[core.NotaryConfig], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def notary(
            self,
            value_or_callback: Callable[
                [core.NotaryConfig.Builder],
                core.NotaryConfig.Builder | core.NotaryConfig,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def notary(self, value_or_callback: Never = ...) -> "core.NotaryConfig.BuilderContext": ...

        def notary(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.NotaryConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "notary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.NotaryConfig.builder())
                if isinstance(output, core.NotaryConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("notary", value)

        def project_descriptor_path(self, value: Optional[str], /) -> Self:
            return self._set("project_descriptor_path", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            return self._set("service_account_name", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.SourceConfig], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.SourceConfig.Builder],
                core.SourceConfig.Builder | core.SourceConfig,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "core.SourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.SourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.SourceConfig.builder())
                if isinstance(output, core.SourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

        def success_build_history_limit(self, value: Optional[int], /) -> Self:
            return self._set("success_build_history_limit", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["ImageSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_tags: Annotated[Optional[List[str]], Field(alias="additionalTags")] = None
    build: Optional[ImageBuild] = None
    builder_: Annotated[Optional[v1.ObjectReference], Field(alias="builder")] = (
        v1.ObjectReference.model_validate({})
    )
    cache: Optional[ImageCacheConfig] = None
    cosign: Optional[CosignConfig] = None
    default_process: Annotated[Optional[str], Field(alias="defaultProcess")] = None
    failed_build_history_limit: Annotated[Optional[int], Field(alias="failedBuildHistoryLimit")] = (
        None
    )
    image_tagging_strategy: Annotated[Optional[str], Field(alias="imageTaggingStrategy")] = None
    notary: Optional[core.NotaryConfig] = None
    project_descriptor_path: Annotated[Optional[str], Field(alias="projectDescriptorPath")] = None
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    source: Optional[core.SourceConfig] = core.SourceConfig.model_validate({})
    success_build_history_limit: Annotated[
        Optional[int], Field(alias="successBuildHistoryLimit")
    ] = None
    tag: Optional[str] = ""


class Build(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Build"]:
            return Build

        def build(self) -> "Build":
            return Build(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Build"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Build.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Build.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[BuildSpec], /) -> "Build.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BuildSpec.Builder], BuildSpec.Builder | BuildSpec],
            /,
        ) -> "Build.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BuildSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildSpec.builder())
                if isinstance(output, BuildSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BuildStatus], /) -> "Build.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[BuildStatus.Builder], BuildStatus.Builder | BuildStatus],
            /,
        ) -> "Build.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuildStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildStatus.builder())
                if isinstance(output, BuildStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Build.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Build.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Build."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Build", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Build.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Build"]] = "Build"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[BuildSpec] = BuildSpec.model_validate({})
    status: Optional[BuildStatus] = BuildStatus.model_validate({})


BuildList = ResourceList["Build"]


class Image(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Image"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Image.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Image.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[ImageSpec], /) -> "Image.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ImageSpec.Builder], ImageSpec.Builder | ImageSpec],
            /,
        ) -> "Image.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ImageSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageSpec.builder())
                if isinstance(output, ImageSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ImageStatus], /) -> "Image.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[ImageStatus.Builder], ImageStatus.Builder | ImageStatus],
            /,
        ) -> "Image.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ImageStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageStatus.builder())
                if isinstance(output, ImageStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Image.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Image.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Image."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha2"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Image"]] = "Image"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ImageSpec] = ImageSpec.model_validate({})
    status: Optional[ImageStatus] = ImageStatus.model_validate({})


ImageList = ResourceList["Image"]
