# Generated by cloudcoil-model-codegen v0.4.6
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.models.kubernetes.core import v1
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource, ResourceList

from . import core


class ClusterStackSpecImage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackSpecImage"]:
            return ClusterStackSpecImage

        def build(self) -> "ClusterStackSpecImage":
            return ClusterStackSpecImage(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

    class BuilderContext(BuilderContextBase["ClusterStackSpecImage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackSpecImage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackSpecImage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackSpecImage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackSpecImage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None


class ClusterStackStatusImage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackStatusImage"]:
            return ClusterStackStatusImage

        def build(self) -> "ClusterStackStatusImage":
            return ClusterStackStatusImage(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

    class BuilderContext(BuilderContextBase["ClusterStackStatusImage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackStatusImage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackStatusImage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackStatusImage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackStatusImage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None


class LastBuild(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LastBuild"]:
            return LastBuild

        def build(self) -> "LastBuild":
            return LastBuild(**self._attrs)

        def image(self, value: Optional[str], /) -> Self:
            return self._set("image", value)

        def stack_id(self, value: Optional[str], /) -> Self:
            return self._set("stack_id", value)

    class BuilderContext(BuilderContextBase["LastBuild.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LastBuild.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LastBuild."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LastBuild", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LastBuild.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image: Optional[str] = None
    stack_id: Annotated[Optional[str], Field(alias="stackId")] = None


class ResolvedClusterStack(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResolvedClusterStack"]:
            return ResolvedClusterStack

        def build(self) -> "ResolvedClusterStack":
            return ResolvedClusterStack(**self._attrs)

        @overload
        def build_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def build_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def build_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def build_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "build_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_image", value)

        def group_id(self, value: Optional[int], /) -> Self:
            return self._set("group_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def mixins(self, value: Optional[List[str]], /) -> Self:
            return self._set("mixins", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ResolvedClusterStack.Builder": ...

        @overload
        def run_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

        def user_id(self, value: Optional[int], /) -> Self:
            return self._set("user_id", value)

    class BuilderContext(BuilderContextBase["ResolvedClusterStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResolvedClusterStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResolvedClusterStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResolvedClusterStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResolvedClusterStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="buildImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    group_id: Annotated[Optional[int], Field(alias="groupId")] = None
    id: Optional[str] = None
    mixins: Optional[List[str]] = None
    run_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="runImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    user_id: Annotated[Optional[int], Field(alias="userId")] = None


class BuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderSpec"]:
            return BuilderSpec

        def build(self) -> "BuilderSpec":
            return BuilderSpec(**self._attrs)

        @overload
        def order(self, value_or_callback: List[core.OrderEntry], /) -> "BuilderSpec.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]],
                GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]
                | List[core.OrderEntry],
            ],
            /,
        ) -> "BuilderSpec.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.OrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.OrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.OrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        @overload
        def stack(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "BuilderSpec.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "BuilderSpec.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def store(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "BuilderSpec.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "BuilderSpec.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["BuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Optional[List[core.OrderEntry]] = None
    stack: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    store: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    tag: Optional[str] = None


class BuilderStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderStatus"]:
            return BuilderStatus

        def build(self) -> "BuilderStatus":
            return BuilderStatus(**self._attrs)

        @overload
        def builder_metadata(
            self, value_or_callback: List[core.BuildpackMetadata], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def builder_metadata(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]],
                GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]
                | List[core.BuildpackMetadata],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def builder_metadata(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackMetadata.Builder]: ...

        def builder_metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackMetadata.Builder]()
                context._parent_builder = self
                context._field_name = "builder_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackMetadata.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("builder_metadata", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def observed_stack_generation(self, value: Optional[int], /) -> Self:
            return self._set("observed_stack_generation", value)

        def observed_store_generation(self, value: Optional[int], /) -> Self:
            return self._set("observed_store_generation", value)

        @overload
        def order(self, value_or_callback: List[core.OrderEntry], /) -> "BuilderStatus.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]],
                GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]
                | List[core.OrderEntry],
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.OrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.OrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.OrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        def os(self, value: Optional[str], /) -> Self:
            return self._set("os", value)

        @overload
        def stack(
            self, value_or_callback: Optional[core.BuildStack], /
        ) -> "BuilderStatus.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [core.BuildStack.Builder], core.BuildStack.Builder | core.BuildStack
            ],
            /,
        ) -> "BuilderStatus.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "core.BuildStack.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.BuildStack.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildStack.builder())
                if isinstance(output, core.BuildStack.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

    class BuilderContext(BuilderContextBase["BuilderStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    builder_metadata: Annotated[
        Optional[List[core.BuildpackMetadata]], Field(alias="builderMetadata")
    ] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    observed_stack_generation: Annotated[Optional[int], Field(alias="observedStackGeneration")] = (
        None
    )
    observed_store_generation: Annotated[Optional[int], Field(alias="observedStoreGeneration")] = (
        None
    )
    order: Optional[List[core.OrderEntry]] = None
    os: Optional[str] = None
    stack: Optional[core.BuildStack] = core.BuildStack.model_validate({})


class ClusterBuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuilderSpec"]:
            return ClusterBuilderSpec

        def build(self) -> "ClusterBuilderSpec":
            return ClusterBuilderSpec(**self._attrs)

        @overload
        def order(
            self, value_or_callback: List[core.OrderEntry], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]],
                GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]
                | List[core.OrderEntry],
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.OrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.OrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.OrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        @overload
        def service_account_ref(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

        @overload
        def stack(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def store(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ClusterBuilderSpec.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["ClusterBuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Optional[List[core.OrderEntry]] = None
    service_account_ref: Annotated[
        Optional[v1.ObjectReference], Field(alias="serviceAccountRef")
    ] = v1.ObjectReference.model_validate({})
    stack: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    store: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    tag: Optional[str] = None


class ClusterStackSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackSpec"]:
            return ClusterStackSpec

        def build(self) -> "ClusterStackSpec":
            return ClusterStackSpec(**self._attrs)

        @overload
        def build_image(
            self, value_or_callback: Optional[ClusterStackSpecImage], /
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def build_image(
            self,
            value_or_callback: Callable[
                [ClusterStackSpecImage.Builder],
                ClusterStackSpecImage.Builder | ClusterStackSpecImage,
            ],
            /,
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def build_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackSpecImage.BuilderContext": ...

        def build_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackSpecImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "build_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackSpecImage.builder())
                if isinstance(output, ClusterStackSpecImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_image", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[ClusterStackSpecImage], /
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [ClusterStackSpecImage.Builder],
                ClusterStackSpecImage.Builder | ClusterStackSpecImage,
            ],
            /,
        ) -> "ClusterStackSpec.Builder": ...

        @overload
        def run_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackSpecImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackSpecImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackSpecImage.builder())
                if isinstance(output, ClusterStackSpecImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

    class BuilderContext(BuilderContextBase["ClusterStackSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_image: Annotated[Optional[ClusterStackSpecImage], Field(alias="buildImage")] = (
        ClusterStackSpecImage.model_validate({})
    )
    id: Optional[str] = None
    run_image: Annotated[Optional[ClusterStackSpecImage], Field(alias="runImage")] = (
        ClusterStackSpecImage.model_validate({})
    )


class ClusterStackStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStackStatus"]:
            return ClusterStackStatus

        def build(self) -> "ClusterStackStatus":
            return ClusterStackStatus(**self._attrs)

        @overload
        def build_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def build_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def build_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def build_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "build_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_image", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def group_id(self, value: Optional[int], /) -> Self:
            return self._set("group_id", value)

        def id(self, value: Optional[str], /) -> Self:
            return self._set("id", value)

        def mixins(self, value: Optional[List[str]], /) -> Self:
            return self._set("mixins", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def run_image(
            self, value_or_callback: Optional[ClusterStackStatusImage], /
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def run_image(
            self,
            value_or_callback: Callable[
                [ClusterStackStatusImage.Builder],
                ClusterStackStatusImage.Builder | ClusterStackStatusImage,
            ],
            /,
        ) -> "ClusterStackStatus.Builder": ...

        @overload
        def run_image(
            self, value_or_callback: Never = ...
        ) -> "ClusterStackStatusImage.BuilderContext": ...

        def run_image(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatusImage.BuilderContext()
                context._parent_builder = self
                context._field_name = "run_image"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatusImage.builder())
                if isinstance(output, ClusterStackStatusImage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("run_image", value)

        def user_id(self, value: Optional[int], /) -> Self:
            return self._set("user_id", value)

    class BuilderContext(BuilderContextBase["ClusterStackStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStackStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStackStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStackStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStackStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="buildImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    group_id: Annotated[Optional[int], Field(alias="groupId")] = None
    id: Optional[str] = None
    mixins: Optional[List[str]] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    run_image: Annotated[Optional[ClusterStackStatusImage], Field(alias="runImage")] = (
        ClusterStackStatusImage.model_validate({})
    )
    user_id: Annotated[Optional[int], Field(alias="userId")] = None


class ClusterStoreSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStoreSpec"]:
            return ClusterStoreSpec

        def build(self) -> "ClusterStoreSpec":
            return ClusterStoreSpec(**self._attrs)

        @overload
        def sources(
            self, value_or_callback: List[core.ImageSource], /
        ) -> "ClusterStoreSpec.Builder": ...

        @overload
        def sources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.ImageSource, core.ImageSource.Builder]],
                GenericListBuilder[core.ImageSource, core.ImageSource.Builder]
                | List[core.ImageSource],
            ],
            /,
        ) -> "ClusterStoreSpec.Builder": ...

        @overload
        def sources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.ImageSource.Builder]: ...

        def sources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.ImageSource.Builder]()
                context._parent_builder = self
                context._field_name = "sources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.ImageSource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sources", value)

    class BuilderContext(BuilderContextBase["ClusterStoreSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStoreSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStoreSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStoreSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStoreSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    sources: Optional[List[core.ImageSource]] = None


class ImageStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageStatus"]:
            return ImageStatus

        def build(self) -> "ImageStatus":
            return ImageStatus(**self._attrs)

        def build_cache_name(self, value: Optional[str], /) -> Self:
            return self._set("build_cache_name", value)

        def build_counter(self, value: Optional[int], /) -> Self:
            return self._set("build_counter", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ImageStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ImageStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_build_image_generation(self, value: Optional[int], /) -> Self:
            return self._set("latest_build_image_generation", value)

        def latest_build_reason(self, value: Optional[str], /) -> Self:
            return self._set("latest_build_reason", value)

        def latest_build_ref(self, value: Optional[str], /) -> Self:
            return self._set("latest_build_ref", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

        def latest_stack(self, value: Optional[str], /) -> Self:
            return self._set("latest_stack", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ImageStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_cache_name: Annotated[Optional[str], Field(alias="buildCacheName")] = None
    build_counter: Annotated[Optional[int], Field(alias="buildCounter")] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_build_image_generation: Annotated[
        Optional[int], Field(alias="latestBuildImageGeneration")
    ] = None
    latest_build_reason: Annotated[Optional[str], Field(alias="latestBuildReason")] = None
    latest_build_ref: Annotated[Optional[str], Field(alias="latestBuildRef")] = None
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    latest_stack: Annotated[Optional[str], Field(alias="latestStack")] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class NamespacedBuilderSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespacedBuilderSpec"]:
            return NamespacedBuilderSpec

        def build(self) -> "NamespacedBuilderSpec":
            return NamespacedBuilderSpec(**self._attrs)

        @overload
        def order(
            self, value_or_callback: List[core.OrderEntry], /
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def order(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]],
                GenericListBuilder[core.OrderEntry, core.OrderEntry.Builder]
                | List[core.OrderEntry],
            ],
            /,
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def order(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.OrderEntry.Builder]: ...

        def order(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.OrderEntry.Builder]()
                context._parent_builder = self
                context._field_name = "order"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.OrderEntry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("order", value)

        def service_account(self, value: Optional[str], /) -> Self:
            return self._set("service_account", value)

        @overload
        def stack(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def store(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "NamespacedBuilderSpec.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "v1.ObjectReference.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["NamespacedBuilderSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespacedBuilderSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespacedBuilderSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespacedBuilderSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespacedBuilderSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    order: Optional[List[core.OrderEntry]] = None
    service_account: Annotated[Optional[str], Field(alias="serviceAccount")] = None
    stack: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    store: Optional[v1.ObjectReference] = v1.ObjectReference.model_validate({})
    tag: Optional[str] = None


class SourceResolverSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceResolverSpec"]:
            return SourceResolverSpec

        def build(self) -> "SourceResolverSpec":
            return SourceResolverSpec(**self._attrs)

        def service_account(self, value: Optional[str], /) -> Self:
            return self._set("service_account", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.SourceConfig], /
        ) -> "SourceResolverSpec.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.SourceConfig.Builder],
                core.SourceConfig.Builder | core.SourceConfig,
            ],
            /,
        ) -> "SourceResolverSpec.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "core.SourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.SourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.SourceConfig.builder())
                if isinstance(output, core.SourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["SourceResolverSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceResolverSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceResolverSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceResolverSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceResolverSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account: Annotated[Optional[str], Field(alias="serviceAccount")] = None
    source: Optional[core.SourceConfig] = core.SourceConfig.model_validate({})


class SourceResolverStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceResolverStatus"]:
            return SourceResolverStatus

        def build(self) -> "SourceResolverStatus":
            return SourceResolverStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.ResolvedSourceConfig], /
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.ResolvedSourceConfig.Builder],
                core.ResolvedSourceConfig.Builder | core.ResolvedSourceConfig,
            ],
            /,
        ) -> "SourceResolverStatus.Builder": ...

        @overload
        def source(
            self, value_or_callback: Never = ...
        ) -> "core.ResolvedSourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.ResolvedSourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.ResolvedSourceConfig.builder())
                if isinstance(output, core.ResolvedSourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["SourceResolverStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceResolverStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceResolverStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceResolverStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceResolverStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    source: Optional[core.ResolvedSourceConfig] = core.ResolvedSourceConfig.model_validate({})


class BuildStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildStatus"]:
            return BuildStatus

        def build(self) -> "BuildStatus":
            return BuildStatus(**self._attrs)

        @overload
        def build_metadata(
            self, value_or_callback: List[core.BuildpackMetadata], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def build_metadata(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]],
                GenericListBuilder[core.BuildpackMetadata, core.BuildpackMetadata.Builder]
                | List[core.BuildpackMetadata],
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def build_metadata(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackMetadata.Builder]: ...

        def build_metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackMetadata.Builder]()
                context._parent_builder = self
                context._field_name = "build_metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackMetadata.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("build_metadata", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_image(self, value: Optional[str], /) -> Self:
            return self._set("latest_image", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def pod_name(self, value: Optional[str], /) -> Self:
            return self._set("pod_name", value)

        @overload
        def stack(
            self, value_or_callback: Optional[core.BuildStack], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def stack(
            self,
            value_or_callback: Callable[
                [core.BuildStack.Builder], core.BuildStack.Builder | core.BuildStack
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def stack(self, value_or_callback: Never = ...) -> "core.BuildStack.BuilderContext": ...

        def stack(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.BuildStack.BuilderContext()
                context._parent_builder = self
                context._field_name = "stack"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildStack.builder())
                if isinstance(output, core.BuildStack.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("stack", value)

        @overload
        def step_states(
            self, value_or_callback: List[v1.ContainerState], /
        ) -> "BuildStatus.Builder": ...

        @overload
        def step_states(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.ContainerState, v1.ContainerState.Builder]],
                GenericListBuilder[v1.ContainerState, v1.ContainerState.Builder]
                | List[v1.ContainerState],
            ],
            /,
        ) -> "BuildStatus.Builder": ...

        @overload
        def step_states(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[v1.ContainerState.Builder]: ...

        def step_states(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.ContainerState.Builder]()
                context._parent_builder = self
                context._field_name = "step_states"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ContainerState.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("step_states", value)

        def steps_completed(self, value: Optional[List[str]], /) -> Self:
            return self._set("steps_completed", value)

    class BuilderContext(BuilderContextBase["BuildStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build_metadata: Annotated[
        Optional[List[core.BuildpackMetadata]], Field(alias="buildMetadata")
    ] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_image: Annotated[Optional[str], Field(alias="latestImage")] = None
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    pod_name: Annotated[Optional[str], Field(alias="podName")] = None
    stack: Optional[core.BuildStack] = core.BuildStack.model_validate({})
    step_states: Annotated[Optional[List[v1.ContainerState]], Field(alias="stepStates")] = None
    steps_completed: Annotated[Optional[List[str]], Field(alias="stepsCompleted")] = None


class BuilderResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderResource"]:
            return BuilderResource

        def build(self) -> "BuilderResource":
            return BuilderResource(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Builder"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BuilderResource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BuilderResource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[NamespacedBuilderSpec], /
        ) -> "BuilderResource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [NamespacedBuilderSpec.Builder],
                NamespacedBuilderSpec.Builder | NamespacedBuilderSpec,
            ],
            /,
        ) -> "BuilderResource.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "NamespacedBuilderSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = NamespacedBuilderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespacedBuilderSpec.builder())
                if isinstance(output, NamespacedBuilderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BuilderStatus], /
        ) -> "BuilderResource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BuilderStatus.Builder], BuilderStatus.Builder | BuilderStatus
            ],
            /,
        ) -> "BuilderResource.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuilderStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuilderStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderStatus.builder())
                if isinstance(output, BuilderStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BuilderResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Builder"]] = "Builder"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[NamespacedBuilderSpec] = NamespacedBuilderSpec.model_validate({})
    status: Optional[BuilderStatus] = BuilderStatus.model_validate({})


class BuilderResourceList(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuilderResourceList"]:
            return BuilderResourceList

        def build(self) -> "BuilderResourceList":
            return BuilderResourceList(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        @overload
        def items(
            self, value_or_callback: List[BuilderResource], /
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BuilderResource, BuilderResource.Builder]],
                GenericListBuilder[BuilderResource, BuilderResource.Builder]
                | List[BuilderResource],
            ],
            /,
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BuilderResource.Builder]: ...

        def items(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BuilderResource.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderResource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ListMeta], /
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ListMeta.Builder],
                apimachinery.ListMeta.Builder | apimachinery.ListMeta,
            ],
            /,
        ) -> "BuilderResourceList.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ListMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ListMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ListMeta.builder())
                if isinstance(output, apimachinery.ListMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["BuilderResourceList.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuilderResourceList.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuilderResourceList."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuilderResourceList", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuilderResourceList.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    items: List[BuilderResource]
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ListMeta] = apimachinery.ListMeta.model_validate({})


class ClusterBuilder(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBuilder"]:
            return ClusterBuilder

        def build(self) -> "ClusterBuilder":
            return ClusterBuilder(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterBuilder"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterBuilderSpec], /
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterBuilderSpec.Builder],
                ClusterBuilderSpec.Builder | ClusterBuilderSpec,
            ],
            /,
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterBuilderSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterBuilderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterBuilderSpec.builder())
                if isinstance(output, ClusterBuilderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BuilderStatus], /
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BuilderStatus.Builder], BuilderStatus.Builder | BuilderStatus
            ],
            /,
        ) -> "ClusterBuilder.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuilderStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuilderStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuilderStatus.builder())
                if isinstance(output, BuilderStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterBuilder.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBuilder.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBuilder."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBuilder", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBuilder.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterBuilder"]] = "ClusterBuilder"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterBuilderSpec] = ClusterBuilderSpec.model_validate({})
    status: Optional[BuilderStatus] = BuilderStatus.model_validate({})


ClusterBuilderList = ResourceList["ClusterBuilder"]


class ClusterStack(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStack"]:
            return ClusterStack

        def build(self) -> "ClusterStack":
            return ClusterStack(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterStack"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterStack.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterStack.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterStackSpec], /
        ) -> "ClusterStack.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterStackSpec.Builder], ClusterStackSpec.Builder | ClusterStackSpec
            ],
            /,
        ) -> "ClusterStack.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterStackSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackSpec.builder())
                if isinstance(output, ClusterStackSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterStackStatus], /
        ) -> "ClusterStack.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterStackStatus.Builder],
                ClusterStackStatus.Builder | ClusterStackStatus,
            ],
            /,
        ) -> "ClusterStack.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ClusterStackStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStackStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStackStatus.builder())
                if isinstance(output, ClusterStackStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterStack.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStack.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStack."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStack", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStack.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterStack"]] = "ClusterStack"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterStackSpec] = ClusterStackSpec.model_validate({})
    status: Optional[ClusterStackStatus] = ClusterStackStatus.model_validate({})


ClusterStackList = ResourceList["ClusterStack"]


class ClusterStoreStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStoreStatus"]:
            return ClusterStoreStatus

        def build(self) -> "ClusterStoreStatus":
            return ClusterStoreStatus(**self._attrs)

        @overload
        def buildpacks(
            self, value_or_callback: List[core.BuildpackStatus], /
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def buildpacks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]],
                GenericListBuilder[core.BuildpackStatus, core.BuildpackStatus.Builder]
                | List[core.BuildpackStatus],
            ],
            /,
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def buildpacks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.BuildpackStatus.Builder]: ...

        def buildpacks(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.BuildpackStatus.Builder]()
                context._parent_builder = self
                context._field_name = "buildpacks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildpackStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("buildpacks", value)

        @overload
        def conditions(
            self, value_or_callback: List[core.Condition], /
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.Condition, core.Condition.Builder]],
                GenericListBuilder[core.Condition, core.Condition.Builder] | List[core.Condition],
            ],
            /,
        ) -> "ClusterStoreStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ClusterStoreStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStoreStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStoreStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStoreStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStoreStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    buildpacks: Optional[List[core.BuildpackStatus]] = None
    conditions: Optional[List[core.Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class SourceResolver(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceResolver"]:
            return SourceResolver

        def build(self) -> "SourceResolver":
            return SourceResolver(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["SourceResolver"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "SourceResolver.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "SourceResolver.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[SourceResolverSpec], /
        ) -> "SourceResolver.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [SourceResolverSpec.Builder],
                SourceResolverSpec.Builder | SourceResolverSpec,
            ],
            /,
        ) -> "SourceResolver.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SourceResolverSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SourceResolverSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceResolverSpec.builder())
                if isinstance(output, SourceResolverSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[SourceResolverStatus], /
        ) -> "SourceResolver.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SourceResolverStatus.Builder],
                SourceResolverStatus.Builder | SourceResolverStatus,
            ],
            /,
        ) -> "SourceResolver.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "SourceResolverStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SourceResolverStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceResolverStatus.builder())
                if isinstance(output, SourceResolverStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["SourceResolver.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceResolver.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceResolver."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceResolver", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceResolver.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["SourceResolver"]] = "SourceResolver"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[SourceResolverSpec] = SourceResolverSpec.model_validate({})
    status: Optional[SourceResolverStatus] = SourceResolverStatus.model_validate({})


SourceResolverList = ResourceList["SourceResolver"]


class BuildSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BuildSpec"]:
            return BuildSpec

        def build(self) -> "BuildSpec":
            return BuildSpec(**self._attrs)

        @overload
        def bindings(self, value_or_callback: List[core.CNBBinding], /) -> "BuildSpec.Builder": ...

        @overload
        def bindings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]],
                GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]
                | List[core.CNBBinding],
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def bindings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.CNBBinding.Builder]: ...

        def bindings(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.CNBBinding.Builder]()
                context._parent_builder = self
                context._field_name = "bindings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.CNBBinding.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("bindings", value)

        @overload
        def builder_(
            self, value_or_callback: Optional[core.BuildBuilderSpec], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def builder_(
            self,
            value_or_callback: Callable[
                [core.BuildBuilderSpec.Builder],
                core.BuildBuilderSpec.Builder | core.BuildBuilderSpec,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def builder_(
            self, value_or_callback: Never = ...
        ) -> "core.BuildBuilderSpec.BuilderContext": ...

        def builder_(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.BuildBuilderSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "builder_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.BuildBuilderSpec.builder())
                if isinstance(output, core.BuildBuilderSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("builder_", value)

        def cache_name(self, value: Optional[str], /) -> Self:
            return self._set("cache_name", value)

        @overload
        def env(self, value_or_callback: List[v1.EnvVar], /) -> "BuildSpec.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder]],
                GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder] | List[v1.EnvVar],
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[v1.EnvVar.Builder]: ...

        def env(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.EnvVar.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.EnvVar.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def last_build(self, value_or_callback: Optional[LastBuild], /) -> "BuildSpec.Builder": ...

        @overload
        def last_build(
            self,
            value_or_callback: Callable[[LastBuild.Builder], LastBuild.Builder | LastBuild],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def last_build(self, value_or_callback: Never = ...) -> "LastBuild.BuilderContext": ...

        def last_build(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = LastBuild.BuilderContext()
                context._parent_builder = self
                context._field_name = "last_build"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LastBuild.builder())
                if isinstance(output, LastBuild.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("last_build", value)

        @overload
        def notary(
            self, value_or_callback: Optional[core.NotaryConfig], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def notary(
            self,
            value_or_callback: Callable[
                [core.NotaryConfig.Builder],
                core.NotaryConfig.Builder | core.NotaryConfig,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def notary(self, value_or_callback: Never = ...) -> "core.NotaryConfig.BuilderContext": ...

        def notary(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.NotaryConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "notary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.NotaryConfig.builder())
                if isinstance(output, core.NotaryConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("notary", value)

        @overload
        def resources(
            self, value_or_callback: Optional[v1.ResourceRequirements], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [v1.ResourceRequirements.Builder],
                v1.ResourceRequirements.Builder | v1.ResourceRequirements,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> "v1.ResourceRequirements.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ResourceRequirements.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ResourceRequirements.builder())
                if isinstance(output, v1.ResourceRequirements.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def service_account(self, value: Optional[str], /) -> Self:
            return self._set("service_account", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.SourceConfig], /
        ) -> "BuildSpec.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.SourceConfig.Builder],
                core.SourceConfig.Builder | core.SourceConfig,
            ],
            /,
        ) -> "BuildSpec.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "core.SourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.SourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.SourceConfig.builder())
                if isinstance(output, core.SourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

        def tags(self, value: Optional[List[str]], /) -> Self:
            return self._set("tags", value)

    class BuilderContext(BuilderContextBase["BuildSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BuildSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BuildSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BuildSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BuildSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bindings: Optional[List[core.CNBBinding]] = None
    builder_: Annotated[Optional[core.BuildBuilderSpec], Field(alias="builder")] = (
        core.BuildBuilderSpec.model_validate({})
    )
    cache_name: Annotated[Optional[str], Field(alias="cacheName")] = None
    env: Optional[List[v1.EnvVar]] = None
    last_build: Annotated[Optional[LastBuild], Field(alias="lastBuild")] = None
    notary: Optional[core.NotaryConfig] = None
    resources: Optional[v1.ResourceRequirements] = v1.ResourceRequirements.model_validate({})
    service_account: Annotated[Optional[str], Field(alias="serviceAccount")] = None
    source: Optional[core.SourceConfig] = core.SourceConfig.model_validate({})
    tags: Optional[List[str]] = None


class ClusterStore(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterStore"]:
            return ClusterStore

        def build(self) -> "ClusterStore":
            return ClusterStore(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterStore"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterStore.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterStore.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterStoreSpec], /
        ) -> "ClusterStore.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterStoreSpec.Builder], ClusterStoreSpec.Builder | ClusterStoreSpec
            ],
            /,
        ) -> "ClusterStore.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterStoreSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStoreSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStoreSpec.builder())
                if isinstance(output, ClusterStoreSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterStoreStatus], /
        ) -> "ClusterStore.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterStoreStatus.Builder],
                ClusterStoreStatus.Builder | ClusterStoreStatus,
            ],
            /,
        ) -> "ClusterStore.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ClusterStoreStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterStoreStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterStoreStatus.builder())
                if isinstance(output, ClusterStoreStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterStore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterStore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterStore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterStore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterStore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterStore"]] = "ClusterStore"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ClusterStoreSpec] = ClusterStoreSpec.model_validate({})
    status: Optional[ClusterStoreStatus] = ClusterStoreStatus.model_validate({})


ClusterStoreList = ResourceList["ClusterStore"]


class ImageBuild(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageBuild"]:
            return ImageBuild

        def build(self) -> "ImageBuild":
            return ImageBuild(**self._attrs)

        @overload
        def bindings(self, value_or_callback: List[core.CNBBinding], /) -> "ImageBuild.Builder": ...

        @overload
        def bindings(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]],
                GenericListBuilder[core.CNBBinding, core.CNBBinding.Builder]
                | List[core.CNBBinding],
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def bindings(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[core.CNBBinding.Builder]: ...

        def bindings(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[core.CNBBinding.Builder]()
                context._parent_builder = self
                context._field_name = "bindings"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.CNBBinding.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("bindings", value)

        @overload
        def env(self, value_or_callback: List[v1.EnvVar], /) -> "ImageBuild.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder]],
                GenericListBuilder[v1.EnvVar, v1.EnvVar.Builder] | List[v1.EnvVar],
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[v1.EnvVar.Builder]: ...

        def env(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[v1.EnvVar.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.EnvVar.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def resources(
            self, value_or_callback: Optional[v1.ResourceRequirements], /
        ) -> "ImageBuild.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [v1.ResourceRequirements.Builder],
                v1.ResourceRequirements.Builder | v1.ResourceRequirements,
            ],
            /,
        ) -> "ImageBuild.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> "v1.ResourceRequirements.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ResourceRequirements.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ResourceRequirements.builder())
                if isinstance(output, v1.ResourceRequirements.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

    class BuilderContext(BuilderContextBase["ImageBuild.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageBuild.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageBuild."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageBuild", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageBuild.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bindings: Optional[List[core.CNBBinding]] = None
    env: Optional[List[v1.EnvVar]] = None
    resources: Optional[v1.ResourceRequirements] = v1.ResourceRequirements.model_validate({})


class ImageSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageSpec"]:
            return ImageSpec

        def build(self) -> "ImageSpec":
            return ImageSpec(**self._attrs)

        @overload
        def build_(self, value_or_callback: Optional[ImageBuild], /) -> "ImageSpec.Builder": ...

        @overload
        def build_(
            self,
            value_or_callback: Callable[[ImageBuild.Builder], ImageBuild.Builder | ImageBuild],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def build_(self, value_or_callback: Never = ...) -> "ImageBuild.BuilderContext": ...

        def build_(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageBuild.BuilderContext()
                context._parent_builder = self
                context._field_name = "build"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageBuild.builder())
                if isinstance(output, ImageBuild.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("build", value)

        @overload
        def builder_(
            self, value_or_callback: Optional[v1.ObjectReference], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def builder_(
            self,
            value_or_callback: Callable[
                [v1.ObjectReference.Builder],
                v1.ObjectReference.Builder | v1.ObjectReference,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def builder_(
            self, value_or_callback: Never = ...
        ) -> "v1.ObjectReference.BuilderContext": ...

        def builder_(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "builder_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectReference.builder())
                if isinstance(output, v1.ObjectReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("builder_", value)

        @overload
        def cache_size(
            self, value_or_callback: Optional[apimachinery.Quantity], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def cache_size(
            self,
            value_or_callback: Callable[
                [apimachinery.Quantity.Builder],
                apimachinery.Quantity.Builder | apimachinery.Quantity,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def cache_size(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.Quantity.BuilderContext": ...

        def cache_size(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.Quantity.BuilderContext()
                context._parent_builder = self
                context._field_name = "cache_size"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.Quantity.builder())
                if isinstance(output, apimachinery.Quantity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cache_size", value)

        def failed_build_history_limit(self, value: Optional[int], /) -> Self:
            return self._set("failed_build_history_limit", value)

        def image_tagging_strategy(self, value: Optional[str], /) -> Self:
            return self._set("image_tagging_strategy", value)

        @overload
        def notary(
            self, value_or_callback: Optional[core.NotaryConfig], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def notary(
            self,
            value_or_callback: Callable[
                [core.NotaryConfig.Builder],
                core.NotaryConfig.Builder | core.NotaryConfig,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def notary(self, value_or_callback: Never = ...) -> "core.NotaryConfig.BuilderContext": ...

        def notary(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.NotaryConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "notary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.NotaryConfig.builder())
                if isinstance(output, core.NotaryConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("notary", value)

        def service_account(self, value: Optional[str], /) -> Self:
            return self._set("service_account", value)

        @overload
        def source(
            self, value_or_callback: Optional[core.SourceConfig], /
        ) -> "ImageSpec.Builder": ...

        @overload
        def source(
            self,
            value_or_callback: Callable[
                [core.SourceConfig.Builder],
                core.SourceConfig.Builder | core.SourceConfig,
            ],
            /,
        ) -> "ImageSpec.Builder": ...

        @overload
        def source(self, value_or_callback: Never = ...) -> "core.SourceConfig.BuilderContext": ...

        def source(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = core.SourceConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "source"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(core.SourceConfig.builder())
                if isinstance(output, core.SourceConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source", value)

        def success_build_history_limit(self, value: Optional[int], /) -> Self:
            return self._set("success_build_history_limit", value)

        def tag(self, value: Optional[str], /) -> Self:
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["ImageSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    build: Optional[ImageBuild] = None
    builder_: Annotated[Optional[v1.ObjectReference], Field(alias="builder")] = (
        v1.ObjectReference.model_validate({})
    )
    cache_size: Annotated[Optional[apimachinery.Quantity], Field(alias="cacheSize")] = None
    failed_build_history_limit: Annotated[Optional[int], Field(alias="failedBuildHistoryLimit")] = (
        None
    )
    image_tagging_strategy: Annotated[Optional[str], Field(alias="imageTaggingStrategy")] = None
    notary: Optional[core.NotaryConfig] = None
    service_account: Annotated[Optional[str], Field(alias="serviceAccount")] = None
    source: Optional[core.SourceConfig] = core.SourceConfig.model_validate({})
    success_build_history_limit: Annotated[
        Optional[int], Field(alias="successBuildHistoryLimit")
    ] = None
    tag: Optional[str] = ""


class Build(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Build"]:
            return Build

        def build(self) -> "Build":
            return Build(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Build"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Build.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Build.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[BuildSpec], /) -> "Build.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BuildSpec.Builder], BuildSpec.Builder | BuildSpec],
            /,
        ) -> "Build.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BuildSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildSpec.builder())
                if isinstance(output, BuildSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BuildStatus], /) -> "Build.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[BuildStatus.Builder], BuildStatus.Builder | BuildStatus],
            /,
        ) -> "Build.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BuildStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BuildStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BuildStatus.builder())
                if isinstance(output, BuildStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Build.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Build.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Build."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Build", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Build.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Build"]] = "Build"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[BuildSpec] = BuildSpec.model_validate({})
    status: Optional[BuildStatus] = BuildStatus.model_validate({})


BuildList = ResourceList["Build"]


class Image(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Image"]:
            return Image

        def build(self) -> "Image":
            return Image(**self._attrs)

        def api_version(self, value: Optional[Literal["kpack.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Image"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Image.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Image.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[ImageSpec], /) -> "Image.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ImageSpec.Builder], ImageSpec.Builder | ImageSpec],
            /,
        ) -> "Image.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ImageSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageSpec.builder())
                if isinstance(output, ImageSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ImageStatus], /) -> "Image.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[ImageStatus.Builder], ImageStatus.Builder | ImageStatus],
            /,
        ) -> "Image.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ImageStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ImageStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageStatus.builder())
                if isinstance(output, ImageStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Image.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Image.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Image."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Image", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Image.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kpack.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "kpack.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Image"]] = "Image"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = apimachinery.ObjectMeta.model_validate({})
    spec: Optional[ImageSpec] = ImageSpec.model_validate({})
    status: Optional[ImageStatus] = ImageStatus.model_validate({})


ImageList = ResourceList["Image"]
