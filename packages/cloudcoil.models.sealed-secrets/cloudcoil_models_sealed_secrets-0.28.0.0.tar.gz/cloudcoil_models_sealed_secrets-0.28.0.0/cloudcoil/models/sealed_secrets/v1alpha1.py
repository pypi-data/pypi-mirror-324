# Generated by cloudcoil-model-codegen v0.4.3
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("annotations", value)

        def finalizers(self, value: Optional[List[str]], /) -> Self:
            return self._set("finalizers", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("labels", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    finalizers: Optional[List[str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        def data(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Keys that should be templated using decrypted data.
            """
            return self._set("data", value)

        def immutable(self, value: Optional[bool], /) -> Self:
            """
            Immutable, if set to true, ensures that data stored in the Secret cannot
            be updated (only object metadata can be modified).
            If not set to true, the field can be modified at any time.
            Defaulted to nil.
            """
            return self._set("immutable", value)

        @overload
        def metadata(self, value_or_callback: Optional[Metadata], /) -> "Template.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "Template.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object's metadata.
            More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Used to facilitate programmatic handling of secret data.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[Dict[str, str]] = None
    """
    Keys that should be templated using decrypted data.
    """
    immutable: Optional[bool] = None
    """
    Immutable, if set to true, ensures that data stored in the Secret cannot
    be updated (only object metadata can be modified).
    If not set to true, the field can be modified at any time.
    Defaulted to nil.
    """
    metadata: Optional[Metadata] = None
    """
    Standard object's metadata.
    More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
    """
    type: Optional[str] = None
    """
    Used to facilitate programmatic handling of secret data.
    """


class SealedSecretSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SealedSecretSpec"]:
            return SealedSecretSpec

        def build(self) -> "SealedSecretSpec":
            return SealedSecretSpec(**self._attrs)

        def data(self, value: Optional[str], /) -> Self:
            """
            Data is deprecated and will be removed eventually. Use per-value EncryptedData instead.
            """
            return self._set("data", value)

        def encrypted_data(self, value: Dict[str, str], /) -> Self:
            return self._set("encrypted_data", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "SealedSecretSpec.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "SealedSecretSpec.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            Template defines the structure of the Secret that will be
            created from this sealed secret.
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["SealedSecretSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SealedSecretSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SealedSecretSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SealedSecretSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SealedSecretSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[str] = None
    """
    Data is deprecated and will be removed eventually. Use per-value EncryptedData instead.
    """
    encrypted_data: Annotated[Dict[str, str], Field(alias="encryptedData")]
    template: Optional[Template] = None
    """
    Template defines the structure of the Secret that will be
    created from this sealed secret.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[datetime], /) -> Self:
            """
            Last time the condition transitioned from one status to another.
            """
            return self._set("last_transition_time", value)

        def last_update_time(self, value: Optional[datetime], /) -> Self:
            """
            The last time this condition was updated.
            """
            return self._set("last_update_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition for a sealed secret.
            Valid values for "Synced": "True", "False", or "Unknown".
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition for a sealed secret.
            Valid value: "Synced"
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[datetime], Field(alias="lastTransitionTime")] = None
    """
    Last time the condition transitioned from one status to another.
    """
    last_update_time: Annotated[Optional[datetime], Field(alias="lastUpdateTime")] = None
    """
    The last time this condition was updated.
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    status: str
    """
    Status of the condition for a sealed secret.
    Valid values for "Synced": "True", "False", or "Unknown".
    """
    type: str
    """
    Type of condition for a sealed secret.
    Valid value: "Synced"
    """


class SealedSecretStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SealedSecretStatus"]:
            return SealedSecretStatus

        def build(self) -> "SealedSecretStatus":
            return SealedSecretStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "SealedSecretStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "SealedSecretStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Represents the latest available observations of a sealed secret's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration reflects the generation most recently observed by the sealed-secrets controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["SealedSecretStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SealedSecretStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SealedSecretStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SealedSecretStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SealedSecretStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Represents the latest available observations of a sealed secret's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration reflects the generation most recently observed by the sealed-secrets controller.
    """


class SealedSecret(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SealedSecret"]:
            return SealedSecret

        def build(self) -> "SealedSecret":
            return SealedSecret(**self._attrs)

        def api_version(self, value: Optional[Literal["bitnami.com/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["SealedSecret"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "SealedSecret.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "SealedSecret.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: SealedSecretSpec, /) -> "SealedSecret.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [SealedSecretSpec.Builder], SealedSecretSpec.Builder | SealedSecretSpec
            ],
            /,
        ) -> "SealedSecret.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SealedSecretSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SealedSecretSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SealedSecretSpec.builder())
                if isinstance(output, SealedSecretSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[SealedSecretStatus], /
        ) -> "SealedSecret.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SealedSecretStatus.Builder],
                SealedSecretStatus.Builder | SealedSecretStatus,
            ],
            /,
        ) -> "SealedSecret.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "SealedSecretStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SealedSecretStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SealedSecretStatus.builder())
                if isinstance(output, SealedSecretStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["SealedSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SealedSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SealedSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SealedSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SealedSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["bitnami.com/v1alpha1"]], Field(alias="apiVersion")] = (
        "bitnami.com/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["SealedSecret"]] = "SealedSecret"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: SealedSecretSpec
    status: Optional[SealedSecretStatus] = None
