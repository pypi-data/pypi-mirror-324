# Code generated by generate_api.py. DO NOT EDIT.
# Client library for Diagonal's geospatial analysis engine, b6.

from __future__ import annotations

from typing import Callable

import diagonal_b6.expression
from diagonal_b6.expression import Call, Symbol, Lambda, Result, QueryConversionTraits, register_builtin_result
from diagonal_b6.features import CollectionFeatureResultTraits

VERSION = '0.2.3'

class AnyAnyCollectionTraits:

    def count_values(self) -> AnyIntCollectionResult:
        return count_values(self)

    def histogram_swatch(self) -> ChangeTraits:
        return histogram_swatch(self)

    def take(self, n: IntTraits) -> AnyAnyCollectionResult:
        return take(self, n)

    def histogram_with_id(self, id: CollectionIDTraits) -> ChangeTraits:
        return histogram_with_id(self, id)

    def map_parallel(self, function: CallableTraits) -> AnyAnyCollectionResult:
        return map_parallel(self, function)

    def map(self, function: CallableTraits) -> AnyAnyCollectionResult:
        return map(self, function)

    def top(self, n: IntTraits) -> AnyAnyCollectionResult:
        return top(self, n)

    def count(self) -> IntTraits:
        return count(self)

    def histogram(self) -> ChangeTraits:
        return histogram(self)

    def map_items(self, function: CallableTraits) -> AnyAnyCollectionResult:
        return map_items(self, function)

    def histogram_swatch_with_id(self, id: CollectionIDTraits) -> ChangeTraits:
        return histogram_swatch_with_id(self, id)

    def join_missing(self, joined: AnyAnyCollectionResult) -> AnyAnyCollectionResult:
        return join_missing(self, joined)

    def count_valid_keys(self) -> AnyIntCollectionResult:
        return count_valid_keys(self)

    def filter(self, function: CallableTraits) -> AnyAnyCollectionResult:
        return filter(self, function)

    def count_keys(self) -> AnyIntCollectionResult:
        return count_keys(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyAnyCollectionValuesTraits:

    def count_values(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(count_values, [self._values()]))

    def histogram_swatch(self) -> AnyChangeCollectionTraits:
        return self.map(Lambda(histogram_swatch, [self._values()]))

    def take(self, n: IntTraits) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: take(x, n), [self._values()]))

    def histogram_with_id(self, id: CollectionIDTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: histogram_with_id(x, id), [self._values()]))

    def map_parallel(self, function: CallableTraits) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: map_parallel(x, function), [self._values()]))

    def map(self, function: CallableTraits) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: map(x, function), [self._values()]))

    def top(self, n: IntTraits) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: top(x, n), [self._values()]))

    def count(self) -> AnyIntCollectionTraits:
        return self.map(Lambda(count, [self._values()]))

    def histogram(self) -> AnyChangeCollectionTraits:
        return self.map(Lambda(histogram, [self._values()]))

    def map_items(self, function: CallableTraits) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: map_items(x, function), [self._values()]))

    def histogram_swatch_with_id(self, id: CollectionIDTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: histogram_swatch_with_id(x, id), [self._values()]))

    def join_missing(self, joined: AnyAnyCollectionResult) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: join_missing(x, joined), [self._values()]))

    def count_valid_keys(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(count_valid_keys, [self._values()]))

    def filter(self, function: CallableTraits) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(lambda x: filter(x, function), [self._values()]))

    def count_keys(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(count_keys, [self._values()]))

class AnyAnyAnyCollectionValuesResult(Result, AnyAnyCollectionValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AnyAnyCollectionResult

class IdentifiableTraits:

    def matches(self, query: QueryTraits) -> BoolTraits:
        return matches(self, query)

    def count_tag_value(self, key: StringTraits) -> AnyIntCollectionResult:
        return count_tag_value(self, key)

    def get_centroid(self) -> GeometryTraits:
        return get_centroid(self)

    def accessible_routes(self, destinations: QueryTraits, duration: FloatTraits, options: AnyAnyCollectionResult) -> FeatureIDRouteCollectionResult:
        return accessible_routes(self, destinations, duration, options)

    def debug_tokens(self) -> IntStringCollectionResult:
        return debug_tokens(self)

    def get_int(self, key: StringTraits) -> IntTraits:
        return get_int(self, key)

    def get(self, key: StringTraits) -> TagTraits:
        return get(self, key)

    def get_string(self, key: StringTraits) -> StringTraits:
        return get_string(self, key)

    def add_tag(self, tag: TagTraits) -> ChangeTraits:
        return add_tag(self, tag)

    def remove_tag(self, key: StringTraits) -> ChangeTraits:
        return remove_tag(self, key)

    def point_paths(self) -> FeatureIDPhysicalFeatureCollectionResult:
        return point_paths(self)

    def all_tags(self) -> IntTagCollectionResult:
        return all_tags(self)

    def get_float(self, key: StringTraits) -> FloatTraits:
        return get_float(self, key)

    @classmethod
    def _collection(cls):
        return AnyIdentifiableCollectionResult

class IdentifiableValuesTraits:

    def matches(self, query: QueryTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: matches(x, query), [self._values()]))

    def count_tag_value(self, key: StringTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: count_tag_value(x, key), [self._values()]))

    def get_centroid(self) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(get_centroid, [self._values()]))

    def accessible_routes(self, destinations: QueryTraits, duration: FloatTraits, options: AnyAnyCollectionResult) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: accessible_routes(x, destinations, duration, options), [self._values()]))

    def debug_tokens(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(debug_tokens, [self._values()]))

    def get_int(self, key: StringTraits) -> AnyIntCollectionTraits:
        return self.map(Lambda(lambda x: get_int(x, key), [self._values()]))

    def get(self, key: StringTraits) -> AnyTagCollectionTraits:
        return self.map(Lambda(lambda x: get(x, key), [self._values()]))

    def get_string(self, key: StringTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: get_string(x, key), [self._values()]))

    def add_tag(self, tag: TagTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: add_tag(x, tag), [self._values()]))

    def remove_tag(self, key: StringTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: remove_tag(x, key), [self._values()]))

    def point_paths(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(point_paths, [self._values()]))

    def all_tags(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(all_tags, [self._values()]))

    def get_float(self, key: StringTraits) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(lambda x: get_float(x, key), [self._values()]))

class AnyIdentifiableValuesResult(Result, IdentifiableValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return IdentifiableResult

class GeometryTraits:

    def intersecting(self) -> QueryTraits:
        return intersecting(self)

    def length(self) -> FloatTraits:
        return length(self)

    def intersecting_cap(self, radius: FloatTraits) -> QueryTraits:
        return intersecting_cap(self, radius)

    def cap_polygon(self, radius: FloatTraits) -> AreaTraits:
        return cap_polygon(self, radius)

    def within_cap(self, radius: FloatTraits) -> QueryTraits:
        return within_cap(self, radius)

    def sample_points(self, distanceMeters: FloatTraits) -> IntGeometryCollectionResult:
        return sample_points(self, distanceMeters)

    def sightline(self, radius: FloatTraits) -> AreaTraits:
        return sightline(self, radius)

    def rectangle_polygon(self, b: GeometryTraits) -> AreaTraits:
        return rectangle_polygon(self, b)

    def centroid(self) -> GeometryTraits:
        return centroid(self)

    def distance_meters(self, b: GeometryTraits) -> FloatTraits:
        return distance_meters(self, b)

    def join(self, pathB: GeometryTraits) -> GeometryTraits:
        return join(self, pathB)

    def interpolate(self, fraction: FloatTraits) -> GeometryTraits:
        return interpolate(self, fraction)

    def ordered_join(self, pathB: GeometryTraits) -> GeometryTraits:
        return ordered_join(self, pathB)

    def points(self) -> IntGeometryCollectionResult:
        return points(self)

    def distance_to_point_meters(self, point: GeometryTraits) -> FloatTraits:
        return distance_to_point_meters(self, point)

    def tile_paths(self, zoom: IntTraits) -> IntStringCollectionResult:
        return tile_paths(self, zoom)

    def to_geojson(self) -> GeoJSONTraits:
        return to_geojson(self)

    def add_point(self, id: FeatureIDTraits, tags: AnyTagCollectionResult) -> ChangeTraits:
        return add_point(self, id, tags)

    @classmethod
    def _collection(cls):
        return AnyGeometryCollectionResult

class GeometryValuesTraits:

    def intersecting(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(intersecting, [self._values()]))

    def length(self) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(length, [self._values()]))

    def intersecting_cap(self, radius: FloatTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: intersecting_cap(x, radius), [self._values()]))

    def cap_polygon(self, radius: FloatTraits) -> AnyAreaCollectionTraits:
        return self.map(Lambda(lambda x: cap_polygon(x, radius), [self._values()]))

    def within_cap(self, radius: FloatTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: within_cap(x, radius), [self._values()]))

    def sample_points(self, distanceMeters: FloatTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: sample_points(x, distanceMeters), [self._values()]))

    def sightline(self, radius: FloatTraits) -> AnyAreaCollectionTraits:
        return self.map(Lambda(lambda x: sightline(x, radius), [self._values()]))

    def rectangle_polygon(self, b: GeometryTraits) -> AnyAreaCollectionTraits:
        return self.map(Lambda(lambda x: rectangle_polygon(x, b), [self._values()]))

    def centroid(self) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(centroid, [self._values()]))

    def distance_meters(self, b: GeometryTraits) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(lambda x: distance_meters(x, b), [self._values()]))

    def join(self, pathB: GeometryTraits) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(lambda x: join(x, pathB), [self._values()]))

    def interpolate(self, fraction: FloatTraits) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(lambda x: interpolate(x, fraction), [self._values()]))

    def ordered_join(self, pathB: GeometryTraits) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(lambda x: ordered_join(x, pathB), [self._values()]))

    def points(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(points, [self._values()]))

    def distance_to_point_meters(self, point: GeometryTraits) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(lambda x: distance_to_point_meters(x, point), [self._values()]))

    def tile_paths(self, zoom: IntTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: tile_paths(x, zoom), [self._values()]))

    def to_geojson(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(to_geojson, [self._values()]))

    def add_point(self, id: FeatureIDTraits, tags: AnyTagCollectionResult) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: add_point(x, id, tags), [self._values()]))

class AnyGeometryValuesResult(Result, GeometryValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return GeometryResult

class FeatureTraits(IdentifiableTraits):

    def reachable(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FeatureIDFeatureCollectionResult:
        return reachable(self, options, distance, query)

    def closest(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FeatureTraits:
        return closest(self, options, distance, query)

    def tile_ids_hex(self) -> FeatureIDStringCollectionResult:
        return tile_ids_hex(self)

    def connect_to_network(self) -> ChangeTraits:
        return connect_to_network(self)

    def paths_to_reach(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FeatureIDIntCollectionResult:
        return paths_to_reach(self, options, distance, query)

    def tile_ids(self) -> FeatureIDIntCollectionResult:
        return tile_ids(self)

    def degree(self) -> IntTraits:
        return degree(self)

    def connect(self, b: FeatureTraits) -> ChangeTraits:
        return connect(self, b)

    def point_features(self) -> FeatureIDPhysicalFeatureCollectionResult:
        return point_features(self)

    def closest_distance(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FloatTraits:
        return closest_distance(self, options, distance, query)

    def reachable_area(self, options: AnyAnyCollectionResult, distance: FloatTraits) -> FloatTraits:
        return reachable_area(self, options, distance)

    @classmethod
    def _collection(cls):
        return AnyFeatureCollectionResult

class FeatureValuesTraits(IdentifiableValuesTraits):

    def reachable(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: reachable(x, options, distance, query), [self._values()]))

    def closest(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> AnyFeatureCollectionTraits:
        return self.map(Lambda(lambda x: closest(x, options, distance, query), [self._values()]))

    def tile_ids_hex(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(tile_ids_hex, [self._values()]))

    def connect_to_network(self) -> AnyChangeCollectionTraits:
        return self.map(Lambda(connect_to_network, [self._values()]))

    def paths_to_reach(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: paths_to_reach(x, options, distance, query), [self._values()]))

    def tile_ids(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(tile_ids, [self._values()]))

    def degree(self) -> AnyIntCollectionTraits:
        return self.map(Lambda(degree, [self._values()]))

    def connect(self, b: FeatureTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: connect(x, b), [self._values()]))

    def point_features(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(point_features, [self._values()]))

    def closest_distance(self, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(lambda x: closest_distance(x, options, distance, query), [self._values()]))

    def reachable_area(self, options: AnyAnyCollectionResult, distance: FloatTraits) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(lambda x: reachable_area(x, options, distance), [self._values()]))

class AnyFeatureValuesResult(Result, FeatureValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FeatureResult

class NumberTraits:

    def divide(self, b: NumberTraits) -> NumberTraits:
        return divide(self, b)

    def add(self, b: NumberTraits) -> NumberTraits:
        return add(self, b)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class NumberValuesTraits:

    def divide(self, b: NumberTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: divide(x, b), [self._values()]))

    def add(self, b: NumberTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: add(x, b), [self._values()]))

class AnyNumberValuesResult(Result, NumberValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return NumberResult

class AreaTraits(GeometryTraits):

    def area(self) -> FloatTraits:
        return area(self)

    def within(self) -> QueryTraits:
        return within(self)

    def s2_grid(self, level: IntTraits) -> IntStringCollectionResult:
        return s2_grid(self, level)

    def s2_points(self, minLevel: IntTraits, maxLevel: IntTraits) -> StringGeometryCollectionResult:
        return s2_points(self, minLevel, maxLevel)

    def s2_covering(self, minLevel: IntTraits, maxLevel: IntTraits) -> IntStringCollectionResult:
        return s2_covering(self, minLevel, maxLevel)

    def snap_area_edges(self, query: QueryTraits, threshold: FloatTraits) -> AreaTraits:
        return snap_area_edges(self, query, threshold)

    @classmethod
    def _collection(cls):
        return AnyAreaCollectionResult

class AreaValuesTraits(GeometryValuesTraits):

    def area(self) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(area, [self._values()]))

    def within(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(within, [self._values()]))

    def s2_grid(self, level: IntTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: s2_grid(x, level), [self._values()]))

    def s2_points(self, minLevel: IntTraits, maxLevel: IntTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: s2_points(x, minLevel, maxLevel), [self._values()]))

    def s2_covering(self, minLevel: IntTraits, maxLevel: IntTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: s2_covering(x, minLevel, maxLevel), [self._values()]))

    def snap_area_edges(self, query: QueryTraits, threshold: FloatTraits) -> AnyAreaCollectionTraits:
        return self.map(Lambda(lambda x: snap_area_edges(x, query, threshold), [self._values()]))

class AnyAreaValuesResult(Result, AreaValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AreaResult

class TagTraits:

    def value(self) -> StringTraits:
        return value(self)

    def int_value(self) -> IntTraits:
        return int_value(self)

    def float_value(self) -> FloatTraits:
        return float_value(self)

    @classmethod
    def _collection(cls):
        return AnyTagCollectionResult

class TagValuesTraits:

    def value(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(value, [self._values()]))

    def int_value(self) -> AnyIntCollectionTraits:
        return self.map(Lambda(int_value, [self._values()]))

    def float_value(self) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(float_value, [self._values()]))

class AnyTagValuesResult(Result, TagValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return TagResult

class StringTraits:

    def keyed(self) -> QueryTraits:
        return keyed(self)

    def import_geojson_file(self, namespace: StringTraits) -> ChangeTraits:
        return import_geojson_file(self, namespace)

    def debug_all_query(self) -> QueryTraits:
        return debug_all_query(self)

    def s2_center(self) -> GeometryTraits:
        return s2_center(self)

    def tagged(self, value: StringTraits) -> QueryTraits:
        return tagged(self, value)

    def typed(self, q: QueryTraits) -> QueryTraits:
        return typed(self, q)

    def changes_from_file(self) -> ChangeTraits:
        return changes_from_file(self)

    def id_to_relation_id(self, id: IdentifiableTraits) -> FeatureIDTraits:
        return id_to_relation_id(self, id)

    def s2_polygon(self) -> AreaTraits:
        return s2_polygon(self)

    def changes_to_file(self) -> StringTraits:
        return changes_to_file(self)

    def tag(self, value: StringTraits) -> TagTraits:
        return tag(self, value)

    def parse_geojson(self) -> GeoJSONTraits:
        return parse_geojson(self)

    def parse_geojson_file(self) -> GeoJSONTraits:
        return parse_geojson_file(self)

    def export_world(self) -> IntTraits:
        return export_world(self)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class StringValuesTraits:

    def keyed(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(keyed, [self._values()]))

    def import_geojson_file(self, namespace: StringTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: import_geojson_file(x, namespace), [self._values()]))

    def debug_all_query(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(debug_all_query, [self._values()]))

    def s2_center(self) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(s2_center, [self._values()]))

    def tagged(self, value: StringTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: tagged(x, value), [self._values()]))

    def typed(self, q: QueryTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: typed(x, q), [self._values()]))

    def changes_from_file(self) -> AnyChangeCollectionTraits:
        return self.map(Lambda(changes_from_file, [self._values()]))

    def id_to_relation_id(self, id: IdentifiableTraits) -> AnyFeatureIDCollectionTraits:
        return self.map(Lambda(lambda x: id_to_relation_id(x, id), [self._values()]))

    def s2_polygon(self) -> AnyAreaCollectionTraits:
        return self.map(Lambda(s2_polygon, [self._values()]))

    def changes_to_file(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(changes_to_file, [self._values()]))

    def tag(self, value: StringTraits) -> AnyTagCollectionTraits:
        return self.map(Lambda(lambda x: tag(x, value), [self._values()]))

    def parse_geojson(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(parse_geojson, [self._values()]))

    def parse_geojson_file(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(parse_geojson_file, [self._values()]))

    def export_world(self) -> AnyIntCollectionTraits:
        return self.map(Lambda(export_world, [self._values()]))

class AnyStringValuesResult(Result, StringValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return StringResult

class IntTraits(NumberTraits):

    def divide_int(self, b: FloatTraits) -> FloatTraits:
        return divide_int(self, b)

    def clamp(self, low: IntTraits, high: IntTraits) -> IntTraits:
        return clamp(self, low, high)

    def to_str(self) -> StringTraits:
        return to_str(self)

    def add_ints(self, b: IntTraits) -> IntTraits:
        return add_ints(self, b)

    @classmethod
    def _collection(cls):
        return AnyIntCollectionResult

class IntValuesTraits(NumberValuesTraits):

    def divide_int(self, b: FloatTraits) -> AnyFloat64CollectionTraits:
        return self.map(Lambda(lambda x: divide_int(x, b), [self._values()]))

    def clamp(self, low: IntTraits, high: IntTraits) -> AnyIntCollectionTraits:
        return self.map(Lambda(lambda x: clamp(x, low, high), [self._values()]))

    def to_str(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(to_str, [self._values()]))

    def add_ints(self, b: IntTraits) -> AnyIntCollectionTraits:
        return self.map(Lambda(lambda x: add_ints(x, b), [self._values()]))

class AnyIntValuesResult(Result, IntValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return IntResult

class FeatureIDTraits(IdentifiableTraits):

    def find_relation(self) -> RelationFeatureTraits:
        return find_relation(self)

    def find_feature(self) -> FeatureTraits:
        return find_feature(self)

    def evaluate_feature(self) -> AnyTraits:
        return evaluate_feature(self)

    def add_world_with_change(self, change: ChangeTraits) -> FeatureIDFeatureIDCollectionResult:
        return add_world_with_change(self, change)

    def add_expression(self, tags: AnyTagCollectionResult, expresson: ExpressionTraits) -> ChangeTraits:
        return add_expression(self, tags, expresson)

    def find_area(self) -> AreaFeatureTraits:
        return find_area(self)

    def find_collection(self) -> CollectionFeatureTraits:
        return find_collection(self)

    @classmethod
    def _collection(cls):
        return AnyFeatureIDCollectionResult

class FeatureIDValuesTraits(IdentifiableValuesTraits):

    def find_relation(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(find_relation, [self._values()]))

    def find_feature(self) -> AnyFeatureCollectionTraits:
        return self.map(Lambda(find_feature, [self._values()]))

    def evaluate_feature(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(evaluate_feature, [self._values()]))

    def add_world_with_change(self, change: ChangeTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: add_world_with_change(x, change), [self._values()]))

    def add_expression(self, tags: AnyTagCollectionResult, expresson: ExpressionTraits) -> AnyChangeCollectionTraits:
        return self.map(Lambda(lambda x: add_expression(x, tags, expresson), [self._values()]))

    def find_area(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(find_area, [self._values()]))

    def find_collection(self) -> AnyAnyCollectionTraits:
        return self.map(Lambda(find_collection, [self._values()]))

class AnyFeatureIDValuesResult(Result, FeatureIDValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FeatureIDResult

class AnyTraits:

    def pair(self, second: AnyTraits) -> PairTraits:
        return pair(self, second)

    def gt(self, b: AnyTraits) -> BoolTraits:
        return gt(self, b)

    def collection(self) -> AnyAnyCollectionResult:
        return collection(self)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class AnyValuesTraits:

    def pair(self, second: AnyTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: pair(x, second), [self._values()]))

    def gt(self, b: AnyTraits) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: gt(x, b), [self._values()]))

    def collection(self) -> AnyAnyAnyCollectionCollectionTraits:
        return self.map(Lambda(collection, [self._values()]))

class AnyAnyValuesResult(Result, AnyValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AnyResult

class FloatTraits(NumberTraits):

    def ll(self, lng: FloatTraits) -> GeometryTraits:
        return ll(self, lng)

    @classmethod
    def _collection(cls):
        return AnyFloat64CollectionResult

class FloatValuesTraits(NumberValuesTraits):

    def ll(self, lng: FloatTraits) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(lambda x: ll(x, lng), [self._values()]))

class AnyFloatValuesResult(Result, FloatValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FloatResult

class AnyFeatureCollectionTraits(AnyAnyCollectionTraits, FeatureValuesTraits):

    def materialise_map(self, id: CollectionIDTraits, function: CallableTraits) -> ChangeTraits:
        return materialise_map(self, id, function)

    def containing_areas(self, q: QueryTraits) -> FeatureIDAreaFeatureCollectionResult:
        return containing_areas(self, q)

    def building_access(self, limit: FloatTraits, mode: StringTraits) -> FeatureIDFeatureIDCollectionResult:
        return building_access(self, limit, mode)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AreaFeatureTraits(AreaTraits, FeatureTraits):

    def entrance_approach(self) -> GeometryTraits:
        return entrance_approach(self)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class AreaFeatureValuesTraits(AreaValuesTraits, FeatureValuesTraits):

    def entrance_approach(self) -> AnyGeometryCollectionTraits:
        return self.map(Lambda(entrance_approach, [self._values()]))

class AnyAreaFeatureValuesResult(Result, AreaFeatureValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AreaFeatureResult

class FeatureIDGeometryCollectionTraits(AnyAnyCollectionTraits, GeometryValuesTraits):

    def sample_points_along_paths(self, distanceMeters: FloatTraits) -> IntGeometryCollectionResult:
        return sample_points_along_paths(self, distanceMeters)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class ChangeTraits:

    def with_change(self, function: Callable[[],AnyTraits]) -> AnyTraits:
        return with_change(self, function)

    @classmethod
    def _collection(cls):
        return AnyChangeCollectionResult

class ChangeValuesTraits:

    def with_change(self, function: Callable[[],AnyTraits]) -> AnyAnyCollectionTraits:
        return self.map(Lambda(lambda x: with_change(x, function), [self._values()]))

class AnyChangeValuesResult(Result, ChangeValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return ChangeResult

class RouteTraits:
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class RouteValuesTraits:
    pass

class AnyRouteValuesResult(Result, RouteValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return RouteResult

class AnyAreaCollectionTraits(AnyAnyCollectionTraits, AreaValuesTraits):

    def collect_areas(self) -> AreaTraits:
        return collect_areas(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class PhysicalFeatureTraits:
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class PhysicalFeatureValuesTraits:
    pass

class AnyPhysicalFeatureValuesResult(Result, PhysicalFeatureValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return PhysicalFeatureResult

class RelationFeatureTraits(FeatureTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class RelationFeatureValuesTraits(FeatureValuesTraits):
    pass

class AnyRelationFeatureValuesResult(Result, RelationFeatureValuesTraits, AnyAnyCollectionTraits):

    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return RelationFeatureResult

class ExpressionTraits:
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class AnyIdentifiableCollectionTraits(AnyAnyCollectionTraits, IdentifiableValuesTraits):

    def count_valid_ids(self) -> IntTraits:
        return count_valid_ids(self)

    def accessible_all(self, destinations: QueryTraits, duration: FloatTraits, options: AnyAnyCollectionResult) -> FeatureIDFeatureIDCollectionResult:
        return accessible_all(self, destinations, duration, options)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class IntTagCollectionTraits(AnyAnyCollectionTraits, TagValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDFeatureCollectionTraits(AnyFeatureCollectionTraits, FeatureValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDRouteCollectionTraits(AnyAnyCollectionTraits, RouteValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class GeoJSONTraits:

    def geojson_areas(self) -> IntAreaCollectionResult:
        return geojson_areas(self)

    def map_geometries(self, f: CallableTraits) -> GeoJSONTraits:
        return map_geometries(self, f)

    def import_geojson(self, namespace: StringTraits) -> ChangeTraits:
        return import_geojson(self, namespace)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class CollectionIDTraits(IdentifiableTraits):

    def add_collection(self, tags: AnyTagCollectionResult, collection: AnyAnyCollectionResult) -> ChangeTraits:
        return add_collection(self, tags, collection)

    def list_feature(self) -> AnyAnyCollectionResult:
        return list_feature(self)

    def materialise(self, function: CallableTraits) -> ChangeTraits:
        return materialise(self, function)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class AnyFeatureIDCollectionTraits(AnyAnyCollectionTraits, FeatureIDValuesTraits):

    def connect_to_network_all(self) -> ChangeTraits:
        return connect_to_network_all(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class IntAreaCollectionTraits(AnyAnyCollectionTraits, AreaValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDIntCollectionTraits(AnyAnyCollectionTraits, IntValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class QueryTraits:

    def find(self) -> FeatureIDFeatureCollectionResult:
        return find(self)

    def find_relations(self) -> FeatureIDRelationFeatureCollectionResult:
        return find_relations(self)

    def or_(self, b: QueryTraits) -> QueryTraits:
        return or_(self, b)

    def find_areas(self) -> FeatureIDAreaFeatureCollectionResult:
        return find_areas(self)

    def and_(self, b: QueryTraits) -> QueryTraits:
        return and_(self, b)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class IntGeometryCollectionTraits(AnyAnyCollectionTraits, GeometryValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDPhysicalFeatureCollectionTraits(FeatureIDGeometryCollectionTraits, PhysicalFeatureValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyGeometryCollectionTraits(AnyAnyCollectionTraits, GeometryValuesTraits):

    def convex_hull(self) -> AreaTraits:
        return convex_hull(self)

    def to_geojson_collection(self) -> GeoJSONTraits:
        return to_geojson_collection(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDFeatureIDCollectionTraits(AnyAnyCollectionTraits, FeatureIDValuesTraits):

    def filter_accessible(self, filter: QueryTraits) -> FeatureIDFeatureIDCollectionResult:
        return filter_accessible(self, filter)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class CollectionFeatureTraits(AnyAnyCollectionTraits, FeatureTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class PairTraits:

    def first(self) -> AnyTraits:
        return first(self)

    def second(self) -> AnyTraits:
        return second(self)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class FeatureIDRelationFeatureCollectionTraits(AnyAnyCollectionTraits, RelationFeatureValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDStringCollectionTraits(AnyAnyCollectionTraits, StringValuesTraits):

    def remove_tags(self) -> ChangeTraits:
        return remove_tags(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class FeatureIDTagCollectionTraits(AnyAnyCollectionTraits, TagValuesTraits):

    def add_tags(self) -> ChangeTraits:
        return add_tags(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyTraits:
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class IdentifiableStringCollectionTraits(AnyAnyCollectionTraits, StringValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class IntStringCollectionTraits(AnyAnyCollectionTraits, StringValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class CallableTraits:

    def apply_to_path(self) -> CallableTraits:
        return apply_to_path(self)

    def call(self, args: AnyTraits) -> AnyTraits:
        return call(self, args)

    def apply_to_point(self) -> CallableTraits:
        return apply_to_point(self)

    def apply_to_area(self) -> CallableTraits:
        return apply_to_area(self)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class FeatureIDAreaFeatureCollectionTraits(AnyAreaCollectionTraits, AreaFeatureValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class QueryProtoTraits:
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class RelationIDTraits(IdentifiableTraits):

    def add_relation(self, tags: AnyTagCollectionResult, members: IdentifiableStringCollectionResult) -> ChangeTraits:
        return add_relation(self, tags, members)

    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class AnyAnyAnyCollectionCollectionTraits(AnyAnyCollectionTraits, AnyAnyCollectionValuesTraits):

    def flatten(self) -> AnyAnyCollectionResult:
        return flatten(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class BoolTraits:
    @classmethod
    def _collection(cls):
        return AnyAnyCollectionResult

class AnyChangeCollectionTraits(AnyAnyCollectionTraits, ChangeValuesTraits):

    def merge_changes(self) -> ChangeTraits:
        return merge_changes(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyFloat64CollectionTraits(AnyAnyCollectionTraits, FloatValuesTraits):

    def percentiles(self) -> AnyFloat64CollectionResult:
        return percentiles(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyTagCollectionTraits(AnyAnyCollectionTraits, TagValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyIntCollectionTraits(AnyAnyCollectionTraits, IntValuesTraits):

    def sum(self) -> IntTraits:
        return sum(self)

    def sum_by_key(self) -> AnyIntCollectionResult:
        return sum_by_key(self)

    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class StringGeometryCollectionTraits(AnyAnyCollectionTraits, GeometryValuesTraits):
    @classmethod
    def _collection(cls):
        return AnyAnyAnyCollectionCollectionResult

class AnyAnyCollectionResult(Result,AnyAnyCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AnyResult

class IdentifiableResult(Result,IdentifiableTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class GeometryResult(Result,GeometryTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class FeatureResult(Result,FeatureTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class NumberResult(Result,NumberTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AreaResult(Result,AreaTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class TagResult(Result,TagTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class StringResult(Result,StringTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class IntResult(Result,IntTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class FeatureIDResult(Result,FeatureIDTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyResult(Result,AnyTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class FloatResult(Result,FloatTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyFeatureCollectionResult(Result,AnyFeatureCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FeatureResult

class AreaFeatureResult(Result,AreaFeatureTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class FeatureIDGeometryCollectionResult(Result,FeatureIDGeometryCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return GeometryResult

class ChangeResult(Result,ChangeTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class RouteResult(Result,RouteTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyAreaCollectionResult(Result,AnyAreaCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AreaResult

class PhysicalFeatureResult(Result,PhysicalFeatureTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class RelationFeatureResult(Result,RelationFeatureTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class ExpressionResult(Result,ExpressionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyIdentifiableCollectionResult(Result,AnyIdentifiableCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return IdentifiableResult

class IntTagCollectionResult(Result,IntTagCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return TagResult

class FeatureIDFeatureCollectionResult(Result,FeatureIDFeatureCollectionTraits,FeatureIDPhysicalFeatureCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FeatureResult

class FeatureIDRouteCollectionResult(Result,FeatureIDRouteCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return RouteResult

class GeoJSONResult(Result,GeoJSONTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class CollectionIDResult(Result,CollectionIDTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyFeatureIDCollectionResult(Result,AnyFeatureIDCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FeatureIDResult

class IntAreaCollectionResult(Result,IntAreaCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AreaResult

class FeatureIDIntCollectionResult(Result,FeatureIDIntCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return IntResult

class QueryResult(Result,QueryTraits,QueryConversionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class IntGeometryCollectionResult(Result,IntGeometryCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return GeometryResult

class FeatureIDPhysicalFeatureCollectionResult(Result,FeatureIDPhysicalFeatureCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return PhysicalFeatureResult

class AnyGeometryCollectionResult(Result,AnyGeometryCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return GeometryResult

class FeatureIDFeatureIDCollectionResult(Result,FeatureIDFeatureIDCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FeatureIDResult

class CollectionFeatureResult(Result,CollectionFeatureTraits,CollectionFeatureResultTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class PairResult(Result,PairTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class FeatureIDRelationFeatureCollectionResult(Result,FeatureIDRelationFeatureCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return RelationFeatureResult

class FeatureIDStringCollectionResult(Result,FeatureIDStringCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return StringResult

class FeatureIDTagCollectionResult(Result,FeatureIDTagCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return TagResult

class AnyResult(Result,AnyTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class IdentifiableStringCollectionResult(Result,IdentifiableStringCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return StringResult

class IntStringCollectionResult(Result,IntStringCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return StringResult

class CallableResult(Result,CallableTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class FeatureIDAreaFeatureCollectionResult(Result,FeatureIDAreaFeatureCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AreaFeatureResult

class QueryProtoResult(Result,QueryProtoTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class RelationIDResult(Result,RelationIDTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyAnyAnyCollectionCollectionResult(Result,AnyAnyAnyCollectionCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return AnyAnyCollectionResult

class BoolResult(Result,BoolTraits):
    def __init__(self, node):
        Result.__init__(self, node)

class AnyChangeCollectionResult(Result,AnyChangeCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return ChangeResult

class AnyFloat64CollectionResult(Result,AnyFloat64CollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return FloatResult

class AnyTagCollectionResult(Result,AnyTagCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return TagResult

class AnyIntCollectionResult(Result,AnyIntCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return IntResult

class StringGeometryCollectionResult(Result,StringGeometryCollectionTraits):
    def __init__(self, node):
        Result.__init__(self, node)

    @classmethod
    def _values(cls):
        return GeometryResult

class FunctionAnyResult(Result, Callable[[],AnyTraits]):

    def __init__(self, node):
        Result.__init__(self, node)

    def __call__(self, ) -> AnyTraits:
        raise NotImplementedError()

def find(query: QueryTraits) -> FeatureIDFeatureCollectionResult:
    """Return a collection of the features present in the world that match the given query.
Keys are IDs, and values are features."""
    args_ = [query]
    return FeatureIDFeatureCollectionResult(Call(Symbol('find'), args_))

def apply_to_path(f: CallableTraits) -> CallableTraits:
    """Wrap the given function such that it will only be called when passed a path."""
    args_ = [f]
    return CallableResult(Call(Symbol('apply-to-path'), args_))

def count_values(collection: AnyAnyCollectionResult) -> AnyIntCollectionResult:
    """Return a collection of the number of occurances of each value in the given collection."""
    args_ = [collection]
    return AnyIntCollectionResult(Call(Symbol('count-values'), args_))

def intersecting(geometry: GeometryTraits) -> QueryTraits:
    """Return a query that will match features that intersect the given geometry."""
    args_ = [geometry]
    return QueryResult(Call(Symbol('intersecting'), args_))

def keyed(key: StringTraits) -> QueryTraits:
    """Return a query that will match features tagged with the given key independent of value."""
    args_ = [key]
    return QueryResult(Call(Symbol('keyed'), args_))

def length(path: GeometryTraits) -> FloatTraits:
    """Return the length of the given path in meters."""
    args_ = [path]
    return FloatResult(Call(Symbol('length'), args_))

def divide_int(a: IntTraits, b: FloatTraits) -> FloatTraits:
    """Deprecated."""
    args_ = [a, b]
    return FloatResult(Call(Symbol('divide-int'), args_))

def import_geojson_file(filename: StringTraits, namespace: StringTraits) -> ChangeTraits:
    """Add features from the given geojson file to the world.
IDs are formed from the given namespace, and the index of the feature
within the geojson collection (or 0, if a single feature is used).
As the file is read by the b6 server process, the filename it relative
to the filesystems it sees. Reading from files on cloud storage is
supported."""
    args_ = [filename, namespace]
    return ChangeResult(Call(Symbol('import-geojson-file'), args_))

def find_relations(query: QueryTraits) -> FeatureIDRelationFeatureCollectionResult:
    """Return a collection of the relation features present in the world that match the given query.
Keys are IDs, and values are features."""
    args_ = [query]
    return FeatureIDRelationFeatureCollectionResult(Call(Symbol('find-relations'), args_))

def reachable(origin: FeatureTraits, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FeatureIDFeatureCollectionResult:
    """Return the a collection of the features reachable from the given origin via the given mode, within the given distance in meters, that match the given query.
See accessible-all for options values.
Deprecated. Use accessible-all."""
    args_ = [origin, options, distance, query]
    return FeatureIDFeatureCollectionResult(Call(Symbol('reachable'), args_))

def debug_all_query(token: StringTraits) -> QueryTraits:
    """Deprecated."""
    args_ = [token]
    return QueryResult(Call(Symbol('debug-all-query'), args_))

def first(pair: PairTraits) -> AnyTraits:
    """Return the first value of the given pair."""
    args_ = [pair]
    return AnyResult(Call(Symbol('first'), args_))

def histogram_swatch(collection: AnyAnyCollectionResult) -> ChangeTraits:
    """Return a change that adds a histogram with only colour swatches for the given collection."""
    args_ = [collection]
    return ChangeResult(Call(Symbol('histogram-swatch'), args_))

def intersecting_cap(center: GeometryTraits, radius: FloatTraits) -> QueryTraits:
    """Return a query that will match features that intersect a spherical cap centred on the given point, with the given radius in meters."""
    args_ = [center, radius]
    return QueryResult(Call(Symbol('intersecting-cap'), args_))

def or_(a: QueryTraits, b: QueryTraits) -> QueryTraits:
    """Return a query that will match features that match either of the given queries."""
    args_ = [a, b]
    return QueryResult(Call(Symbol('or'), args_))

def area(area: AreaTraits) -> FloatTraits:
    """Return the area of the given polygon in m²."""
    args_ = [area]
    return FloatResult(Call(Symbol('area'), args_))

def materialise_map(collection: AnyFeatureCollectionResult, id: CollectionIDTraits, function: CallableTraits) -> ChangeTraits:
    args_ = [collection, id, function]
    return ChangeResult(Call(Symbol('materialise-map'), args_))

def take(collection: AnyAnyCollectionResult, n: IntTraits) -> AnyAnyCollectionResult:
    """Return a collection with the first n entries of the given collection."""
    args_ = [collection, n]
    return AnyAnyCollectionResult(Call(Symbol('take'), args_))

def s2_center(token: StringTraits) -> GeometryTraits:
    """Return a collection the center of the s2 cell with the given token."""
    args_ = [token]
    return GeometryResult(Call(Symbol('s2-center'), args_))

def cap_polygon(center: GeometryTraits, radius: FloatTraits) -> AreaTraits:
    """Return a polygon approximating a spherical cap with the given center and radius in meters."""
    args_ = [center, radius]
    return AreaResult(Call(Symbol('cap-polygon'), args_))

def sample_points_along_paths(paths: FeatureIDGeometryCollectionResult, distanceMeters: FloatTraits) -> IntGeometryCollectionResult:
    """Return a collection of points along the given paths, with the given distance in meters between them.
Keys are the id of the respective path, values are points."""
    args_ = [paths, distanceMeters]
    return IntGeometryCollectionResult(Call(Symbol('sample-points-along-paths'), args_))

def call(f: CallableTraits, *args: AnyTraits) -> AnyTraits:
    args_ = [f]
    args_.extend(args)
    return AnyResult(Call(Symbol('call'), args_))

def convex_hull(c: AnyGeometryCollectionResult) -> AreaTraits:
    """Return the convex hull of the given geometries."""
    args_ = [c]
    return AreaResult(Call(Symbol('convex-hull'), args_))

def add_collection(id: CollectionIDTraits, tags: AnyTagCollectionResult, collection: AnyAnyCollectionResult) -> ChangeTraits:
    """Add a collection feature with the given id, tags and items."""
    args_ = [id, tags, collection]
    return ChangeResult(Call(Symbol('add-collection'), args_))

def find_relation(id: FeatureIDTraits) -> RelationFeatureTraits:
    """Return the relation feature with the given ID."""
    args_ = [id]
    return RelationFeatureResult(Call(Symbol('find-relation'), args_))

def histogram_with_id(collection: AnyAnyCollectionResult, id: CollectionIDTraits) -> ChangeTraits:
    """Return a change that adds a histogram for the given collection with the given ID."""
    args_ = [collection, id]
    return ChangeResult(Call(Symbol('histogram-with-id'), args_))

def find_areas(query: QueryTraits) -> FeatureIDAreaFeatureCollectionResult:
    """Return a collection of the area features present in the world that match the given query.
Keys are IDs, and values are features."""
    args_ = [query]
    return FeatureIDAreaFeatureCollectionResult(Call(Symbol('find-areas'), args_))

def tagged(key: StringTraits, value: StringTraits) -> QueryTraits:
    """Return a query that will match features tagged with the given key and value."""
    args_ = [key, value]
    return QueryResult(Call(Symbol('tagged'), args_))

def filter_accessible(collection: FeatureIDFeatureIDCollectionResult, filter: QueryTraits) -> FeatureIDFeatureIDCollectionResult:
    """Return a collection containing only the values of the given collection that match the given query.
If no values for a key match the query, emit a single invalid feature ID
for that key, allowing callers to count the number of keys with no valid
values.
Keys are taken from the given collection."""
    args_ = [collection, filter]
    return FeatureIDFeatureIDCollectionResult(Call(Symbol('filter-accessible'), args_))

def closest(origin: FeatureTraits, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FeatureTraits:
    """Return the closest feature from the given origin via the given mode, within the given distance in meters, matching the given query.
See accessible-all for options values."""
    args_ = [origin, options, distance, query]
    return FeatureResult(Call(Symbol('closest'), args_))

def map_parallel(collection: AnyAnyCollectionResult, function: CallableTraits) -> AnyAnyCollectionResult:
    """Return a collection with the result of applying the given function to each value.
Keys are unmodified, and function application occurs in parallel, bounded
by the number of CPU cores allocated to b6."""
    args_ = [collection, function]
    return AnyAnyCollectionResult(Call(Symbol('map-parallel'), args_))

def within_cap(point: GeometryTraits, radius: FloatTraits) -> QueryTraits:
    """Return a query that will match features that intersect a spherical cap centred on the given point, with the given radius in meters.
Deprecated. Use intersecting-cap."""
    args_ = [point, radius]
    return QueryResult(Call(Symbol('within-cap'), args_))

def value(tag: TagTraits) -> StringTraits:
    """Return the value of the given tag as a string."""
    args_ = [tag]
    return StringResult(Call(Symbol('value'), args_))

def clamp(v: IntTraits, low: IntTraits, high: IntTraits) -> IntTraits:
    """Return the given value, unless it falls outside the given inclusive bounds, in which case return the boundary."""
    args_ = [v, low, high]
    return IntResult(Call(Symbol('clamp'), args_))

def tile_ids_hex(feature: FeatureTraits) -> FeatureIDStringCollectionResult:
    """Deprecated"""
    args_ = [feature]
    return FeatureIDStringCollectionResult(Call(Symbol('tile-ids-hex'), args_))

def list_feature(id: CollectionIDTraits) -> AnyAnyCollectionResult:
    args_ = [id]
    return AnyAnyCollectionResult(Call(Symbol('list-feature'), args_))

def find_feature(id: FeatureIDTraits) -> FeatureTraits:
    """Return the feature with the given ID."""
    args_ = [id]
    return FeatureResult(Call(Symbol('find-feature'), args_))

def sample_points(path: GeometryTraits, distanceMeters: FloatTraits) -> IntGeometryCollectionResult:
    """Return a collection of points along the given path, with the given distance in meters between them.
Keys are ordered integers from 0, values are points."""
    args_ = [path, distanceMeters]
    return IntGeometryCollectionResult(Call(Symbol('sample-points'), args_))

def evaluate_feature(id: FeatureIDTraits) -> AnyTraits:
    args_ = [id]
    return AnyResult(Call(Symbol('evaluate-feature'), args_))

def sightline(from_: GeometryTraits, radius: FloatTraits) -> AreaTraits:
    args_ = [from_, radius]
    return AreaResult(Call(Symbol('sightline'), args_))

def apply_to_point(f: CallableTraits) -> CallableTraits:
    """Wrap the given function such that it will only be called when passed a point."""
    args_ = [f]
    return CallableResult(Call(Symbol('apply-to-point'), args_))

map = diagonal_b6.expression._map

def is_valid() -> QueryTraits:
    """Keep only those features that are valid."""
    args_ = []
    return QueryResult(Call(Symbol('is-valid'), args_))

def sum(collection: AnyIntCollectionResult) -> IntTraits:
    """Return the sum of all values in a given collection."""
    args_ = [collection]
    return IntResult(Call(Symbol('sum'), args_))

def merge_changes(collection: AnyChangeCollectionResult) -> ChangeTraits:
    """Return a change that will apply all the changes in the given collection.
Changes are applied transactionally. If the application of one change
fails (for example, because it includes a path that references a missing
point), then no changes will be applied."""
    args_ = [collection]
    return ChangeResult(Call(Symbol('merge-changes'), args_))

def top(collection: AnyAnyCollectionResult, n: IntTraits) -> AnyAnyCollectionResult:
    """Return a collection with the n entries from the given collection with the greatest values.
Requires the values of the given collection to be integers or floats."""
    args_ = [collection, n]
    return AnyAnyCollectionResult(Call(Symbol('top'), args_))

def matches(id: IdentifiableTraits, query: QueryTraits) -> BoolTraits:
    """Return true if the given feature matches the given query."""
    args_ = [id, query]
    return BoolResult(Call(Symbol('matches'), args_))

def count(collection: AnyAnyCollectionResult) -> IntTraits:
    """Return the number of items in the given collection.
The function will not evaluate and traverse the entire collection if it's possible to count
the collection efficiently."""
    args_ = [collection]
    return IntResult(Call(Symbol('count'), args_))

def typed(typ: StringTraits, q: QueryTraits) -> QueryTraits:
    """Wrap a query to only match features with the given feature type."""
    args_ = [typ, q]
    return QueryResult(Call(Symbol('typed'), args_))

def rectangle_polygon(a: GeometryTraits, b: GeometryTraits) -> AreaTraits:
    """Return a rectangle polygon with the given top left and bottom right points."""
    args_ = [a, b]
    return AreaResult(Call(Symbol('rectangle-polygon'), args_))

def geojson_areas(g: GeoJSONTraits) -> IntAreaCollectionResult:
    """Return the areas present in the given geojson."""
    args_ = [g]
    return IntAreaCollectionResult(Call(Symbol('geojson-areas'), args_))

def add_world_with_change(id: FeatureIDTraits, change: ChangeTraits) -> FeatureIDFeatureIDCollectionResult:
    args_ = [id, change]
    return FeatureIDFeatureIDCollectionResult(Call(Symbol('add-world-with-change'), args_))

def changes_from_file(filename: StringTraits) -> ChangeTraits:
    """Return the changes contained in the given file.
As the file is read by the b6 server process, the filename it relative
to the filesystems it sees. Reading from files on cloud storage is
supported."""
    args_ = [filename]
    return ChangeResult(Call(Symbol('changes-from-file'), args_))

def connect_to_network_all(features: AnyFeatureIDCollectionResult) -> ChangeTraits:
    """Add paths and points to connect the given collection of features to the
network. See connect-to-network for connection details.
More efficient than using map with connect-to-network, as the street
network is only computed once."""
    args_ = [features]
    return ChangeResult(Call(Symbol('connect-to-network-all'), args_))

def all() -> QueryTraits:
    """Return a query that will match any feature."""
    args_ = []
    return QueryResult(Call(Symbol('all'), args_))

def connect_to_network(feature: FeatureTraits) -> ChangeTraits:
    """Add a path and point to connect given feature to the street network.
The street network is defined at the set of paths tagged #highway that
allow traversal of more than 500m. A point is added to the closest
network path at the projection of the origin point on that path, unless
that point is within 4m of an existing path point."""
    args_ = [feature]
    return ChangeResult(Call(Symbol('connect-to-network'), args_))

def centroid(geometry: GeometryTraits) -> GeometryTraits:
    """Return the centroid of the given geometry.
For multipolygons, we return the centroid of the convex hull formed from
the points of those polygons."""
    args_ = [geometry]
    return GeometryResult(Call(Symbol('centroid'), args_))

def map_geometries(g: GeoJSONTraits, f: CallableTraits) -> GeoJSONTraits:
    """Return a geojson representing the result of applying the given function to each geometry in the given geojson."""
    args_ = [g, f]
    return GeoJSONResult(Call(Symbol('map-geometries'), args_))

def add_relation(id: RelationIDTraits, tags: AnyTagCollectionResult, members: IdentifiableStringCollectionResult) -> ChangeTraits:
    """Add a relation feature with the given id, tags and members."""
    args_ = [id, tags, members]
    return ChangeResult(Call(Symbol('add-relation'), args_))

def sum_by_key(c: AnyIntCollectionResult) -> AnyIntCollectionResult:
    """Return a collection of the result of summing the values of each item with the same key.
Requires values to be integers."""
    args_ = [c]
    return AnyIntCollectionResult(Call(Symbol('sum-by-key'), args_))

def and_(a: QueryTraits, b: QueryTraits) -> QueryTraits:
    """Return a query that will match features that match both given queries."""
    args_ = [a, b]
    return QueryResult(Call(Symbol('and'), args_))

def type_area() -> QueryProtoTraits:
    """Return a query that will match area features."""
    args_ = []
    return QueryProtoResult(Call(Symbol('type-area'), args_))

def within(a: AreaTraits) -> QueryTraits:
    """Return a query that will match features that intersect the given area.
Deprecated. Use intersecting."""
    args_ = [a]
    return QueryResult(Call(Symbol('within'), args_))

def s2_grid(area: AreaTraits, level: IntTraits) -> IntStringCollectionResult:
    """Return a collection of points representing the centroids of s2 cells that cover the given area at the given level."""
    args_ = [area, level]
    return IntStringCollectionResult(Call(Symbol('s2-grid'), args_))

def paths_to_reach(origin: FeatureTraits, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FeatureIDIntCollectionResult:
    """Return a collection of the paths used to reach all features matching the given query from the given origin via the given mode, within the given distance in meters.
Keys are the paths used, values are the number of times that path was used during traversal.
See accessible-all for options values."""
    args_ = [origin, options, distance, query]
    return FeatureIDIntCollectionResult(Call(Symbol('paths-to-reach'), args_))

def tile_ids(feature: FeatureTraits) -> FeatureIDIntCollectionResult:
    """Deprecated"""
    args_ = [feature]
    return FeatureIDIntCollectionResult(Call(Symbol('tile-ids'), args_))

def histogram(collection: AnyAnyCollectionResult) -> ChangeTraits:
    """Return a change that adds a histogram for the given collection."""
    args_ = [collection]
    return ChangeResult(Call(Symbol('histogram'), args_))

def s2_points(area: AreaTraits, minLevel: IntTraits, maxLevel: IntTraits) -> StringGeometryCollectionResult:
    """Return a collection of points representing the centroids of s2 cells that cover the given area between the given levels."""
    args_ = [area, minLevel, maxLevel]
    return StringGeometryCollectionResult(Call(Symbol('s2-points'), args_))

def distance_meters(a: GeometryTraits, b: GeometryTraits) -> FloatTraits:
    """Return the distance in meters between the given points."""
    args_ = [a, b]
    return FloatResult(Call(Symbol('distance-meters'), args_))

def id_to_relation_id(namespace: StringTraits, id: IdentifiableTraits) -> FeatureIDTraits:
    """Deprecated."""
    args_ = [namespace, id]
    return FeatureIDResult(Call(Symbol('id-to-relation-id'), args_))

def type_path() -> QueryProtoTraits:
    """Return a query that will match path features."""
    args_ = []
    return QueryProtoResult(Call(Symbol('type-path'), args_))

def import_geojson(features: GeoJSONTraits, namespace: StringTraits) -> ChangeTraits:
    """Add features from the given geojson to the world.
IDs are formed from the given namespace, and the index of the feature
within the geojson collection (or 0, if a single feature is used)."""
    args_ = [features, namespace]
    return ChangeResult(Call(Symbol('import-geojson'), args_))

def add_expression(id: FeatureIDTraits, tags: AnyTagCollectionResult, expresson: ExpressionTraits) -> ChangeTraits:
    """Add an expression feature with the given id, tags and expression."""
    args_ = [id, tags, expresson]
    return ChangeResult(Call(Symbol('add-expression'), args_))

def s2_polygon(token: StringTraits) -> AreaTraits:
    """Return the bounding area of the s2 cell with the given token."""
    args_ = [token]
    return AreaResult(Call(Symbol('s2-polygon'), args_))

def count_tag_value(id: IdentifiableTraits, key: StringTraits) -> AnyIntCollectionResult:
    """Deprecated."""
    args_ = [id, key]
    return AnyIntCollectionResult(Call(Symbol('count-tag-value'), args_))

def join(pathA: GeometryTraits, pathB: GeometryTraits) -> GeometryTraits:
    """Return a path formed from the points of the two given paths, in the order they occur in those paths."""
    args_ = [pathA, pathB]
    return GeometryResult(Call(Symbol('join'), args_))

def get_centroid(id: IdentifiableTraits) -> GeometryTraits:
    """Return the centroid of the given feature.
Returns either the centroid of an invalid geometry."""
    args_ = [id]
    return GeometryResult(Call(Symbol('get-centroid'), args_))

def changes_to_file(filename: StringTraits) -> StringTraits:
    """Export the changes that have been applied to the world to the given filename as yaml.
As the file is written by the b6 server process, the filename it relative
to the filesystems it sees. Writing files to cloud storage is
supported."""
    args_ = [filename]
    return StringResult(Call(Symbol('changes-to-file'), args_))

def find_area(id: FeatureIDTraits) -> AreaFeatureTraits:
    """Return the area feature with the given ID."""
    args_ = [id]
    return AreaFeatureResult(Call(Symbol('find-area'), args_))

def accessible_routes(origin: IdentifiableTraits, destinations: QueryTraits, duration: FloatTraits, options: AnyAnyCollectionResult) -> FeatureIDRouteCollectionResult:
    args_ = [origin, destinations, duration, options]
    return FeatureIDRouteCollectionResult(Call(Symbol('accessible-routes'), args_))

def interpolate(path: GeometryTraits, fraction: FloatTraits) -> GeometryTraits:
    """Return the point at the given fraction along the given path."""
    args_ = [path, fraction]
    return GeometryResult(Call(Symbol('interpolate'), args_))

def map_items(collection: AnyAnyCollectionResult, function: CallableTraits) -> AnyAnyCollectionResult:
    """Return a collection of the result of applying the given function to each pair(key, value).
Keys are unmodified."""
    args_ = [collection, function]
    return AnyAnyCollectionResult(Call(Symbol('map-items'), args_))

def ordered_join(pathA: GeometryTraits, pathB: GeometryTraits) -> GeometryTraits:
    """Returns a path formed by joining the two given paths.
If necessary to maintain consistency, the order of points is reversed,
determined by which points are shared between the paths. Returns an error
if no endpoints are shared."""
    args_ = [pathA, pathB]
    return GeometryResult(Call(Symbol('ordered-join'), args_))

def to_str(a: IntTraits) -> StringTraits:
    args_ = [a]
    return StringResult(Call(Symbol('to-str'), args_))

def add_ints(a: IntTraits, b: IntTraits) -> IntTraits:
    """Deprecated."""
    args_ = [a, b]
    return IntResult(Call(Symbol('add-ints'), args_))

def debug_tokens(id: IdentifiableTraits) -> IntStringCollectionResult:
    """Return the search index tokens generated for the given feature.
Intended for debugging use only."""
    args_ = [id]
    return IntStringCollectionResult(Call(Symbol('debug-tokens'), args_))

def pair(first: AnyTraits, second: AnyTraits) -> PairTraits:
    """Return a pair containing the given values."""
    args_ = [first, second]
    return PairResult(Call(Symbol('pair'), args_))

def type_point() -> QueryProtoTraits:
    """Return a query that will match point features."""
    args_ = []
    return QueryProtoResult(Call(Symbol('type-point'), args_))

def points(geometry: GeometryTraits) -> IntGeometryCollectionResult:
    """Return a collection of the points of the given geometry.
Keys are ordered integers from 0, values are points."""
    args_ = [geometry]
    return IntGeometryCollectionResult(Call(Symbol('points'), args_))

def s2_covering(area: AreaTraits, minLevel: IntTraits, maxLevel: IntTraits) -> IntStringCollectionResult:
    """Return a collection of of s2 cells tokens that cover the given area at the given level."""
    args_ = [area, minLevel, maxLevel]
    return IntStringCollectionResult(Call(Symbol('s2-covering'), args_))

def gt(a: AnyTraits, b: AnyTraits) -> BoolTraits:
    """Return true if a is greater than b."""
    args_ = [a, b]
    return BoolResult(Call(Symbol('gt'), args_))

def divide(a: NumberTraits, b: NumberTraits) -> NumberTraits:
    """Return a divided by b."""
    args_ = [a, b]
    return NumberResult(Call(Symbol('divide'), args_))

def distance_to_point_meters(path: GeometryTraits, point: GeometryTraits) -> FloatTraits:
    """Return the distance in meters between the given path, and the project of the give point onto it."""
    args_ = [path, point]
    return FloatResult(Call(Symbol('distance-to-point-meters'), args_))

def add_tags(collection: FeatureIDTagCollectionResult) -> ChangeTraits:
    """Add the given tags to the given features.
The keys of the given collection specify the features to change, the
values provide the tag to be added."""
    args_ = [collection]
    return ChangeResult(Call(Symbol('add-tags'), args_))

def flatten(collection: AnyAnyAnyCollectionCollectionResult) -> AnyAnyCollectionResult:
    """Return a collection with keys and values taken from the collections that form the values of the given collection."""
    args_ = [collection]
    return AnyAnyCollectionResult(Call(Symbol('flatten'), args_))

def degree(point: FeatureTraits) -> IntTraits:
    """Return the number of paths connected to the given point.
A single path will be counted twice if the point isn't at one of its
two ends - once in one direction, and once in the other."""
    args_ = [point]
    return IntResult(Call(Symbol('degree'), args_))

def count_valid_ids(collection: AnyIdentifiableCollectionResult) -> IntTraits:
    """Return the number of valid feature IDs in the given collection."""
    args_ = [collection]
    return IntResult(Call(Symbol('count-valid-ids'), args_))

def apply_to_area(f: CallableTraits) -> CallableTraits:
    """Wrap the given function such that it will only be called when passed an area."""
    args_ = [f]
    return CallableResult(Call(Symbol('apply-to-area'), args_))

def get_int(id: IdentifiableTraits, key: StringTraits) -> IntTraits:
    """Return the value of tag with the given key on the given feature as an integer.
Returns error if there isn't a feature with that id, a tag with that key, or if the value isn't a valid integer."""
    args_ = [id, key]
    return IntResult(Call(Symbol('get-int'), args_))

def tag(key: StringTraits, value: StringTraits) -> TagTraits:
    """Return a tag with the given key and value."""
    args_ = [key, value]
    return TagResult(Call(Symbol('tag'), args_))

def get(id: IdentifiableTraits, key: StringTraits) -> TagTraits:
    """Return the tag with the given key on the given feature.
Returns a tag. To return the string value of a tag, use get-string."""
    args_ = [id, key]
    return TagResult(Call(Symbol('get'), args_))

def get_string(id: IdentifiableTraits, key: StringTraits) -> StringTraits:
    """Return the value of tag with the given key on the given feature as a string.
Returns an empty string if there isn't a tag with that key."""
    args_ = [id, key]
    return StringResult(Call(Symbol('get-string'), args_))

def connect(a: FeatureTraits, b: FeatureTraits) -> ChangeTraits:
    """Add a path that connects the two given points, if they're not already directly connected."""
    args_ = [a, b]
    return ChangeResult(Call(Symbol('connect'), args_))

def with_change(change: ChangeTraits, function: Callable[[],AnyTraits]) -> AnyTraits:
    """Return the result of calling the given function in a world in which the given change has been applied.
The underlying world used by the server is not modified."""
    args_ = [change, function]
    return AnyResult(Call(Symbol('with-change'), args_))

def histogram_swatch_with_id(collection: AnyAnyCollectionResult, id: CollectionIDTraits) -> ChangeTraits:
    """Return a change that adds a histogram with only colour swatches for the given collection."""
    args_ = [collection, id]
    return ChangeResult(Call(Symbol('histogram-swatch-with-id'), args_))

def join_missing(base: AnyAnyCollectionResult, joined: AnyAnyCollectionResult) -> AnyAnyCollectionResult:
    args_ = [base, joined]
    return AnyAnyCollectionResult(Call(Symbol('join-missing'), args_))

def containing_areas(points: AnyFeatureCollectionResult, q: QueryTraits) -> FeatureIDAreaFeatureCollectionResult:
    args_ = [points, q]
    return FeatureIDAreaFeatureCollectionResult(Call(Symbol('containing-areas'), args_))

def parse_geojson(s: StringTraits) -> GeoJSONTraits:
    """Return the geojson represented by the given string."""
    args_ = [s]
    return GeoJSONResult(Call(Symbol('parse-geojson'), args_))

def add_tag(id: IdentifiableTraits, tag: TagTraits) -> ChangeTraits:
    """Add the given tag to the given feature."""
    args_ = [id, tag]
    return ChangeResult(Call(Symbol('add-tag'), args_))

def count_valid_keys(collection: AnyAnyCollectionResult) -> AnyIntCollectionResult:
    """Return a collection of the number of occurances of each valid value in the given collection.
Invalid values are not counted, but case the key to appear in the output."""
    args_ = [collection]
    return AnyIntCollectionResult(Call(Symbol('count-valid-keys'), args_))

def remove_tag(id: IdentifiableTraits, key: StringTraits) -> ChangeTraits:
    """Remove the tag with the given key from the given feature."""
    args_ = [id, key]
    return ChangeResult(Call(Symbol('remove-tag'), args_))

def remove_tags(collection: FeatureIDStringCollectionResult) -> ChangeTraits:
    """Remove the given tags from the given features.
The keys of the given collection specify the features to change, the
values provide the key of the tag to be removed."""
    args_ = [collection]
    return ChangeResult(Call(Symbol('remove-tags'), args_))

def collection(*pairs: AnyTraits) -> AnyAnyCollectionResult:
    """Return a collection of the given key value pairs."""
    args_ = []
    args_.extend(pairs)
    return AnyAnyCollectionResult(Call(Symbol('collection'), args_))

def point_features(f: FeatureTraits) -> FeatureIDPhysicalFeatureCollectionResult:
    """Return a collection of the point features referenced by the given feature.
Keys are ids of the respective value, values are point features. Area
features return the points referenced by their path features."""
    args_ = [f]
    return FeatureIDPhysicalFeatureCollectionResult(Call(Symbol('point-features'), args_))

def tile_paths(geometry: GeometryTraits, zoom: IntTraits) -> IntStringCollectionResult:
    """Return the URL paths for the tiles containing the given geometry at the given zoom level."""
    args_ = [geometry, zoom]
    return IntStringCollectionResult(Call(Symbol('tile-paths'), args_))

filter = diagonal_b6.expression._filter

def percentiles(collection: AnyFloat64CollectionResult) -> AnyFloat64CollectionResult:
    """Return a collection where values represent the perentile of the corresponding value in the given collection.
The returned collection is ordered by percentile, with keys drawn from the
given collection."""
    args_ = [collection]
    return AnyFloat64CollectionResult(Call(Symbol('percentiles'), args_))

def closest_distance(origin: FeatureTraits, options: AnyAnyCollectionResult, distance: FloatTraits, query: QueryTraits) -> FloatTraits:
    """Return the distance through the graph of the closest feature from the given origin via the given mode, within the given distance in meters, matching the given query.
See accessible-all for options values."""
    args_ = [origin, options, distance, query]
    return FloatResult(Call(Symbol('closest-distance'), args_))

def ll(lat: FloatTraits, lng: FloatTraits) -> GeometryTraits:
    """Return a point at the given latitude and longitude, specified in degrees."""
    args_ = [lat, lng]
    return GeometryResult(Call(Symbol('ll'), args_))

def parse_geojson_file(filename: StringTraits) -> GeoJSONTraits:
    """Return the geojson contained in the given file.
As the file is read by the b6 server process, the filename it relative
to the filesystems it sees. Reading from files on cloud storage is
supported."""
    args_ = [filename]
    return GeoJSONResult(Call(Symbol('parse-geojson-file'), args_))

def find_collection(id: FeatureIDTraits) -> CollectionFeatureTraits:
    """Return the collection feature with the given ID."""
    args_ = [id]
    return CollectionFeatureResult(Call(Symbol('find-collection'), args_))

def int_value(tag: TagTraits) -> IntTraits:
    """Return the value of the given tag as an integer.
Propagates error if the value isn't a valid integer."""
    args_ = [tag]
    return IntResult(Call(Symbol('int-value'), args_))

def point_paths(id: IdentifiableTraits) -> FeatureIDPhysicalFeatureCollectionResult:
    """Return a collection of the path features referencing the given point.
Keys are the ids of the respective paths."""
    args_ = [id]
    return FeatureIDPhysicalFeatureCollectionResult(Call(Symbol('point-paths'), args_))

def count_keys(collection: AnyAnyCollectionResult) -> AnyIntCollectionResult:
    """Return a collection of the number of occurances of each value in the given collection."""
    args_ = [collection]
    return AnyIntCollectionResult(Call(Symbol('count-keys'), args_))

def collect_areas(areas: AnyAreaCollectionResult) -> AreaTraits:
    """Return a single area containing all areas from the given collection.
If areas in the collection overlap, loops within the returned area
will overlap, which will likely cause undefined behaviour in many
functions."""
    args_ = [areas]
    return AreaResult(Call(Symbol('collect-areas'), args_))

def to_geojson_collection(renderables: AnyGeometryCollectionResult) -> GeoJSONTraits:
    args_ = [renderables]
    return GeoJSONResult(Call(Symbol('to-geojson-collection'), args_))

def all_tags(id: IdentifiableTraits) -> IntTagCollectionResult:
    """Return a collection of all the tags on the given feature.
Keys are ordered integers from 0, values are tags."""
    args_ = [id]
    return IntTagCollectionResult(Call(Symbol('all-tags'), args_))

def snap_area_edges(area: AreaTraits, query: QueryTraits, threshold: FloatTraits) -> AreaTraits:
    """Return an area formed by projecting the edges of the given polygon onto the paths present in the world matching the given query.
Paths beyond the given threshold in meters are ignored."""
    args_ = [area, query, threshold]
    return AreaResult(Call(Symbol('snap-area-edges'), args_))

def accessible_all(origins: AnyIdentifiableCollectionResult, destinations: QueryTraits, duration: FloatTraits, options: AnyAnyCollectionResult) -> FeatureIDFeatureIDCollectionResult:
    """Return the a collection of the features reachable from the given origins, within the given duration in seconds, that match the given query.
Keys of the collection are origins, values are reachable destinations.
Options are passed as tags containing the mode, and mode specific values. Examples include:
Walking, with the default speed of 4.5km/h:
mode=walk
Walking, a speed of 3km/h:
mode=walk, walk:speed=3.0
Transit at peak times:
mode=transit
Transit at off-peak times:
mode=transit, peak=no
Walking, accounting for elevation:
elevation=true (optional: elevation:uphill=2.0 elevation:downhill=1.2)
Walking, accounting for elevation, adding double the penalty for uphill:
elevation=true, elevation:uphill=2.0
Walking, with the resulting collection flipped such that keys are
destinations and values are origins. Useful for efficiency if you assume
symmetry, and the number of destinations is considerably smaller than the
number of origins:
mode=walk, flip=yes"""
    args_ = [origins, destinations, duration, options]
    return FeatureIDFeatureIDCollectionResult(Call(Symbol('accessible-all'), args_))

def second(pair: PairTraits) -> AnyTraits:
    """Return the second value of the given pair."""
    args_ = [pair]
    return AnyResult(Call(Symbol('second'), args_))

def add(a: NumberTraits, b: NumberTraits) -> NumberTraits:
    """Return a added to b."""
    args_ = [a, b]
    return NumberResult(Call(Symbol('add'), args_))

def building_access(origins: AnyFeatureCollectionResult, limit: FloatTraits, mode: StringTraits) -> FeatureIDFeatureIDCollectionResult:
    """Deprecated. Use accessible."""
    args_ = [origins, limit, mode]
    return FeatureIDFeatureIDCollectionResult(Call(Symbol('building-access'), args_))

def entrance_approach(area: AreaFeatureTraits) -> GeometryTraits:
    args_ = [area]
    return GeometryResult(Call(Symbol('entrance-approach'), args_))

def to_geojson(renderable: GeometryTraits) -> GeoJSONTraits:
    args_ = [renderable]
    return GeoJSONResult(Call(Symbol('to-geojson'), args_))

def materialise(id: CollectionIDTraits, function: CallableTraits) -> ChangeTraits:
    """Return a change that adds a collection feature to the world with the given ID, containing the result of calling the given function.
The given function isn't passed any arguments.
Also adds an expression feature (with the same namespace and value)
representing the given function."""
    args_ = [id, function]
    return ChangeResult(Call(Symbol('materialise'), args_))

def export_world(filename: StringTraits) -> IntTraits:
    """Write the current world to the given filename in the b6 compact index format.
As the file is written by the b6 server process, the filename it relative
to the filesystems it sees. Writing files to cloud storage is
supported."""
    args_ = [filename]
    return IntResult(Call(Symbol('export-world'), args_))

def get_float(id: IdentifiableTraits, key: StringTraits) -> FloatTraits:
    """Return the value of tag with the given key on the given feature as a float.
Returns error if there isn't a feature with that id, a tag with that key, or if the value isn't a valid float."""
    args_ = [id, key]
    return FloatResult(Call(Symbol('get-float'), args_))

def reachable_area(origin: FeatureTraits, options: AnyAnyCollectionResult, distance: FloatTraits) -> FloatTraits:
    """Return the area formed by the convex hull of the features matching the given query reachable from the given origin via the given mode specified in options, within the given distance in meters.
See accessible-all for options values."""
    args_ = [origin, options, distance]
    return FloatResult(Call(Symbol('reachable-area'), args_))

def add_point(point: GeometryTraits, id: FeatureIDTraits, tags: AnyTagCollectionResult) -> ChangeTraits:
    """Adds a point feature with the given id, tags and members."""
    args_ = [point, id, tags]
    return ChangeResult(Call(Symbol('add-point'), args_))

def float_value(tag: TagTraits) -> FloatTraits:
    """Return the value of the given tag as a float.
Propagates error if the value isn't a valid float."""
    args_ = [tag]
    return FloatResult(Call(Symbol('float-value'), args_))

name = diagonal_b6.expression._name
register_builtin_result(str,StringResult)
register_builtin_result(int,IntResult)
register_builtin_result(float,FloatResult)
register_builtin_result(bool,BoolResult)
register_builtin_result(list,AnyAnyCollectionResult)
