"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class Visibility(str, Enum):
    r"""The visibility of the document."""

    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class GlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class GlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


FormValuesTypedDict = TypeAliasType("FormValuesTypedDict", Union[str, bool, float])


FormValues = TypeAliasType("FormValues", Union[str, bool, float])


class Role(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"


class AccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class ActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11Type(
    str, Enum
):
    DROPDOWN = "DROPDOWN"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMetaType(
    str, Enum
):
    DROPDOWN = "dropdown"


class DocumentCreateDocumentTemporaryFieldsValuesTypedDict(TypedDict):
    value: str


class DocumentCreateDocumentTemporaryFieldsValues(BaseModel):
    value: str


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMetaTypedDict(
    TypedDict
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentCreateDocumentTemporaryFieldsValuesTypedDict]]
    default_value: NotRequired[str]


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMeta(
    BaseModel
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentCreateDocumentTemporaryFieldsValues]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class ElevenTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11Type
    )
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMetaTypedDict
    ]


class Eleven(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11Type
    )

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[
            DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients11FieldMeta
        ],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10Type(
    str, Enum
):
    CHECKBOX = "CHECKBOX"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMetaType(
    str, Enum
):
    CHECKBOX = "checkbox"


class FieldsValuesTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class FieldsValues(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMetaTypedDict(
    TypedDict
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[FieldsValuesTypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMeta(
    BaseModel
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[FieldsValues]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class TenTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10Type
    )
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMetaTypedDict
    ]


class Ten(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10Type
    )

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[
            DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients10FieldMeta
        ],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients9Type(
    str, Enum
):
    RADIO = "RADIO"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients9FieldMetaType(
    str, Enum
):
    RADIO = "radio"


class ValuesTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class Values(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsFieldMetaTypedDict(
    TypedDict
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients9FieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[ValuesTypedDict]]


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsFieldMeta(
    BaseModel
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients9FieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[Values]] = None


class NineTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients9Type
    )
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsFieldMetaTypedDict
    ]


class Nine(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients9Type
    )

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[
            DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsFieldMeta
        ],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients8Type(
    str, Enum
):
    NUMBER = "NUMBER"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients8FieldMetaType(
    str, Enum
):
    NUMBER = "number"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyFieldMetaTypedDict(
    TypedDict
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients8FieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyFieldMeta(
    BaseModel
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients8FieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class EightTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients8Type
    )
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyFieldMetaTypedDict
    ]


class Eight(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients8Type
    )

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[
            DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyFieldMeta
        ],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients7Type(
    str, Enum
):
    TEXT = "TEXT"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients7FieldMetaType(
    str, Enum
):
    TEXT = "text"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestFieldMetaTypedDict(
    TypedDict
):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients7FieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestFieldMeta(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients7FieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class SevenTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients7Type
    )
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestFieldMetaTypedDict
    ]


class Seven(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients7Type
    )

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryFieldsDocumentsRequestFieldMeta],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients6Type(
    str, Enum
):
    DATE = "DATE"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients6FieldMetaType(
    str, Enum
):
    DATE = "date"


class DocumentCreateDocumentTemporaryFieldsDocumentsFieldMetaTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients6FieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldsDocumentsFieldMeta(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients6FieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class SixTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients6Type
    )
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryFieldsDocumentsFieldMetaTypedDict
    ]


class Six(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients6Type
    )

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryFieldsDocumentsFieldMeta],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsType(
    str, Enum
):
    EMAIL = "EMAIL"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients5Type(
    str, Enum
):
    EMAIL = "email"


class DocumentCreateDocumentTemporaryFieldsFieldMetaTypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients5Type
    )
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldsFieldMeta(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipients5Type
    )

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class FiveTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsType
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[DocumentCreateDocumentTemporaryFieldsFieldMetaTypedDict]


class Five(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyRecipientsType

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryFieldsFieldMeta],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestType(str, Enum):
    NAME = "NAME"


class DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyType(str, Enum):
    NAME = "name"


class FieldsFieldMetaTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class FieldsFieldMeta(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestRequestBodyType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class FourTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestType
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldsFieldMetaTypedDict]


class Four(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsRequestType

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldsFieldMeta], pydantic.Field(alias="fieldMeta")
    ] = None


class DocumentCreateDocumentTemporaryFieldsType(str, Enum):
    INITIALS = "INITIALS"


class DocumentCreateDocumentTemporaryFieldsDocumentsType(str, Enum):
    INITIALS = "initials"


class FieldMetaTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class FieldMeta(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsDocumentsType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class ThreeTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldsType
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaTypedDict]


class Three(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldsType

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[Optional[FieldMeta], pydantic.Field(alias="fieldMeta")] = None


class FieldsType(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


class TwoTypedDict(TypedDict):
    type: FieldsType
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""


class Two(BaseModel):
    type: FieldsType

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""


class Type(str, Enum):
    SIGNATURE = "SIGNATURE"


class OneTypedDict(TypedDict):
    type: Type
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""


class One(BaseModel):
    type: Type

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""


DocumentCreateDocumentTemporaryFieldsTypedDict = TypeAliasType(
    "DocumentCreateDocumentTemporaryFieldsTypedDict",
    Union[
        OneTypedDict,
        TwoTypedDict,
        ThreeTypedDict,
        FourTypedDict,
        FiveTypedDict,
        SixTypedDict,
        SevenTypedDict,
        EightTypedDict,
        NineTypedDict,
        TenTypedDict,
        ElevenTypedDict,
    ],
)


DocumentCreateDocumentTemporaryFields = TypeAliasType(
    "DocumentCreateDocumentTemporaryFields",
    Union[One, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Eleven],
)


class DocumentCreateDocumentTemporaryRecipientsTypedDict(TypedDict):
    email: str
    name: str
    role: Role
    signing_order: NotRequired[float]
    access_auth: NotRequired[Nullable[AccessAuth]]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: NotRequired[Nullable[ActionAuth]]
    r"""The type of authentication required for the recipient to sign the document."""
    fields: NotRequired[List[DocumentCreateDocumentTemporaryFieldsTypedDict]]


class DocumentCreateDocumentTemporaryRecipients(BaseModel):
    email: str

    name: str

    role: Role

    signing_order: Annotated[Optional[float], pydantic.Field(alias="signingOrder")] = (
        None
    )

    access_auth: Annotated[
        OptionalNullable[AccessAuth], pydantic.Field(alias="accessAuth")
    ] = UNSET
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        OptionalNullable[ActionAuth], pydantic.Field(alias="actionAuth")
    ] = UNSET
    r"""The type of authentication required for the recipient to sign the document."""

    fields: Optional[List[DocumentCreateDocumentTemporaryFields]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["signingOrder", "accessAuth", "actionAuth", "fields"]
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DateFormat(str, Enum):
    r"""The date format to use for date fields and signing the document."""

    YYYY_MM_DD_HH_MM_A = "yyyy-MM-dd hh:mm a"
    YYYY_MM_DD = "yyyy-MM-dd"
    DD_MM_YYYY_HH_MM_A = "dd/MM/yyyy hh:mm a"
    MM_DD_YYYY_HH_MM_A = "MM/dd/yyyy hh:mm a"
    YYYY_MM_DD_HH_MM = "yyyy-MM-dd HH:mm"
    YY_MM_DD_HH_MM_A = "yy-MM-dd hh:mm a"
    YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss"
    MMMM_DD_YYYY_HH_MM_A = "MMMM dd, yyyy hh:mm a"
    EEEE_MMMM_DD_YYYY_HH_MM_A = "EEEE, MMMM dd, yyyy hh:mm a"
    YYYY_MM_DD_T_HH_MM_SS_SSSXXX = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"


class DistributionMethod(str, Enum):
    r"""The distribution method to use when sending the document to the recipients."""

    EMAIL = "EMAIL"
    NONE = "NONE"


class SigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class Language(str, Enum):
    r"""The language to use for email communications with recipients."""

    DE = "de"
    EN = "en"
    FR = "fr"
    ES = "es"


class EmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class EmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class MetaTypedDict(TypedDict):
    subject: NotRequired[str]
    r"""The subject of the email that will be sent to the recipients."""
    message: NotRequired[str]
    r"""The message of the email that will be sent to the recipients."""
    timezone: NotRequired[str]
    r"""The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne"""
    date_format: NotRequired[DateFormat]
    r"""The date format to use for date fields and signing the document."""
    distribution_method: NotRequired[DistributionMethod]
    r"""The distribution method to use when sending the document to the recipients."""
    signing_order: NotRequired[SigningOrder]
    redirect_url: NotRequired[str]
    r"""The URL to which the recipient should be redirected after signing the document."""
    language: NotRequired[Language]
    r"""The language to use for email communications with recipients."""
    typed_signature_enabled: NotRequired[bool]
    r"""Whether to allow recipients to sign using a typed signature."""
    email_settings: NotRequired[EmailSettingsTypedDict]


class Meta(BaseModel):
    subject: Optional[str] = None
    r"""The subject of the email that will be sent to the recipients."""

    message: Optional[str] = None
    r"""The message of the email that will be sent to the recipients."""

    timezone: Optional[str] = None
    r"""The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne"""

    date_format: Annotated[Optional[DateFormat], pydantic.Field(alias="dateFormat")] = (
        None
    )
    r"""The date format to use for date fields and signing the document."""

    distribution_method: Annotated[
        Optional[DistributionMethod], pydantic.Field(alias="distributionMethod")
    ] = None
    r"""The distribution method to use when sending the document to the recipients."""

    signing_order: Annotated[
        Optional[SigningOrder], pydantic.Field(alias="signingOrder")
    ] = None

    redirect_url: Annotated[Optional[str], pydantic.Field(alias="redirectUrl")] = None
    r"""The URL to which the recipient should be redirected after signing the document."""

    language: Optional[Language] = None
    r"""The language to use for email communications with recipients."""

    typed_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="typedSignatureEnabled")
    ] = None
    r"""Whether to allow recipients to sign using a typed signature."""

    email_settings: Annotated[
        Optional[EmailSettings], pydantic.Field(alias="emailSettings")
    ] = None


class DocumentCreateDocumentTemporaryRequestBodyTypedDict(TypedDict):
    title: str
    r"""The title of the document."""
    external_id: NotRequired[str]
    r"""The external ID of the document."""
    visibility: NotRequired[Visibility]
    r"""The visibility of the document."""
    global_access_auth: NotRequired[GlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: NotRequired[GlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""
    form_values: NotRequired[Dict[str, FormValuesTypedDict]]
    recipients: NotRequired[List[DocumentCreateDocumentTemporaryRecipientsTypedDict]]
    meta: NotRequired[MetaTypedDict]


class DocumentCreateDocumentTemporaryRequestBody(BaseModel):
    title: str
    r"""The title of the document."""

    external_id: Annotated[Optional[str], pydantic.Field(alias="externalId")] = None
    r"""The external ID of the document."""

    visibility: Optional[Visibility] = None
    r"""The visibility of the document."""

    global_access_auth: Annotated[
        Optional[GlobalAccessAuth], pydantic.Field(alias="globalAccessAuth")
    ] = None
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Optional[GlobalActionAuth], pydantic.Field(alias="globalActionAuth")
    ] = None
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    form_values: Annotated[
        Optional[Dict[str, FormValues]], pydantic.Field(alias="formValues")
    ] = None

    recipients: Optional[List[DocumentCreateDocumentTemporaryRecipients]] = None

    meta: Optional[Meta] = None


class DocumentCreateDocumentTemporaryDocumentsIssuesTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryDocumentsIssues(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryDocumentsResponseResponseBodyData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryDocumentsIssues]] = None


class DocumentCreateDocumentTemporaryDocumentsResponseResponseBody(Exception):
    r"""Internal server error"""

    data: DocumentCreateDocumentTemporaryDocumentsResponseResponseBodyData

    def __init__(
        self, data: DocumentCreateDocumentTemporaryDocumentsResponseResponseBodyData
    ):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentCreateDocumentTemporaryDocumentsResponseResponseBodyData
        )


class DocumentCreateDocumentTemporaryIssuesTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryIssues(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryDocumentsResponseBodyData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryIssues]] = None


class DocumentCreateDocumentTemporaryDocumentsResponseBody(Exception):
    r"""Invalid input data"""

    data: DocumentCreateDocumentTemporaryDocumentsResponseBodyData

    def __init__(self, data: DocumentCreateDocumentTemporaryDocumentsResponseBodyData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentCreateDocumentTemporaryDocumentsResponseBodyData
        )


class DocumentCreateDocumentTemporaryVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentCreateDocumentTemporaryStatus(str, Enum):
    DRAFT = "DRAFT"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"


class DocumentCreateDocumentTemporarySource(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class DocumentCreateDocumentTemporaryGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class DocumentCreateDocumentTemporaryGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentCreateDocumentTemporaryAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[DocumentCreateDocumentTemporaryGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[DocumentCreateDocumentTemporaryGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class DocumentCreateDocumentTemporaryAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[DocumentCreateDocumentTemporaryGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[DocumentCreateDocumentTemporaryGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


DocumentCreateDocumentTemporaryFormValuesTypedDict = TypeAliasType(
    "DocumentCreateDocumentTemporaryFormValuesTypedDict", Union[str, bool, float]
)


DocumentCreateDocumentTemporaryFormValues = TypeAliasType(
    "DocumentCreateDocumentTemporaryFormValues", Union[str, bool, float]
)


class DocumentCreateDocumentTemporaryType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class DocumentCreateDocumentTemporaryDocumentDataTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryType
    id: str
    data: str
    initial_data: str


class DocumentCreateDocumentTemporaryDocumentData(BaseModel):
    type: DocumentCreateDocumentTemporaryType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]


class DocumentCreateDocumentTemporarySigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class DocumentCreateDocumentTemporaryDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class DocumentCreateDocumentTemporaryEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentCreateDocumentTemporaryEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentCreateDocumentTemporaryDocumentMetaTypedDict(TypedDict):
    signing_order: DocumentCreateDocumentTemporarySigningOrder
    distribution_method: DocumentCreateDocumentTemporaryDistributionMethod
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    password: Nullable[str]
    date_format: Nullable[str]
    document_id: int
    redirect_url: Nullable[str]
    typed_signature_enabled: bool
    language: str
    email_settings: Nullable[DocumentCreateDocumentTemporaryEmailSettingsTypedDict]


class DocumentCreateDocumentTemporaryDocumentMeta(BaseModel):
    signing_order: Annotated[
        DocumentCreateDocumentTemporarySigningOrder,
        pydantic.Field(alias="signingOrder"),
    ]

    distribution_method: Annotated[
        DocumentCreateDocumentTemporaryDistributionMethod,
        pydantic.Field(alias="distributionMethod"),
    ]

    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    password: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    document_id: Annotated[int, pydantic.Field(alias="documentId")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    language: str

    email_settings: Annotated[
        Nullable[DocumentCreateDocumentTemporaryEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "password",
            "dateFormat",
            "redirectUrl",
            "emailSettings",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"


class DocumentCreateDocumentTemporaryReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class DocumentCreateDocumentTemporarySigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class DocumentCreateDocumentTemporarySendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class DocumentCreateDocumentTemporaryAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class DocumentCreateDocumentTemporaryActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class DocumentCreateDocumentTemporaryDocumentsAuthOptionsTypedDict(TypedDict):
    access_auth: Nullable[DocumentCreateDocumentTemporaryAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: Nullable[DocumentCreateDocumentTemporaryActionAuth]
    r"""The type of authentication required for the recipient to sign the document."""


class DocumentCreateDocumentTemporaryDocumentsAuthOptions(BaseModel):
    access_auth: Annotated[
        Nullable[DocumentCreateDocumentTemporaryAccessAuth],
        pydantic.Field(alias="accessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        Nullable[DocumentCreateDocumentTemporaryActionAuth],
        pydantic.Field(alias="actionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryDocumentsRecipientsTypedDict(TypedDict):
    role: DocumentCreateDocumentTemporaryRole
    read_status: DocumentCreateDocumentTemporaryReadStatus
    signing_status: DocumentCreateDocumentTemporarySigningStatus
    send_status: DocumentCreateDocumentTemporarySendStatus
    id: int
    document_id: Nullable[int]
    template_id: Nullable[int]
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[DocumentCreateDocumentTemporaryDocumentsAuthOptionsTypedDict]
    signing_order: Nullable[float]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""
    rejection_reason: Nullable[str]


class DocumentCreateDocumentTemporaryDocumentsRecipients(BaseModel):
    role: DocumentCreateDocumentTemporaryRole

    read_status: Annotated[
        DocumentCreateDocumentTemporaryReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        DocumentCreateDocumentTemporarySigningStatus,
        pydantic.Field(alias="signingStatus"),
    ]

    send_status: Annotated[
        DocumentCreateDocumentTemporarySendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: int

    document_id: Annotated[Nullable[int], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[int], pydantic.Field(alias="templateId")]

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[DocumentCreateDocumentTemporaryDocumentsAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "documentId",
            "templateId",
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryDocumentsType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentFields9Type(
    str, Enum
):
    DROPDOWN = "dropdown"


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseValuesTypedDict(
    TypedDict
):
    value: str


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseValues(BaseModel):
    value: str


class DocumentCreateDocumentTemporaryFieldMeta9TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentFields9Type
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[
        List[DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseValuesTypedDict]
    ]
    default_value: NotRequired[str]


class DocumentCreateDocumentTemporaryFieldMeta9(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentFields9Type

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[
        List[DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseValues]
    ] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentFieldsType(
    str, Enum
):
    CHECKBOX = "checkbox"


class DocumentCreateDocumentTemporaryFieldMetaDocumentsValuesTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentCreateDocumentTemporaryFieldMetaDocumentsValues(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentCreateDocumentTemporaryFieldMeta8TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentFieldsType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[
        List[DocumentCreateDocumentTemporaryFieldMetaDocumentsValuesTypedDict]
    ]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta8(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentFieldsType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentCreateDocumentTemporaryFieldMetaDocumentsValues]] = (
        None
    )

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentType(
    str, Enum
):
    RADIO = "radio"


class DocumentCreateDocumentTemporaryFieldMetaValuesTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentCreateDocumentTemporaryFieldMetaValues(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentCreateDocumentTemporaryFieldMeta7TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentCreateDocumentTemporaryFieldMetaValuesTypedDict]]


class DocumentCreateDocumentTemporaryFieldMeta7(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyDocumentType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentCreateDocumentTemporaryFieldMetaValues]] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyType(
    str, Enum
):
    NUMBER = "number"


class DocumentCreateDocumentTemporaryFieldMeta6TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta6(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONResponseBodyType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONType(
    str, Enum
):
    TEXT = "text"


class DocumentCreateDocumentTemporaryFieldMeta5TypedDict(TypedDict):
    type: (
        DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONType
    )
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta5(BaseModel):
    type: (
        DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200ApplicationJSONType
    )

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200Type(str, Enum):
    DATE = "date"


class DocumentCreateDocumentTemporaryFieldMeta4TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200Type
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta4(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponse200Type

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseType(str, Enum):
    EMAIL = "email"


class DocumentCreateDocumentTemporaryFieldMeta3TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta3(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsResponseType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class DocumentCreateDocumentTemporaryFieldMetaDocumentsType(str, Enum):
    NAME = "name"


class DocumentCreateDocumentTemporaryFieldMeta2TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta2(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaDocumentsType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class DocumentCreateDocumentTemporaryFieldMetaType(str, Enum):
    INITIALS = "initials"


class DocumentCreateDocumentTemporaryFieldMeta1TypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryFieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryFieldMeta1(BaseModel):
    type: DocumentCreateDocumentTemporaryFieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


DocumentCreateDocumentTemporaryFieldMetaTypedDict = TypeAliasType(
    "DocumentCreateDocumentTemporaryFieldMetaTypedDict",
    Union[
        DocumentCreateDocumentTemporaryFieldMeta1TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta2TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta3TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta4TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta7TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta9TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta5TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta8TypedDict,
        DocumentCreateDocumentTemporaryFieldMeta6TypedDict,
    ],
)


DocumentCreateDocumentTemporaryFieldMeta = TypeAliasType(
    "DocumentCreateDocumentTemporaryFieldMeta",
    Union[
        DocumentCreateDocumentTemporaryFieldMeta1,
        DocumentCreateDocumentTemporaryFieldMeta2,
        DocumentCreateDocumentTemporaryFieldMeta3,
        DocumentCreateDocumentTemporaryFieldMeta4,
        DocumentCreateDocumentTemporaryFieldMeta7,
        DocumentCreateDocumentTemporaryFieldMeta9,
        DocumentCreateDocumentTemporaryFieldMeta5,
        DocumentCreateDocumentTemporaryFieldMeta8,
        DocumentCreateDocumentTemporaryFieldMeta6,
    ],
)


class DocumentCreateDocumentTemporaryDocumentsFieldsTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryDocumentsType
    id: int
    secondary_id: str
    document_id: Nullable[int]
    template_id: Nullable[int]
    recipient_id: int
    page: float
    r"""The page number of the field on the document. Starts from 1."""
    custom_text: str
    inserted: bool
    field_meta: Nullable[DocumentCreateDocumentTemporaryFieldMetaTypedDict]
    position_x: NotRequired[Any]
    position_y: NotRequired[Any]
    width: NotRequired[Any]
    height: NotRequired[Any]


class DocumentCreateDocumentTemporaryDocumentsFields(BaseModel):
    type: DocumentCreateDocumentTemporaryDocumentsType

    id: int

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    document_id: Annotated[Nullable[int], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[int], pydantic.Field(alias="templateId")]

    recipient_id: Annotated[int, pydantic.Field(alias="recipientId")]

    page: float
    r"""The page number of the field on the document. Starts from 1."""

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[DocumentCreateDocumentTemporaryFieldMeta],
        pydantic.Field(alias="fieldMeta"),
    ]

    position_x: Annotated[Optional[Any], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[Any], pydantic.Field(alias="positionY")] = None

    width: Optional[Any] = None

    height: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["positionX", "positionY", "width", "height"]
        nullable_fields = ["documentId", "templateId", "fieldMeta"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentTypedDict(TypedDict):
    visibility: DocumentCreateDocumentTemporaryVisibility
    status: DocumentCreateDocumentTemporaryStatus
    source: DocumentCreateDocumentTemporarySource
    id: int
    external_id: Nullable[str]
    r"""A custom external ID you can use to identify the document."""
    user_id: float
    r"""The ID of the user that created this document."""
    auth_options: Nullable[DocumentCreateDocumentTemporaryAuthOptionsTypedDict]
    form_values: Nullable[Dict[str, DocumentCreateDocumentTemporaryFormValuesTypedDict]]
    title: str
    document_data_id: str
    created_at: str
    updated_at: str
    completed_at: Nullable[str]
    deleted_at: Nullable[str]
    team_id: Nullable[int]
    template_id: Nullable[int]
    document_data: DocumentCreateDocumentTemporaryDocumentDataTypedDict
    document_meta: Nullable[DocumentCreateDocumentTemporaryDocumentMetaTypedDict]
    recipients: List[DocumentCreateDocumentTemporaryDocumentsRecipientsTypedDict]
    fields: List[DocumentCreateDocumentTemporaryDocumentsFieldsTypedDict]


class Document(BaseModel):
    visibility: DocumentCreateDocumentTemporaryVisibility

    status: DocumentCreateDocumentTemporaryStatus

    source: DocumentCreateDocumentTemporarySource

    id: int

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]
    r"""A custom external ID you can use to identify the document."""

    user_id: Annotated[float, pydantic.Field(alias="userId")]
    r"""The ID of the user that created this document."""

    auth_options: Annotated[
        Nullable[DocumentCreateDocumentTemporaryAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    form_values: Annotated[
        Nullable[Dict[str, DocumentCreateDocumentTemporaryFormValues]],
        pydantic.Field(alias="formValues"),
    ]

    title: str

    document_data_id: Annotated[str, pydantic.Field(alias="documentDataId")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    completed_at: Annotated[Nullable[str], pydantic.Field(alias="completedAt")]

    deleted_at: Annotated[Nullable[str], pydantic.Field(alias="deletedAt")]

    team_id: Annotated[Nullable[int], pydantic.Field(alias="teamId")]

    template_id: Annotated[Nullable[int], pydantic.Field(alias="templateId")]

    document_data: Annotated[
        DocumentCreateDocumentTemporaryDocumentData,
        pydantic.Field(alias="documentData"),
    ]

    document_meta: Annotated[
        Nullable[DocumentCreateDocumentTemporaryDocumentMeta],
        pydantic.Field(alias="documentMeta"),
    ]

    recipients: List[DocumentCreateDocumentTemporaryDocumentsRecipients]

    fields: List[DocumentCreateDocumentTemporaryDocumentsFields]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "externalId",
            "authOptions",
            "formValues",
            "completedAt",
            "deletedAt",
            "teamId",
            "templateId",
            "documentMeta",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryResponseBodyTypedDict(TypedDict):
    r"""Successful response"""

    document: DocumentTypedDict
    upload_url: str
    r"""The URL to upload the document PDF to. Use a PUT request with the file via form-data"""


class DocumentCreateDocumentTemporaryResponseBody(BaseModel):
    r"""Successful response"""

    document: Document

    upload_url: Annotated[str, pydantic.Field(alias="uploadUrl")]
    r"""The URL to upload the document PDF to. Use a PUT request with the file via form-data"""
