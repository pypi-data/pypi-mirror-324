"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import BaseModel, Nullable, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class TemplateCreateDocumentFromTemplateRecipientsTypedDict(TypedDict):
    id: float
    r"""The ID of the recipient in the template."""
    email: str
    name: NotRequired[str]


class TemplateCreateDocumentFromTemplateRecipients(BaseModel):
    id: float
    r"""The ID of the recipient in the template."""

    email: str

    name: Optional[str] = None


class TemplateCreateDocumentFromTemplateRequestBodyTypedDict(TypedDict):
    template_id: float
    recipients: List[TemplateCreateDocumentFromTemplateRecipientsTypedDict]
    r"""The information of the recipients to create the document with."""
    distribute_document: NotRequired[bool]
    r"""Whether to create the document as pending and distribute it to recipients."""
    custom_document_data_id: NotRequired[str]
    r"""The data ID of an alternative PDF to use when creating the document. If not provided, the PDF attached to the template will be used."""


class TemplateCreateDocumentFromTemplateRequestBody(BaseModel):
    template_id: Annotated[float, pydantic.Field(alias="templateId")]

    recipients: List[TemplateCreateDocumentFromTemplateRecipients]
    r"""The information of the recipients to create the document with."""

    distribute_document: Annotated[
        Optional[bool], pydantic.Field(alias="distributeDocument")
    ] = None
    r"""Whether to create the document as pending and distribute it to recipients."""

    custom_document_data_id: Annotated[
        Optional[str], pydantic.Field(alias="customDocumentDataId")
    ] = None
    r"""The data ID of an alternative PDF to use when creating the document. If not provided, the PDF attached to the template will be used."""


class TemplateCreateDocumentFromTemplateTemplatesIssuesTypedDict(TypedDict):
    message: str


class TemplateCreateDocumentFromTemplateTemplatesIssues(BaseModel):
    message: str


class TemplateCreateDocumentFromTemplateTemplatesResponseResponseBodyData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateCreateDocumentFromTemplateTemplatesIssues]] = None


class TemplateCreateDocumentFromTemplateTemplatesResponseResponseBody(Exception):
    r"""Internal server error"""

    data: TemplateCreateDocumentFromTemplateTemplatesResponseResponseBodyData

    def __init__(
        self, data: TemplateCreateDocumentFromTemplateTemplatesResponseResponseBodyData
    ):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data,
            TemplateCreateDocumentFromTemplateTemplatesResponseResponseBodyData,
        )


class TemplateCreateDocumentFromTemplateIssuesTypedDict(TypedDict):
    message: str


class TemplateCreateDocumentFromTemplateIssues(BaseModel):
    message: str


class TemplateCreateDocumentFromTemplateTemplatesResponseBodyData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateCreateDocumentFromTemplateIssues]] = None


class TemplateCreateDocumentFromTemplateTemplatesResponseBody(Exception):
    r"""Invalid input data"""

    data: TemplateCreateDocumentFromTemplateTemplatesResponseBodyData

    def __init__(
        self, data: TemplateCreateDocumentFromTemplateTemplatesResponseBodyData
    ):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, TemplateCreateDocumentFromTemplateTemplatesResponseBodyData
        )


class TemplateCreateDocumentFromTemplateVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class TemplateCreateDocumentFromTemplateStatus(str, Enum):
    DRAFT = "DRAFT"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"


class TemplateCreateDocumentFromTemplateSource(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class TemplateCreateDocumentFromTemplateGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateCreateDocumentFromTemplateGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class TemplateCreateDocumentFromTemplateAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[TemplateCreateDocumentFromTemplateGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[TemplateCreateDocumentFromTemplateGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class TemplateCreateDocumentFromTemplateAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


TemplateCreateDocumentFromTemplateFormValuesTypedDict = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFormValuesTypedDict", Union[str, bool, float]
)


TemplateCreateDocumentFromTemplateFormValues = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFormValues", Union[str, bool, float]
)


class TemplateCreateDocumentFromTemplateType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class TemplateCreateDocumentFromTemplateDocumentDataTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateType
    id: str
    data: str
    initial_data: str


class TemplateCreateDocumentFromTemplateDocumentData(BaseModel):
    type: TemplateCreateDocumentFromTemplateType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]


class TemplateCreateDocumentFromTemplateSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class TemplateCreateDocumentFromTemplateDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class TemplateCreateDocumentFromTemplateEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateCreateDocumentFromTemplateEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateCreateDocumentFromTemplateDocumentMetaTypedDict(TypedDict):
    signing_order: TemplateCreateDocumentFromTemplateSigningOrder
    distribution_method: TemplateCreateDocumentFromTemplateDistributionMethod
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    password: Nullable[str]
    date_format: Nullable[str]
    document_id: int
    redirect_url: Nullable[str]
    typed_signature_enabled: bool
    language: str
    email_settings: Nullable[TemplateCreateDocumentFromTemplateEmailSettingsTypedDict]


class TemplateCreateDocumentFromTemplateDocumentMeta(BaseModel):
    signing_order: Annotated[
        TemplateCreateDocumentFromTemplateSigningOrder,
        pydantic.Field(alias="signingOrder"),
    ]

    distribution_method: Annotated[
        TemplateCreateDocumentFromTemplateDistributionMethod,
        pydantic.Field(alias="distributionMethod"),
    ]

    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    password: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    document_id: Annotated[int, pydantic.Field(alias="documentId")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    language: str

    email_settings: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "password",
            "dateFormat",
            "redirectUrl",
            "emailSettings",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"


class TemplateCreateDocumentFromTemplateReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class TemplateCreateDocumentFromTemplateSigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class TemplateCreateDocumentFromTemplateSendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class TemplateCreateDocumentFromTemplateAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateCreateDocumentFromTemplateActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class TemplateCreateDocumentFromTemplateTemplatesAuthOptionsTypedDict(TypedDict):
    access_auth: Nullable[TemplateCreateDocumentFromTemplateAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: Nullable[TemplateCreateDocumentFromTemplateActionAuth]
    r"""The type of authentication required for the recipient to sign the document."""


class TemplateCreateDocumentFromTemplateTemplatesAuthOptions(BaseModel):
    access_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateAccessAuth],
        pydantic.Field(alias="accessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateActionAuth],
        pydantic.Field(alias="actionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateTemplatesRecipientsTypedDict(TypedDict):
    role: TemplateCreateDocumentFromTemplateRole
    read_status: TemplateCreateDocumentFromTemplateReadStatus
    signing_status: TemplateCreateDocumentFromTemplateSigningStatus
    send_status: TemplateCreateDocumentFromTemplateSendStatus
    id: int
    document_id: Nullable[int]
    template_id: Nullable[int]
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[
        TemplateCreateDocumentFromTemplateTemplatesAuthOptionsTypedDict
    ]
    signing_order: Nullable[float]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""
    rejection_reason: Nullable[str]


class TemplateCreateDocumentFromTemplateTemplatesRecipients(BaseModel):
    role: TemplateCreateDocumentFromTemplateRole

    read_status: Annotated[
        TemplateCreateDocumentFromTemplateReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        TemplateCreateDocumentFromTemplateSigningStatus,
        pydantic.Field(alias="signingStatus"),
    ]

    send_status: Annotated[
        TemplateCreateDocumentFromTemplateSendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: int

    document_id: Annotated[Nullable[int], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[int], pydantic.Field(alias="templateId")]

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateTemplatesAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "documentId",
            "templateId",
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateTemplatesType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFields9Type(
    str, Enum
):
    DROPDOWN = "dropdown"


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseValuesTypedDict(
    TypedDict
):
    value: str


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseValues(BaseModel):
    value: str


class TemplateCreateDocumentFromTemplateFieldMeta9TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFields9Type
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[
        List[
            TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseValuesTypedDict
        ]
    ]
    default_value: NotRequired[str]


class TemplateCreateDocumentFromTemplateFieldMeta9(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFields9Type

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[
        List[TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseValues]
    ] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFields8Type(
    str, Enum
):
    CHECKBOX = "checkbox"


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesValuesTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesValues(BaseModel):
    id: float

    checked: bool

    value: str


class TemplateCreateDocumentFromTemplateFieldMeta8TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFields8Type
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[
        List[TemplateCreateDocumentFromTemplateFieldMetaTemplatesValuesTypedDict]
    ]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta8(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFields8Type

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[
        List[TemplateCreateDocumentFromTemplateFieldMetaTemplatesValues]
    ] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFieldsType(
    str, Enum
):
    RADIO = "radio"


class TemplateCreateDocumentFromTemplateFieldMetaValuesTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class TemplateCreateDocumentFromTemplateFieldMetaValues(BaseModel):
    id: float

    checked: bool

    value: str


class TemplateCreateDocumentFromTemplateFieldMeta7TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFieldsType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[
        List[TemplateCreateDocumentFromTemplateFieldMetaValuesTypedDict]
    ]


class TemplateCreateDocumentFromTemplateFieldMeta7(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyFieldsType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateCreateDocumentFromTemplateFieldMetaValues]] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyType(
    str, Enum
):
    NUMBER = "number"


class TemplateCreateDocumentFromTemplateFieldMeta6TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta6(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONResponseBodyType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONType(
    str, Enum
):
    TEXT = "text"


class TemplateCreateDocumentFromTemplateFieldMeta5TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta5(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200ApplicationJSONType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200Type(str, Enum):
    DATE = "date"


class TemplateCreateDocumentFromTemplateFieldMeta4TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200Type
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta4(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponse200Type

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseType(str, Enum):
    EMAIL = "email"


class TemplateCreateDocumentFromTemplateFieldMeta3TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta3(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesResponseType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class TemplateCreateDocumentFromTemplateFieldMetaTemplatesType(str, Enum):
    NAME = "name"


class TemplateCreateDocumentFromTemplateFieldMeta2TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta2(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTemplatesType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


class TemplateCreateDocumentFromTemplateFieldMetaType(str, Enum):
    INITIALS = "initials"


class TemplateCreateDocumentFromTemplateFieldMeta1TypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaType
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMeta1(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaType

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None


TemplateCreateDocumentFromTemplateFieldMetaTypedDict = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFieldMetaTypedDict",
    Union[
        TemplateCreateDocumentFromTemplateFieldMeta1TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta2TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta3TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta4TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta7TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta9TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta5TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta8TypedDict,
        TemplateCreateDocumentFromTemplateFieldMeta6TypedDict,
    ],
)


TemplateCreateDocumentFromTemplateFieldMeta = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFieldMeta",
    Union[
        TemplateCreateDocumentFromTemplateFieldMeta1,
        TemplateCreateDocumentFromTemplateFieldMeta2,
        TemplateCreateDocumentFromTemplateFieldMeta3,
        TemplateCreateDocumentFromTemplateFieldMeta4,
        TemplateCreateDocumentFromTemplateFieldMeta7,
        TemplateCreateDocumentFromTemplateFieldMeta9,
        TemplateCreateDocumentFromTemplateFieldMeta5,
        TemplateCreateDocumentFromTemplateFieldMeta8,
        TemplateCreateDocumentFromTemplateFieldMeta6,
    ],
)


class TemplateCreateDocumentFromTemplateFieldsTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateTemplatesType
    id: int
    secondary_id: str
    document_id: Nullable[int]
    template_id: Nullable[int]
    recipient_id: int
    page: float
    r"""The page number of the field on the document. Starts from 1."""
    custom_text: str
    inserted: bool
    field_meta: Nullable[TemplateCreateDocumentFromTemplateFieldMetaTypedDict]
    position_x: NotRequired[Any]
    position_y: NotRequired[Any]
    width: NotRequired[Any]
    height: NotRequired[Any]


class TemplateCreateDocumentFromTemplateFields(BaseModel):
    type: TemplateCreateDocumentFromTemplateTemplatesType

    id: int

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    document_id: Annotated[Nullable[int], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[int], pydantic.Field(alias="templateId")]

    recipient_id: Annotated[int, pydantic.Field(alias="recipientId")]

    page: float
    r"""The page number of the field on the document. Starts from 1."""

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateFieldMeta],
        pydantic.Field(alias="fieldMeta"),
    ]

    position_x: Annotated[Optional[Any], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[Any], pydantic.Field(alias="positionY")] = None

    width: Optional[Any] = None

    height: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["positionX", "positionY", "width", "height"]
        nullable_fields = ["documentId", "templateId", "fieldMeta"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateResponseBodyTypedDict(TypedDict):
    r"""Successful response"""

    visibility: TemplateCreateDocumentFromTemplateVisibility
    status: TemplateCreateDocumentFromTemplateStatus
    source: TemplateCreateDocumentFromTemplateSource
    id: int
    external_id: Nullable[str]
    r"""A custom external ID you can use to identify the document."""
    user_id: float
    r"""The ID of the user that created this document."""
    auth_options: Nullable[TemplateCreateDocumentFromTemplateAuthOptionsTypedDict]
    form_values: Nullable[
        Dict[str, TemplateCreateDocumentFromTemplateFormValuesTypedDict]
    ]
    title: str
    document_data_id: str
    created_at: str
    updated_at: str
    completed_at: Nullable[str]
    deleted_at: Nullable[str]
    team_id: Nullable[int]
    template_id: Nullable[int]
    document_data: TemplateCreateDocumentFromTemplateDocumentDataTypedDict
    document_meta: Nullable[TemplateCreateDocumentFromTemplateDocumentMetaTypedDict]
    recipients: List[TemplateCreateDocumentFromTemplateTemplatesRecipientsTypedDict]
    fields: List[TemplateCreateDocumentFromTemplateFieldsTypedDict]


class TemplateCreateDocumentFromTemplateResponseBody(BaseModel):
    r"""Successful response"""

    visibility: TemplateCreateDocumentFromTemplateVisibility

    status: TemplateCreateDocumentFromTemplateStatus

    source: TemplateCreateDocumentFromTemplateSource

    id: int

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]
    r"""A custom external ID you can use to identify the document."""

    user_id: Annotated[float, pydantic.Field(alias="userId")]
    r"""The ID of the user that created this document."""

    auth_options: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    form_values: Annotated[
        Nullable[Dict[str, TemplateCreateDocumentFromTemplateFormValues]],
        pydantic.Field(alias="formValues"),
    ]

    title: str

    document_data_id: Annotated[str, pydantic.Field(alias="documentDataId")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    completed_at: Annotated[Nullable[str], pydantic.Field(alias="completedAt")]

    deleted_at: Annotated[Nullable[str], pydantic.Field(alias="deletedAt")]

    team_id: Annotated[Nullable[int], pydantic.Field(alias="teamId")]

    template_id: Annotated[Nullable[int], pydantic.Field(alias="templateId")]

    document_data: Annotated[
        TemplateCreateDocumentFromTemplateDocumentData,
        pydantic.Field(alias="documentData"),
    ]

    document_meta: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateDocumentMeta],
        pydantic.Field(alias="documentMeta"),
    ]

    recipients: List[TemplateCreateDocumentFromTemplateTemplatesRecipients]

    fields: List[TemplateCreateDocumentFromTemplateFields]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "externalId",
            "authOptions",
            "formValues",
            "completedAt",
            "deletedAt",
            "teamId",
            "templateId",
            "documentMeta",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
