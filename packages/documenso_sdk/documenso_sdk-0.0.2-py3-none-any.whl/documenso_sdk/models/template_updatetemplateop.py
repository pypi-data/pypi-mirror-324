"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class TemplateUpdateTemplateVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class TemplateUpdateTemplateGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateUpdateTemplateGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class TemplateUpdateTemplateType(str, Enum):
    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"


class TemplateUpdateTemplateDataTypedDict(TypedDict):
    title: NotRequired[str]
    external_id: NotRequired[Nullable[str]]
    visibility: NotRequired[TemplateUpdateTemplateVisibility]
    global_access_auth: NotRequired[Nullable[TemplateUpdateTemplateGlobalAccessAuth]]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: NotRequired[Nullable[TemplateUpdateTemplateGlobalActionAuth]]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""
    public_title: NotRequired[str]
    r"""The title of the template that will be displayed to the public. Only applicable for public templates."""
    public_description: NotRequired[str]
    r"""The description of the template that will be displayed to the public. Only applicable for public templates."""
    type: NotRequired[TemplateUpdateTemplateType]


class TemplateUpdateTemplateData(BaseModel):
    title: Optional[str] = None

    external_id: Annotated[
        OptionalNullable[str], pydantic.Field(alias="externalId")
    ] = UNSET

    visibility: Optional[TemplateUpdateTemplateVisibility] = None

    global_access_auth: Annotated[
        OptionalNullable[TemplateUpdateTemplateGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ] = UNSET
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        OptionalNullable[TemplateUpdateTemplateGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ] = UNSET
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    public_title: Annotated[Optional[str], pydantic.Field(alias="publicTitle")] = None
    r"""The title of the template that will be displayed to the public. Only applicable for public templates."""

    public_description: Annotated[
        Optional[str], pydantic.Field(alias="publicDescription")
    ] = None
    r"""The description of the template that will be displayed to the public. Only applicable for public templates."""

    type: Optional[TemplateUpdateTemplateType] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "title",
            "externalId",
            "visibility",
            "globalAccessAuth",
            "globalActionAuth",
            "publicTitle",
            "publicDescription",
            "type",
        ]
        nullable_fields = ["externalId", "globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateUpdateTemplateDateFormat(str, Enum):
    r"""The date format to use for date fields and signing the document."""

    YYYY_MM_DD_HH_MM_A = "yyyy-MM-dd hh:mm a"
    YYYY_MM_DD = "yyyy-MM-dd"
    DD_MM_YYYY_HH_MM_A = "dd/MM/yyyy hh:mm a"
    MM_DD_YYYY_HH_MM_A = "MM/dd/yyyy hh:mm a"
    YYYY_MM_DD_HH_MM = "yyyy-MM-dd HH:mm"
    YY_MM_DD_HH_MM_A = "yy-MM-dd hh:mm a"
    YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss"
    MMMM_DD_YYYY_HH_MM_A = "MMMM dd, yyyy hh:mm a"
    EEEE_MMMM_DD_YYYY_HH_MM_A = "EEEE, MMMM dd, yyyy hh:mm a"
    YYYY_MM_DD_T_HH_MM_SS_SSSXXX = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"


class TemplateUpdateTemplateDistributionMethod(str, Enum):
    r"""The distribution method to use when sending the document to the recipients."""

    EMAIL = "EMAIL"
    NONE = "NONE"


class TemplateUpdateTemplateEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateUpdateTemplateEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateUpdateTemplateLanguage(str, Enum):
    r"""The language to use for email communications with recipients."""

    DE = "de"
    EN = "en"
    FR = "fr"
    ES = "es"


class TemplateUpdateTemplateSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class TemplateUpdateTemplateMetaTypedDict(TypedDict):
    subject: NotRequired[str]
    r"""The subject of the email that will be sent to the recipients."""
    message: NotRequired[str]
    r"""The message of the email that will be sent to the recipients."""
    timezone: NotRequired[str]
    r"""The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne"""
    date_format: NotRequired[TemplateUpdateTemplateDateFormat]
    r"""The date format to use for date fields and signing the document."""
    distribution_method: NotRequired[TemplateUpdateTemplateDistributionMethod]
    r"""The distribution method to use when sending the document to the recipients."""
    email_settings: NotRequired[TemplateUpdateTemplateEmailSettingsTypedDict]
    redirect_url: NotRequired[str]
    r"""The URL to which the recipient should be redirected after signing the document."""
    language: NotRequired[TemplateUpdateTemplateLanguage]
    r"""The language to use for email communications with recipients."""
    typed_signature_enabled: NotRequired[bool]
    r"""Whether to allow recipients to sign using a typed signature."""
    signing_order: NotRequired[TemplateUpdateTemplateSigningOrder]


class TemplateUpdateTemplateMeta(BaseModel):
    subject: Optional[str] = None
    r"""The subject of the email that will be sent to the recipients."""

    message: Optional[str] = None
    r"""The message of the email that will be sent to the recipients."""

    timezone: Optional[str] = None
    r"""The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne"""

    date_format: Annotated[
        Optional[TemplateUpdateTemplateDateFormat], pydantic.Field(alias="dateFormat")
    ] = None
    r"""The date format to use for date fields and signing the document."""

    distribution_method: Annotated[
        Optional[TemplateUpdateTemplateDistributionMethod],
        pydantic.Field(alias="distributionMethod"),
    ] = None
    r"""The distribution method to use when sending the document to the recipients."""

    email_settings: Annotated[
        Optional[TemplateUpdateTemplateEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ] = None

    redirect_url: Annotated[Optional[str], pydantic.Field(alias="redirectUrl")] = None
    r"""The URL to which the recipient should be redirected after signing the document."""

    language: Optional[TemplateUpdateTemplateLanguage] = None
    r"""The language to use for email communications with recipients."""

    typed_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="typedSignatureEnabled")
    ] = None
    r"""Whether to allow recipients to sign using a typed signature."""

    signing_order: Annotated[
        Optional[TemplateUpdateTemplateSigningOrder],
        pydantic.Field(alias="signingOrder"),
    ] = None


class TemplateUpdateTemplateRequestBodyTypedDict(TypedDict):
    template_id: float
    data: NotRequired[TemplateUpdateTemplateDataTypedDict]
    meta: NotRequired[TemplateUpdateTemplateMetaTypedDict]


class TemplateUpdateTemplateRequestBody(BaseModel):
    template_id: Annotated[float, pydantic.Field(alias="templateId")]

    data: Optional[TemplateUpdateTemplateData] = None

    meta: Optional[TemplateUpdateTemplateMeta] = None


class TemplateUpdateTemplateTemplatesIssuesTypedDict(TypedDict):
    message: str


class TemplateUpdateTemplateTemplatesIssues(BaseModel):
    message: str


class TemplateUpdateTemplateTemplatesResponseResponseBodyData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateUpdateTemplateTemplatesIssues]] = None


class TemplateUpdateTemplateTemplatesResponseResponseBody(Exception):
    r"""Internal server error"""

    data: TemplateUpdateTemplateTemplatesResponseResponseBodyData

    def __init__(self, data: TemplateUpdateTemplateTemplatesResponseResponseBodyData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, TemplateUpdateTemplateTemplatesResponseResponseBodyData
        )


class TemplateUpdateTemplateIssuesTypedDict(TypedDict):
    message: str


class TemplateUpdateTemplateIssues(BaseModel):
    message: str


class TemplateUpdateTemplateTemplatesResponseBodyData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateUpdateTemplateIssues]] = None


class TemplateUpdateTemplateTemplatesResponseBody(Exception):
    r"""Invalid input data"""

    data: TemplateUpdateTemplateTemplatesResponseBodyData

    def __init__(self, data: TemplateUpdateTemplateTemplatesResponseBodyData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, TemplateUpdateTemplateTemplatesResponseBodyData
        )


class TemplateUpdateTemplateTemplatesType(str, Enum):
    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"


class TemplateUpdateTemplateTemplatesVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class TemplateUpdateTemplateTemplatesGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateUpdateTemplateTemplatesGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class TemplateUpdateTemplateAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[TemplateUpdateTemplateTemplatesGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[TemplateUpdateTemplateTemplatesGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class TemplateUpdateTemplateAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[TemplateUpdateTemplateTemplatesGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[TemplateUpdateTemplateTemplatesGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateUpdateTemplateResponseBodyTypedDict(TypedDict):
    r"""Successful response"""

    type: TemplateUpdateTemplateTemplatesType
    visibility: TemplateUpdateTemplateTemplatesVisibility
    id: int
    external_id: Nullable[str]
    title: str
    user_id: int
    team_id: Nullable[int]
    auth_options: Nullable[TemplateUpdateTemplateAuthOptionsTypedDict]
    template_document_data_id: str
    created_at: str
    updated_at: str
    public_title: str
    public_description: str


class TemplateUpdateTemplateResponseBody(BaseModel):
    r"""Successful response"""

    type: TemplateUpdateTemplateTemplatesType

    visibility: TemplateUpdateTemplateTemplatesVisibility

    id: int

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]

    title: str

    user_id: Annotated[int, pydantic.Field(alias="userId")]

    team_id: Annotated[Nullable[int], pydantic.Field(alias="teamId")]

    auth_options: Annotated[
        Nullable[TemplateUpdateTemplateAuthOptions], pydantic.Field(alias="authOptions")
    ]

    template_document_data_id: Annotated[
        str, pydantic.Field(alias="templateDocumentDataId")
    ]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    public_title: Annotated[str, pydantic.Field(alias="publicTitle")]

    public_description: Annotated[str, pydantic.Field(alias="publicDescription")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["externalId", "teamId", "authOptions"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
