# Generated by cloudcoil-model-codegen v0.4.4
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class AuthenticationRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthenticationRef"]:
            return AuthenticationRef

        def build(self) -> "AuthenticationRef":
            return AuthenticationRef(**self._attrs)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the resource being referred to. Defaults to TriggerAuthentication.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["AuthenticationRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthenticationRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthenticationRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthenticationRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthenticationRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Optional[str] = None
    """
    Kind of the resource being referred to. Defaults to TriggerAuthentication.
    """
    name: str


class AzureEventGridTopic(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureEventGridTopic"]:
            return AzureEventGridTopic

        def build(self) -> "AzureEventGridTopic":
            return AzureEventGridTopic(**self._attrs)

        def endpoint(self, value: str, /) -> Self:
            return self._set("endpoint", value)

    class BuilderContext(BuilderContextBase["AzureEventGridTopic.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureEventGridTopic.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureEventGridTopic."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureEventGridTopic", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureEventGridTopic.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    endpoint: str


class Http(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Http"]:
            return Http

        def build(self) -> "Http":
            return Http(**self._attrs)

        def uri(self, value: str, /) -> Self:
            return self._set("uri", value)

    class BuilderContext(BuilderContextBase["Http.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Http.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Http."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Http", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Http.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    uri: str


class Destination(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Destination"]:
            return Destination

        def build(self) -> "Destination":
            return Destination(**self._attrs)

        @overload
        def azure_event_grid_topic(
            self, value_or_callback: Optional[AzureEventGridTopic], /
        ) -> "Destination.Builder": ...

        @overload
        def azure_event_grid_topic(
            self,
            value_or_callback: Callable[
                [AzureEventGridTopic.Builder],
                AzureEventGridTopic.Builder | AzureEventGridTopic,
            ],
            /,
        ) -> "Destination.Builder": ...

        @overload
        def azure_event_grid_topic(
            self, value_or_callback: Never = ...
        ) -> "AzureEventGridTopic.BuilderContext": ...

        def azure_event_grid_topic(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AzureEventGridTopic.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_event_grid_topic"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureEventGridTopic.builder())
                if isinstance(output, AzureEventGridTopic.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_event_grid_topic", value)

        @overload
        def http(self, value_or_callback: Optional[Http], /) -> "Destination.Builder": ...

        @overload
        def http(
            self, value_or_callback: Callable[[Http.Builder], Http.Builder | Http], /
        ) -> "Destination.Builder": ...

        @overload
        def http(self, value_or_callback: Never = ...) -> "Http.BuilderContext": ...

        def http(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Http.BuilderContext()
                context._parent_builder = self
                context._field_name = "http"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Http.builder())
                if isinstance(output, Http.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http", value)

    class BuilderContext(BuilderContextBase["Destination.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Destination.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Destination."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Destination", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Destination.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    azure_event_grid_topic: Annotated[
        Optional[AzureEventGridTopic], Field(alias="azureEventGridTopic")
    ] = None
    http: Optional[Http] = None


class EventSubscription(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EventSubscription"]:
            return EventSubscription

        def build(self) -> "EventSubscription":
            return EventSubscription(**self._attrs)

        def excluded_event_types(
            self,
            value: Optional[
                List[
                    Literal[
                        "keda.scaledobject.ready.v1",
                        "keda.scaledobject.failed.v1",
                        "keda.scaledobject.removed.v1",
                        "keda.scaledjob.ready.v1",
                        "keda.scaledjob.failed.v1",
                        "keda.scaledjob.removed.v1",
                        "keda.authentication.triggerauthentication.created.v1",
                        "keda.authentication.triggerauthentication.updated.v1",
                        "keda.authentication.triggerauthentication.removed.v1",
                        "keda.authentication.clustertriggerauthentication.created.v1",
                        "keda.authentication.clustertriggerauthentication.updated.v1",
                        "keda.authentication.clustertriggerauthentication.removed.v1",
                    ]
                ]
            ],
            /,
        ) -> Self:
            return self._set("excluded_event_types", value)

        def included_event_types(
            self,
            value: Optional[
                List[
                    Literal[
                        "keda.scaledobject.ready.v1",
                        "keda.scaledobject.failed.v1",
                        "keda.scaledobject.removed.v1",
                        "keda.scaledjob.ready.v1",
                        "keda.scaledjob.failed.v1",
                        "keda.scaledjob.removed.v1",
                        "keda.authentication.triggerauthentication.created.v1",
                        "keda.authentication.triggerauthentication.updated.v1",
                        "keda.authentication.triggerauthentication.removed.v1",
                        "keda.authentication.clustertriggerauthentication.created.v1",
                        "keda.authentication.clustertriggerauthentication.updated.v1",
                        "keda.authentication.clustertriggerauthentication.removed.v1",
                    ]
                ]
            ],
            /,
        ) -> Self:
            return self._set("included_event_types", value)

    class BuilderContext(BuilderContextBase["EventSubscription.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EventSubscription.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EventSubscription."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EventSubscription", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EventSubscription.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    excluded_event_types: Annotated[
        Optional[
            List[
                Literal[
                    "keda.scaledobject.ready.v1",
                    "keda.scaledobject.failed.v1",
                    "keda.scaledobject.removed.v1",
                    "keda.scaledjob.ready.v1",
                    "keda.scaledjob.failed.v1",
                    "keda.scaledjob.removed.v1",
                    "keda.authentication.triggerauthentication.created.v1",
                    "keda.authentication.triggerauthentication.updated.v1",
                    "keda.authentication.triggerauthentication.removed.v1",
                    "keda.authentication.clustertriggerauthentication.created.v1",
                    "keda.authentication.clustertriggerauthentication.updated.v1",
                    "keda.authentication.clustertriggerauthentication.removed.v1",
                ]
            ]
        ],
        Field(alias="excludedEventTypes"),
    ] = None
    included_event_types: Annotated[
        Optional[
            List[
                Literal[
                    "keda.scaledobject.ready.v1",
                    "keda.scaledobject.failed.v1",
                    "keda.scaledobject.removed.v1",
                    "keda.scaledjob.ready.v1",
                    "keda.scaledjob.failed.v1",
                    "keda.scaledjob.removed.v1",
                    "keda.authentication.triggerauthentication.created.v1",
                    "keda.authentication.triggerauthentication.updated.v1",
                    "keda.authentication.triggerauthentication.removed.v1",
                    "keda.authentication.clustertriggerauthentication.created.v1",
                    "keda.authentication.clustertriggerauthentication.updated.v1",
                    "keda.authentication.clustertriggerauthentication.removed.v1",
                ]
            ]
        ],
        Field(alias="includedEventTypes"),
    ] = None


class CloudEventSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CloudEventSourceSpec"]:
            return CloudEventSourceSpec

        def build(self) -> "CloudEventSourceSpec":
            return CloudEventSourceSpec(**self._attrs)

        @overload
        def authentication_ref(
            self, value_or_callback: Optional[AuthenticationRef], /
        ) -> "CloudEventSourceSpec.Builder": ...

        @overload
        def authentication_ref(
            self,
            value_or_callback: Callable[
                [AuthenticationRef.Builder],
                AuthenticationRef.Builder | AuthenticationRef,
            ],
            /,
        ) -> "CloudEventSourceSpec.Builder": ...

        @overload
        def authentication_ref(
            self, value_or_callback: Never = ...
        ) -> "AuthenticationRef.BuilderContext": ...

        def authentication_ref(self, value_or_callback=None, /):
            """
            AuthenticationRef points to the TriggerAuthentication or ClusterTriggerAuthentication object that
            is used to authenticate the scaler with the environment
            """
            if self._in_context and value_or_callback is None:
                context = AuthenticationRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "authentication_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthenticationRef.builder())
                if isinstance(output, AuthenticationRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authentication_ref", value)

        def cluster_name(self, value: Optional[str], /) -> Self:
            return self._set("cluster_name", value)

        @overload
        def destination(
            self, value_or_callback: Destination, /
        ) -> "CloudEventSourceSpec.Builder": ...

        @overload
        def destination(
            self,
            value_or_callback: Callable[[Destination.Builder], Destination.Builder | Destination],
            /,
        ) -> "CloudEventSourceSpec.Builder": ...

        @overload
        def destination(self, value_or_callback: Never = ...) -> "Destination.BuilderContext": ...

        def destination(self, value_or_callback=None, /):
            """
            Destination defines the various ways to emit events
            """
            if self._in_context and value_or_callback is None:
                context = Destination.BuilderContext()
                context._parent_builder = self
                context._field_name = "destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Destination.builder())
                if isinstance(output, Destination.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("destination", value)

        @overload
        def event_subscription(
            self, value_or_callback: Optional[EventSubscription], /
        ) -> "CloudEventSourceSpec.Builder": ...

        @overload
        def event_subscription(
            self,
            value_or_callback: Callable[
                [EventSubscription.Builder],
                EventSubscription.Builder | EventSubscription,
            ],
            /,
        ) -> "CloudEventSourceSpec.Builder": ...

        @overload
        def event_subscription(
            self, value_or_callback: Never = ...
        ) -> "EventSubscription.BuilderContext": ...

        def event_subscription(self, value_or_callback=None, /):
            """
            EventSubscription defines filters for events
            """
            if self._in_context and value_or_callback is None:
                context = EventSubscription.BuilderContext()
                context._parent_builder = self
                context._field_name = "event_subscription"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EventSubscription.builder())
                if isinstance(output, EventSubscription.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("event_subscription", value)

    class BuilderContext(BuilderContextBase["CloudEventSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CloudEventSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CloudEventSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CloudEventSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CloudEventSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication_ref: Annotated[Optional[AuthenticationRef], Field(alias="authenticationRef")] = (
        None
    )
    """
    AuthenticationRef points to the TriggerAuthentication or ClusterTriggerAuthentication object that
    is used to authenticate the scaler with the environment
    """
    cluster_name: Annotated[Optional[str], Field(alias="clusterName")] = None
    destination: Destination
    """
    Destination defines the various ways to emit events
    """
    event_subscription: Annotated[Optional[EventSubscription], Field(alias="eventSubscription")] = (
        None
    )
    """
    EventSubscription defines filters for events
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition
    """


class CloudEventSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CloudEventSourceStatus"]:
            return CloudEventSourceStatus

        def build(self) -> "CloudEventSourceStatus":
            return CloudEventSourceStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CloudEventSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CloudEventSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions an array representation to store multiple Conditions
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["CloudEventSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CloudEventSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CloudEventSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CloudEventSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CloudEventSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions an array representation to store multiple Conditions
    """


class ClusterCloudEventSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCloudEventSourceSpec"]:
            return ClusterCloudEventSourceSpec

        def build(self) -> "ClusterCloudEventSourceSpec":
            return ClusterCloudEventSourceSpec(**self._attrs)

        @overload
        def authentication_ref(
            self, value_or_callback: Optional[AuthenticationRef], /
        ) -> "ClusterCloudEventSourceSpec.Builder": ...

        @overload
        def authentication_ref(
            self,
            value_or_callback: Callable[
                [AuthenticationRef.Builder],
                AuthenticationRef.Builder | AuthenticationRef,
            ],
            /,
        ) -> "ClusterCloudEventSourceSpec.Builder": ...

        @overload
        def authentication_ref(
            self, value_or_callback: Never = ...
        ) -> "AuthenticationRef.BuilderContext": ...

        def authentication_ref(self, value_or_callback=None, /):
            """
            AuthenticationRef points to the TriggerAuthentication or ClusterTriggerAuthentication object that
            is used to authenticate the scaler with the environment
            """
            if self._in_context and value_or_callback is None:
                context = AuthenticationRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "authentication_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthenticationRef.builder())
                if isinstance(output, AuthenticationRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authentication_ref", value)

        def cluster_name(self, value: Optional[str], /) -> Self:
            return self._set("cluster_name", value)

        @overload
        def destination(
            self, value_or_callback: Destination, /
        ) -> "ClusterCloudEventSourceSpec.Builder": ...

        @overload
        def destination(
            self,
            value_or_callback: Callable[[Destination.Builder], Destination.Builder | Destination],
            /,
        ) -> "ClusterCloudEventSourceSpec.Builder": ...

        @overload
        def destination(self, value_or_callback: Never = ...) -> "Destination.BuilderContext": ...

        def destination(self, value_or_callback=None, /):
            """
            Destination defines the various ways to emit events
            """
            if self._in_context and value_or_callback is None:
                context = Destination.BuilderContext()
                context._parent_builder = self
                context._field_name = "destination"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Destination.builder())
                if isinstance(output, Destination.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("destination", value)

        @overload
        def event_subscription(
            self, value_or_callback: Optional[EventSubscription], /
        ) -> "ClusterCloudEventSourceSpec.Builder": ...

        @overload
        def event_subscription(
            self,
            value_or_callback: Callable[
                [EventSubscription.Builder],
                EventSubscription.Builder | EventSubscription,
            ],
            /,
        ) -> "ClusterCloudEventSourceSpec.Builder": ...

        @overload
        def event_subscription(
            self, value_or_callback: Never = ...
        ) -> "EventSubscription.BuilderContext": ...

        def event_subscription(self, value_or_callback=None, /):
            """
            EventSubscription defines filters for events
            """
            if self._in_context and value_or_callback is None:
                context = EventSubscription.BuilderContext()
                context._parent_builder = self
                context._field_name = "event_subscription"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EventSubscription.builder())
                if isinstance(output, EventSubscription.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("event_subscription", value)

    class BuilderContext(BuilderContextBase["ClusterCloudEventSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCloudEventSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCloudEventSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCloudEventSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCloudEventSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication_ref: Annotated[Optional[AuthenticationRef], Field(alias="authenticationRef")] = (
        None
    )
    """
    AuthenticationRef points to the TriggerAuthentication or ClusterTriggerAuthentication object that
    is used to authenticate the scaler with the environment
    """
    cluster_name: Annotated[Optional[str], Field(alias="clusterName")] = None
    destination: Destination
    """
    Destination defines the various ways to emit events
    """
    event_subscription: Annotated[Optional[EventSubscription], Field(alias="eventSubscription")] = (
        None
    )
    """
    EventSubscription defines filters for events
    """


class ClusterCloudEventSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCloudEventSourceStatus"]:
            return ClusterCloudEventSourceStatus

        def build(self) -> "ClusterCloudEventSourceStatus":
            return ClusterCloudEventSourceStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ClusterCloudEventSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ClusterCloudEventSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions an array representation to store multiple Conditions
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["ClusterCloudEventSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCloudEventSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCloudEventSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCloudEventSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCloudEventSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions an array representation to store multiple Conditions
    """


class CloudEventSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CloudEventSource"]:
            return CloudEventSource

        def build(self) -> "CloudEventSource":
            return CloudEventSource(**self._attrs)

        def api_version(self, value: Optional[Literal["eventing.keda.sh/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["CloudEventSource"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "CloudEventSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "CloudEventSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: CloudEventSourceSpec, /
        ) -> "CloudEventSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CloudEventSourceSpec.Builder],
                CloudEventSourceSpec.Builder | CloudEventSourceSpec,
            ],
            /,
        ) -> "CloudEventSource.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CloudEventSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CloudEventSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CloudEventSourceSpec.builder())
                if isinstance(output, CloudEventSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CloudEventSourceStatus], /
        ) -> "CloudEventSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CloudEventSourceStatus.Builder],
                CloudEventSourceStatus.Builder | CloudEventSourceStatus,
            ],
            /,
        ) -> "CloudEventSource.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "CloudEventSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CloudEventSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CloudEventSourceStatus.builder())
                if isinstance(output, CloudEventSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["CloudEventSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CloudEventSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CloudEventSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CloudEventSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CloudEventSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["eventing.keda.sh/v1alpha1"]], Field(alias="apiVersion")
    ] = "eventing.keda.sh/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["CloudEventSource"]] = "CloudEventSource"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: CloudEventSourceSpec
    status: Optional[CloudEventSourceStatus] = None


class ClusterCloudEventSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCloudEventSource"]:
            return ClusterCloudEventSource

        def build(self) -> "ClusterCloudEventSource":
            return ClusterCloudEventSource(**self._attrs)

        def api_version(self, value: Optional[Literal["eventing.keda.sh/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterCloudEventSource"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterCloudEventSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterCloudEventSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ClusterCloudEventSourceSpec, /
        ) -> "ClusterCloudEventSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterCloudEventSourceSpec.Builder],
                ClusterCloudEventSourceSpec.Builder | ClusterCloudEventSourceSpec,
            ],
            /,
        ) -> "ClusterCloudEventSource.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterCloudEventSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterCloudEventSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterCloudEventSourceSpec.builder())
                if isinstance(output, ClusterCloudEventSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterCloudEventSourceStatus], /
        ) -> "ClusterCloudEventSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterCloudEventSourceStatus.Builder],
                ClusterCloudEventSourceStatus.Builder | ClusterCloudEventSourceStatus,
            ],
            /,
        ) -> "ClusterCloudEventSource.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ClusterCloudEventSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterCloudEventSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterCloudEventSourceStatus.builder())
                if isinstance(output, ClusterCloudEventSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterCloudEventSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCloudEventSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCloudEventSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCloudEventSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCloudEventSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["eventing.keda.sh/v1alpha1"]], Field(alias="apiVersion")
    ] = "eventing.keda.sh/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterCloudEventSource"]] = "ClusterCloudEventSource"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterCloudEventSourceSpec
    status: Optional[ClusterCloudEventSourceStatus] = None
