# Generated by cloudcoil-model-codegen v0.4.3
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class BackupRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupRepositorySpec"]:
            return BackupRepositorySpec

        def build(self) -> "BackupRepositorySpec":
            return BackupRepositorySpec(**self._attrs)

        def backup_storage_location(self, value: str, /) -> Self:
            """
            BackupStorageLocation is the name of the BackupStorageLocation
            that should contain this repository.
            """
            return self._set("backup_storage_location", value)

        def maintenance_frequency(self, value: str, /) -> Self:
            """
            MaintenanceFrequency is how often maintenance should be run.
            """
            return self._set("maintenance_frequency", value)

        def repository_config(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            RepositoryConfig is for repository-specific configuration fields.
            """
            return self._set("repository_config", value)

        def repository_type(self, value: Optional[Literal["kopia", "restic", ""]], /) -> Self:
            """
            RepositoryType indicates the type of the backend repository
            """
            return self._set("repository_type", value)

        def restic_identifier(self, value: str, /) -> Self:
            """
            ResticIdentifier is the full restic-compatible string for identifying
            this repository.
            """
            return self._set("restic_identifier", value)

        def volume_namespace(self, value: str, /) -> Self:
            """
            VolumeNamespace is the namespace this backup repository contains
            pod volume backups for.
            """
            return self._set("volume_namespace", value)

    class BuilderContext(BuilderContextBase["BackupRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_storage_location: Annotated[str, Field(alias="backupStorageLocation")]
    """
    BackupStorageLocation is the name of the BackupStorageLocation
    that should contain this repository.
    """
    maintenance_frequency: Annotated[str, Field(alias="maintenanceFrequency")]
    """
    MaintenanceFrequency is how often maintenance should be run.
    """
    repository_config: Annotated[Optional[Dict[str, str]], Field(alias="repositoryConfig")] = None
    """
    RepositoryConfig is for repository-specific configuration fields.
    """
    repository_type: Annotated[
        Optional[Literal["kopia", "restic", ""]], Field(alias="repositoryType")
    ] = None
    """
    RepositoryType indicates the type of the backend repository
    """
    restic_identifier: Annotated[str, Field(alias="resticIdentifier")]
    """
    ResticIdentifier is the full restic-compatible string for identifying
    this repository.
    """
    volume_namespace: Annotated[str, Field(alias="volumeNamespace")]
    """
    VolumeNamespace is the namespace this backup repository contains
    pod volume backups for.
    """


class BackupRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupRepositoryStatus"]:
            return BackupRepositoryStatus

        def build(self) -> "BackupRepositoryStatus":
            return BackupRepositoryStatus(**self._attrs)

        def last_maintenance_time(self, value: Optional[datetime], /) -> Self:
            """
            LastMaintenanceTime is the last time maintenance was run.
            """
            return self._set("last_maintenance_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is a message about the current status of the BackupRepository.
            """
            return self._set("message", value)

        def phase(self, value: Optional[Literal["New", "Ready", "NotReady"]], /) -> Self:
            """
            Phase is the current state of the BackupRepository.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["BackupRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_maintenance_time: Annotated[Optional[datetime], Field(alias="lastMaintenanceTime")] = None
    """
    LastMaintenanceTime is the last time maintenance was run.
    """
    message: Optional[str] = None
    """
    Message is a message about the current status of the BackupRepository.
    """
    phase: Optional[Literal["New", "Ready", "NotReady"]] = None
    """
    Phase is the current state of the BackupRepository.
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class LabelSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LabelSelector"]:
            return LabelSelector

        def build(self) -> "LabelSelector":
            return LabelSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "LabelSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "LabelSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["LabelSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LabelSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LabelSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LabelSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LabelSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Exec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exec"]:
            return Exec

        def build(self) -> "Exec":
            return Exec(**self._attrs)

        def command(self, value: List[str], /) -> Self:
            """
            Command is the command and arguments to execute.
            """
            return self._set("command", value)

        def container(self, value: Optional[str], /) -> Self:
            """
            Container is the container in the pod where the command should be executed. If not specified,
            the pod's first container is used.
            """
            return self._set("container", value)

        def on_error(self, value: Optional[Literal["Continue", "Fail"]], /) -> Self:
            """
            OnError specifies how Velero should behave if it encounters an error executing this hook.
            """
            return self._set("on_error", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout defines the maximum amount of time Velero should wait for the hook to complete before
            considering the execution a failure.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Exec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: Annotated[List[str], Field(min_length=1)]
    """
    Command is the command and arguments to execute.
    """
    container: Optional[str] = None
    """
    Container is the container in the pod where the command should be executed. If not specified,
    the pod's first container is used.
    """
    on_error: Annotated[Optional[Literal["Continue", "Fail"]], Field(alias="onError")] = None
    """
    OnError specifies how Velero should behave if it encounters an error executing this hook.
    """
    timeout: Optional[str] = None
    """
    Timeout defines the maximum amount of time Velero should wait for the hook to complete before
    considering the execution a failure.
    """


class Post(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Post"]:
            return Post

        def build(self) -> "Post":
            return Post(**self._attrs)

        @overload
        def exec(self, value_or_callback: Exec, /) -> "Post.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "Post.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec defines an exec hook.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

    class BuilderContext(BuilderContextBase["Post.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Post.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Post."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Post", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Post.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Exec
    """
    Exec defines an exec hook.
    """


class Pre(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Pre"]:
            return Pre

        def build(self) -> "Pre":
            return Pre(**self._attrs)

        @overload
        def exec(self, value_or_callback: Exec, /) -> "Pre.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "Pre.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec defines an exec hook.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

    class BuilderContext(BuilderContextBase["Pre.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Pre.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Pre."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Pre", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Pre.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Exec
    """
    Exec defines an exec hook.
    """


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def excluded_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
            """
            return self._set("excluded_namespaces", value)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources specifies the resources to which this hook spec does not apply.
            """
            return self._set("excluded_resources", value)

        def included_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
            to all namespaces.
            """
            return self._set("included_namespaces", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
            to all resources.
            """
            return self._set("included_resources", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "ResourceModel.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector, if specified, filters the resources to which this hook spec applies.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of this hook.
            """
            return self._set("name", value)

        @overload
        def post(self, value_or_callback: List[Post], /) -> "ResourceModel.Builder": ...

        @overload
        def post(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Post, Post.Builder]],
                GenericListBuilder[Post, Post.Builder] | List[Post],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def post(self, value_or_callback: Never = ...) -> ListBuilderContext[Post.Builder]: ...

        def post(self, value_or_callback=None, /):
            """
            PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup.
            These are executed after all "additional items" from item actions are processed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Post.Builder]()
                context._parent_builder = self
                context._field_name = "post"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Post.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("post", value)

        @overload
        def pre(self, value_or_callback: List[Pre], /) -> "ResourceModel.Builder": ...

        @overload
        def pre(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pre, Pre.Builder]],
                GenericListBuilder[Pre, Pre.Builder] | List[Pre],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def pre(self, value_or_callback: Never = ...) -> ListBuilderContext[Pre.Builder]: ...

        def pre(self, value_or_callback=None, /):
            """
            PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup.
            These are executed before any "additional items" from item actions are processed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pre.Builder]()
                context._parent_builder = self
                context._field_name = "pre"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pre.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pre", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    excluded_namespaces: Annotated[Optional[List[str]], Field(alias="excludedNamespaces")] = None
    """
    ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
    """
    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources specifies the resources to which this hook spec does not apply.
    """
    included_namespaces: Annotated[Optional[List[str]], Field(alias="includedNamespaces")] = None
    """
    IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
    to all namespaces.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
    to all resources.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector, if specified, filters the resources to which this hook spec applies.
    """
    name: str
    """
    Name is the name of this hook.
    """
    post: Optional[List[Post]] = None
    """
    PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup.
    These are executed after all "additional items" from item actions are processed.
    """
    pre: Optional[List[Pre]] = None
    """
    PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup.
    These are executed before any "additional items" from item actions are processed.
    """


class Hooks(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Hooks"]:
            return Hooks

        def build(self) -> "Hooks":
            return Hooks(**self._attrs)

        @overload
        def resources(self, value_or_callback: List[ResourceModel], /) -> "Hooks.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "Hooks.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Resources are hooks that should be executed when backing up individual instances of a resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

    class BuilderContext(BuilderContextBase["Hooks.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Hooks.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Hooks."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Hooks", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Hooks.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resources: Optional[List[ResourceModel]] = None
    """
    Resources are hooks that should be executed when backing up individual instances of a resource.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("labels", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    labels: Optional[Dict[str, str]] = None


class OrLabelSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OrLabelSelector"]:
            return OrLabelSelector

        def build(self) -> "OrLabelSelector":
            return OrLabelSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "OrLabelSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "OrLabelSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["OrLabelSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OrLabelSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OrLabelSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OrLabelSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OrLabelSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ResourcePolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourcePolicy"]:
            return ResourcePolicy

        def build(self) -> "ResourcePolicy":
            return ResourcePolicy(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced.
            If APIGroup is not specified, the specified Kind must be in the core API group.
            For any other third-party types, APIGroup is required.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ResourcePolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourcePolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourcePolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourcePolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourcePolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced.
    If APIGroup is not specified, the specified Kind must be in the core API group.
    For any other third-party types, APIGroup is required.
    """
    kind: str
    """
    Kind is the type of resource being referenced
    """
    name: str
    """
    Name is the name of resource being referenced
    """


class UploaderConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UploaderConfig"]:
            return UploaderConfig

        def build(self) -> "UploaderConfig":
            return UploaderConfig(**self._attrs)

        def parallel_files_upload(self, value: Optional[int], /) -> Self:
            """
            ParallelFilesUpload is the number of files parallel uploads to perform when using the uploader.
            """
            return self._set("parallel_files_upload", value)

    class BuilderContext(BuilderContextBase["UploaderConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UploaderConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UploaderConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UploaderConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UploaderConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    parallel_files_upload: Annotated[Optional[int], Field(alias="parallelFilesUpload")] = None
    """
    ParallelFilesUpload is the number of files parallel uploads to perform when using the uploader.
    """


class BackupSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupSpec"]:
            return BackupSpec

        def build(self) -> "BackupSpec":
            return BackupSpec(**self._attrs)

        def csi_snapshot_timeout(self, value: Optional[str], /) -> Self:
            """
            CSISnapshotTimeout specifies the time used to wait for CSI VolumeSnapshot status turns to
            ReadyToUse during creation, before returning error as timeout.
            The default value is 10 minute.
            """
            return self._set("csi_snapshot_timeout", value)

        def datamover(self, value: Optional[str], /) -> Self:
            """
            DataMover specifies the data mover to be used by the backup.
            If DataMover is "" or "velero", the built-in data mover will be used.
            """
            return self._set("datamover", value)

        def default_volumes_to_fs_backup(self, value: Optional[bool], /) -> Self:
            """
            DefaultVolumesToFsBackup specifies whether pod volume file system backup should be used
            for all volumes by default.
            """
            return self._set("default_volumes_to_fs_backup", value)

        def default_volumes_to_restic(self, value: Optional[bool], /) -> Self:
            """
            DefaultVolumesToRestic specifies whether restic should be used to take a
            backup of all pod volumes by default.


            Deprecated: this field is no longer used and will be removed entirely in future. Use DefaultVolumesToFsBackup instead.
            """
            return self._set("default_volumes_to_restic", value)

        def excluded_cluster_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedClusterScopedResources is a slice of cluster-scoped
            resource type names to exclude from the backup.
            If set to "*", all cluster-scoped resource types are excluded.
            The default value is empty.
            """
            return self._set("excluded_cluster_scoped_resources", value)

        def excluded_namespace_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaceScopedResources is a slice of namespace-scoped
            resource type names to exclude from the backup.
            If set to "*", all namespace-scoped resource types are excluded.
            The default value is empty.
            """
            return self._set("excluded_namespace_scoped_resources", value)

        def excluded_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaces contains a list of namespaces that are not
            included in the backup.
            """
            return self._set("excluded_namespaces", value)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources is a slice of resource names that are not
            included in the backup.
            """
            return self._set("excluded_resources", value)

        @overload
        def hooks(self, value_or_callback: Optional[Hooks], /) -> "BackupSpec.Builder": ...

        @overload
        def hooks(
            self, value_or_callback: Callable[[Hooks.Builder], Hooks.Builder | Hooks], /
        ) -> "BackupSpec.Builder": ...

        @overload
        def hooks(self, value_or_callback: Never = ...) -> "Hooks.BuilderContext": ...

        def hooks(self, value_or_callback=None, /):
            """
            Hooks represent custom behaviors that should be executed at different phases of the backup.
            """
            if self._in_context and value_or_callback is None:
                context = Hooks.BuilderContext()
                context._parent_builder = self
                context._field_name = "hooks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Hooks.builder())
                if isinstance(output, Hooks.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("hooks", value)

        def include_cluster_resources(self, value: Optional[bool], /) -> Self:
            """
            IncludeClusterResources specifies whether cluster-scoped resources
            should be included for consideration in the backup.
            """
            return self._set("include_cluster_resources", value)

        def included_cluster_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedClusterScopedResources is a slice of cluster-scoped
            resource type names to include in the backup.
            If set to "*", all cluster-scoped resource types are included.
            The default value is empty, which means only related
            cluster-scoped resources are included.
            """
            return self._set("included_cluster_scoped_resources", value)

        def included_namespace_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaceScopedResources is a slice of namespace-scoped
            resource type names to include in the backup.
            The default value is "*".
            """
            return self._set("included_namespace_scoped_resources", value)

        def included_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaces is a slice of namespace names to include objects
            from. If empty, all namespaces are included.
            """
            return self._set("included_namespaces", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources is a slice of resource names to include
            in the backup. If empty, all resources are included.
            """
            return self._set("included_resources", value)

        def item_operation_timeout(self, value: Optional[str], /) -> Self:
            """
            ItemOperationTimeout specifies the time used to wait for asynchronous BackupItemAction operations
            The default value is 4 hour.
            """
            return self._set("item_operation_timeout", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "BackupSpec.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "BackupSpec.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is a metav1.LabelSelector to filter with
            when adding individual objects to the backup. If empty
            or nil, all objects are included. Optional.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        @overload
        def metadata(self, value_or_callback: Optional[Metadata], /) -> "BackupSpec.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "BackupSpec.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def or_label_selectors(
            self, value_or_callback: List[OrLabelSelector], /
        ) -> "BackupSpec.Builder": ...

        @overload
        def or_label_selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OrLabelSelector, OrLabelSelector.Builder]],
                GenericListBuilder[OrLabelSelector, OrLabelSelector.Builder]
                | List[OrLabelSelector],
            ],
            /,
        ) -> "BackupSpec.Builder": ...

        @overload
        def or_label_selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OrLabelSelector.Builder]: ...

        def or_label_selectors(self, value_or_callback=None, /):
            """
            OrLabelSelectors is list of metav1.LabelSelector to filter with
            when adding individual objects to the backup. If multiple provided
            they will be joined by the OR operator. LabelSelector as well as
            OrLabelSelectors cannot co-exist in backup request, only one of them
            can be used.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OrLabelSelector.Builder]()
                context._parent_builder = self
                context._field_name = "or_label_selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OrLabelSelector.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("or_label_selectors", value)

        def ordered_resources(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            OrderedResources specifies the backup order of resources of specific Kind.
            The map key is the resource name and value is a list of object names separated by commas.
            Each resource name has format "namespace/objectname".  For cluster resources, simply use "objectname".
            """
            return self._set("ordered_resources", value)

        @overload
        def resource_policy(
            self, value_or_callback: Optional[ResourcePolicy], /
        ) -> "BackupSpec.Builder": ...

        @overload
        def resource_policy(
            self,
            value_or_callback: Callable[
                [ResourcePolicy.Builder], ResourcePolicy.Builder | ResourcePolicy
            ],
            /,
        ) -> "BackupSpec.Builder": ...

        @overload
        def resource_policy(
            self, value_or_callback: Never = ...
        ) -> "ResourcePolicy.BuilderContext": ...

        def resource_policy(self, value_or_callback=None, /):
            """
            ResourcePolicy specifies the referenced resource policies that backup should follow
            """
            if self._in_context and value_or_callback is None:
                context = ResourcePolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcePolicy.builder())
                if isinstance(output, ResourcePolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_policy", value)

        def snapshot_move_data(self, value: Optional[bool], /) -> Self:
            """
            SnapshotMoveData specifies whether snapshot data should be moved
            """
            return self._set("snapshot_move_data", value)

        def snapshot_volumes(self, value: Optional[bool], /) -> Self:
            """
            SnapshotVolumes specifies whether to take snapshots
            of any PV's referenced in the set of objects included
            in the Backup.
            """
            return self._set("snapshot_volumes", value)

        def storage_location(self, value: Optional[str], /) -> Self:
            """
            StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
            """
            return self._set("storage_location", value)

        def ttl(self, value: Optional[str], /) -> Self:
            """
            TTL is a time.Duration-parseable string describing how long
            the Backup should be retained for.
            """
            return self._set("ttl", value)

        @overload
        def uploader_config(
            self, value_or_callback: Optional[UploaderConfig], /
        ) -> "BackupSpec.Builder": ...

        @overload
        def uploader_config(
            self,
            value_or_callback: Callable[
                [UploaderConfig.Builder], UploaderConfig.Builder | UploaderConfig
            ],
            /,
        ) -> "BackupSpec.Builder": ...

        @overload
        def uploader_config(
            self, value_or_callback: Never = ...
        ) -> "UploaderConfig.BuilderContext": ...

        def uploader_config(self, value_or_callback=None, /):
            """
            UploaderConfig specifies the configuration for the uploader.
            """
            if self._in_context and value_or_callback is None:
                context = UploaderConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "uploader_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UploaderConfig.builder())
                if isinstance(output, UploaderConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("uploader_config", value)

        def volume_snapshot_locations(self, value: Optional[List[str]], /) -> Self:
            """
            VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
            """
            return self._set("volume_snapshot_locations", value)

    class BuilderContext(BuilderContextBase["BackupSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    csi_snapshot_timeout: Annotated[Optional[str], Field(alias="csiSnapshotTimeout")] = None
    """
    CSISnapshotTimeout specifies the time used to wait for CSI VolumeSnapshot status turns to
    ReadyToUse during creation, before returning error as timeout.
    The default value is 10 minute.
    """
    datamover: Optional[str] = None
    """
    DataMover specifies the data mover to be used by the backup.
    If DataMover is "" or "velero", the built-in data mover will be used.
    """
    default_volumes_to_fs_backup: Annotated[
        Optional[bool], Field(alias="defaultVolumesToFsBackup")
    ] = None
    """
    DefaultVolumesToFsBackup specifies whether pod volume file system backup should be used
    for all volumes by default.
    """
    default_volumes_to_restic: Annotated[Optional[bool], Field(alias="defaultVolumesToRestic")] = (
        None
    )
    """
    DefaultVolumesToRestic specifies whether restic should be used to take a
    backup of all pod volumes by default.


    Deprecated: this field is no longer used and will be removed entirely in future. Use DefaultVolumesToFsBackup instead.
    """
    excluded_cluster_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="excludedClusterScopedResources")
    ] = None
    """
    ExcludedClusterScopedResources is a slice of cluster-scoped
    resource type names to exclude from the backup.
    If set to "*", all cluster-scoped resource types are excluded.
    The default value is empty.
    """
    excluded_namespace_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="excludedNamespaceScopedResources")
    ] = None
    """
    ExcludedNamespaceScopedResources is a slice of namespace-scoped
    resource type names to exclude from the backup.
    If set to "*", all namespace-scoped resource types are excluded.
    The default value is empty.
    """
    excluded_namespaces: Annotated[Optional[List[str]], Field(alias="excludedNamespaces")] = None
    """
    ExcludedNamespaces contains a list of namespaces that are not
    included in the backup.
    """
    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources is a slice of resource names that are not
    included in the backup.
    """
    hooks: Optional[Hooks] = None
    """
    Hooks represent custom behaviors that should be executed at different phases of the backup.
    """
    include_cluster_resources: Annotated[Optional[bool], Field(alias="includeClusterResources")] = (
        None
    )
    """
    IncludeClusterResources specifies whether cluster-scoped resources
    should be included for consideration in the backup.
    """
    included_cluster_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="includedClusterScopedResources")
    ] = None
    """
    IncludedClusterScopedResources is a slice of cluster-scoped
    resource type names to include in the backup.
    If set to "*", all cluster-scoped resource types are included.
    The default value is empty, which means only related
    cluster-scoped resources are included.
    """
    included_namespace_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="includedNamespaceScopedResources")
    ] = None
    """
    IncludedNamespaceScopedResources is a slice of namespace-scoped
    resource type names to include in the backup.
    The default value is "*".
    """
    included_namespaces: Annotated[Optional[List[str]], Field(alias="includedNamespaces")] = None
    """
    IncludedNamespaces is a slice of namespace names to include objects
    from. If empty, all namespaces are included.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources is a slice of resource names to include
    in the backup. If empty, all resources are included.
    """
    item_operation_timeout: Annotated[Optional[str], Field(alias="itemOperationTimeout")] = None
    """
    ItemOperationTimeout specifies the time used to wait for asynchronous BackupItemAction operations
    The default value is 4 hour.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is a metav1.LabelSelector to filter with
    when adding individual objects to the backup. If empty
    or nil, all objects are included. Optional.
    """
    metadata: Optional[Metadata] = None
    or_label_selectors: Annotated[
        Optional[List[OrLabelSelector]], Field(alias="orLabelSelectors")
    ] = None
    """
    OrLabelSelectors is list of metav1.LabelSelector to filter with
    when adding individual objects to the backup. If multiple provided
    they will be joined by the OR operator. LabelSelector as well as
    OrLabelSelectors cannot co-exist in backup request, only one of them
    can be used.
    """
    ordered_resources: Annotated[Optional[Dict[str, str]], Field(alias="orderedResources")] = None
    """
    OrderedResources specifies the backup order of resources of specific Kind.
    The map key is the resource name and value is a list of object names separated by commas.
    Each resource name has format "namespace/objectname".  For cluster resources, simply use "objectname".
    """
    resource_policy: Annotated[Optional[ResourcePolicy], Field(alias="resourcePolicy")] = None
    """
    ResourcePolicy specifies the referenced resource policies that backup should follow
    """
    snapshot_move_data: Annotated[Optional[bool], Field(alias="snapshotMoveData")] = None
    """
    SnapshotMoveData specifies whether snapshot data should be moved
    """
    snapshot_volumes: Annotated[Optional[bool], Field(alias="snapshotVolumes")] = None
    """
    SnapshotVolumes specifies whether to take snapshots
    of any PV's referenced in the set of objects included
    in the Backup.
    """
    storage_location: Annotated[Optional[str], Field(alias="storageLocation")] = None
    """
    StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
    """
    ttl: Optional[str] = None
    """
    TTL is a time.Duration-parseable string describing how long
    the Backup should be retained for.
    """
    uploader_config: Annotated[Optional[UploaderConfig], Field(alias="uploaderConfig")] = None
    """
    UploaderConfig specifies the configuration for the uploader.
    """
    volume_snapshot_locations: Annotated[
        Optional[List[str]], Field(alias="volumeSnapshotLocations")
    ] = None
    """
    VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
    """


class HookStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HookStatus"]:
            return HookStatus

        def build(self) -> "HookStatus":
            return HookStatus(**self._attrs)

        def hooks_attempted(self, value: Optional[int], /) -> Self:
            """
            HooksAttempted is the total number of attempted hooks
            Specifically, HooksAttempted represents the number of hooks that failed to execute
            and the number of hooks that executed successfully.
            """
            return self._set("hooks_attempted", value)

        def hooks_failed(self, value: Optional[int], /) -> Self:
            """
            HooksFailed is the total number of hooks which ended with an error
            """
            return self._set("hooks_failed", value)

    class BuilderContext(BuilderContextBase["HookStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HookStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HookStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HookStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HookStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    hooks_attempted: Annotated[Optional[int], Field(alias="hooksAttempted")] = None
    """
    HooksAttempted is the total number of attempted hooks
    Specifically, HooksAttempted represents the number of hooks that failed to execute
    and the number of hooks that executed successfully.
    """
    hooks_failed: Annotated[Optional[int], Field(alias="hooksFailed")] = None
    """
    HooksFailed is the total number of hooks which ended with an error
    """


class Progress(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Progress"]:
            return Progress

        def build(self) -> "Progress":
            return Progress(**self._attrs)

        def items_backed_up(self, value: Optional[int], /) -> Self:
            """
            ItemsBackedUp is the number of items that have actually been written to the
            backup tarball so far.
            """
            return self._set("items_backed_up", value)

        def total_items(self, value: Optional[int], /) -> Self:
            """
            TotalItems is the total number of items to be backed up. This number may change
            throughout the execution of the backup due to plugins that return additional related
            items to back up, the velero.io/exclude-from-backup label, and various other
            filters that happen as items are processed.
            """
            return self._set("total_items", value)

    class BuilderContext(BuilderContextBase["Progress.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Progress.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Progress."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Progress", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Progress.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items_backed_up: Annotated[Optional[int], Field(alias="itemsBackedUp")] = None
    """
    ItemsBackedUp is the number of items that have actually been written to the
    backup tarball so far.
    """
    total_items: Annotated[Optional[int], Field(alias="totalItems")] = None
    """
    TotalItems is the total number of items to be backed up. This number may change
    throughout the execution of the backup due to plugins that return additional related
    items to back up, the velero.io/exclude-from-backup label, and various other
    filters that happen as items are processed.
    """


class BackupStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupStatus"]:
            return BackupStatus

        def build(self) -> "BackupStatus":
            return BackupStatus(**self._attrs)

        def backup_item_operations_attempted(self, value: Optional[int], /) -> Self:
            """
            BackupItemOperationsAttempted is the total number of attempted
            async BackupItemAction operations for this backup.
            """
            return self._set("backup_item_operations_attempted", value)

        def backup_item_operations_completed(self, value: Optional[int], /) -> Self:
            """
            BackupItemOperationsCompleted is the total number of successfully completed
            async BackupItemAction operations for this backup.
            """
            return self._set("backup_item_operations_completed", value)

        def backup_item_operations_failed(self, value: Optional[int], /) -> Self:
            """
            BackupItemOperationsFailed is the total number of async
            BackupItemAction operations for this backup which ended with an error.
            """
            return self._set("backup_item_operations_failed", value)

        def completion_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            CompletionTimestamp records the time a backup was completed.
            Completion time is recorded even on failed backups.
            Completion time is recorded before uploading the backup object.
            The server's time is used for CompletionTimestamps
            """
            return self._set("completion_timestamp", value)

        def csi_volume_snapshots_attempted(self, value: Optional[int], /) -> Self:
            """
            CSIVolumeSnapshotsAttempted is the total number of attempted
            CSI VolumeSnapshots for this backup.
            """
            return self._set("csi_volume_snapshots_attempted", value)

        def csi_volume_snapshots_completed(self, value: Optional[int], /) -> Self:
            """
            CSIVolumeSnapshotsCompleted is the total number of successfully
            completed CSI VolumeSnapshots for this backup.
            """
            return self._set("csi_volume_snapshots_completed", value)

        def errors(self, value: Optional[int], /) -> Self:
            """
            Errors is a count of all error messages that were generated during
            execution of the backup.  The actual errors are in the backup's log
            file in object storage.
            """
            return self._set("errors", value)

        def expiration(self, value: Optional[datetime], /) -> Self:
            """
            Expiration is when this Backup is eligible for garbage-collection.
            """
            return self._set("expiration", value)

        def failure_reason(self, value: Optional[str], /) -> Self:
            """
            FailureReason is an error that caused the entire backup to fail.
            """
            return self._set("failure_reason", value)

        def format_version(self, value: Optional[str], /) -> Self:
            """
            FormatVersion is the backup format version, including major, minor, and patch version.
            """
            return self._set("format_version", value)

        @overload
        def hook_status(
            self, value_or_callback: Optional[HookStatus], /
        ) -> "BackupStatus.Builder": ...

        @overload
        def hook_status(
            self,
            value_or_callback: Callable[[HookStatus.Builder], HookStatus.Builder | HookStatus],
            /,
        ) -> "BackupStatus.Builder": ...

        @overload
        def hook_status(self, value_or_callback: Never = ...) -> "HookStatus.BuilderContext": ...

        def hook_status(self, value_or_callback=None, /):
            """
            HookStatus contains information about the status of the hooks.
            """
            if self._in_context and value_or_callback is None:
                context = HookStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "hook_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HookStatus.builder())
                if isinstance(output, HookStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("hook_status", value)

        def phase(
            self,
            value: Optional[
                Literal[
                    "New",
                    "FailedValidation",
                    "InProgress",
                    "WaitingForPluginOperations",
                    "WaitingForPluginOperationsPartiallyFailed",
                    "Finalizing",
                    "FinalizingPartiallyFailed",
                    "Completed",
                    "PartiallyFailed",
                    "Failed",
                    "Deleting",
                ]
            ],
            /,
        ) -> Self:
            """
            Phase is the current state of the Backup.
            """
            return self._set("phase", value)

        @overload
        def progress(self, value_or_callback: Optional[Progress], /) -> "BackupStatus.Builder": ...

        @overload
        def progress(
            self,
            value_or_callback: Callable[[Progress.Builder], Progress.Builder | Progress],
            /,
        ) -> "BackupStatus.Builder": ...

        @overload
        def progress(self, value_or_callback: Never = ...) -> "Progress.BuilderContext": ...

        def progress(self, value_or_callback=None, /):
            """
            Progress contains information about the backup's execution progress. Note
            that this information is best-effort only -- if Velero fails to update it
            during a backup for any reason, it may be inaccurate/stale.
            """
            if self._in_context and value_or_callback is None:
                context = Progress.BuilderContext()
                context._parent_builder = self
                context._field_name = "progress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Progress.builder())
                if isinstance(output, Progress.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("progress", value)

        def start_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            StartTimestamp records the time a backup was started.
            Separate from CreationTimestamp, since that value changes
            on restores.
            The server's time is used for StartTimestamps
            """
            return self._set("start_timestamp", value)

        def validation_errors(self, value: Optional[List[str]], /) -> Self:
            """
            ValidationErrors is a slice of all validation errors (if
            applicable).
            """
            return self._set("validation_errors", value)

        def version(self, value: Optional[int], /) -> Self:
            """
            Version is the backup format major version.
            Deprecated: Please see FormatVersion
            """
            return self._set("version", value)

        def volume_snapshots_attempted(self, value: Optional[int], /) -> Self:
            """
            VolumeSnapshotsAttempted is the total number of attempted
            volume snapshots for this backup.
            """
            return self._set("volume_snapshots_attempted", value)

        def volume_snapshots_completed(self, value: Optional[int], /) -> Self:
            """
            VolumeSnapshotsCompleted is the total number of successfully
            completed volume snapshots for this backup.
            """
            return self._set("volume_snapshots_completed", value)

        def warnings(self, value: Optional[int], /) -> Self:
            """
            Warnings is a count of all warning messages that were generated during
            execution of the backup. The actual warnings are in the backup's log
            file in object storage.
            """
            return self._set("warnings", value)

    class BuilderContext(BuilderContextBase["BackupStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_item_operations_attempted: Annotated[
        Optional[int], Field(alias="backupItemOperationsAttempted")
    ] = None
    """
    BackupItemOperationsAttempted is the total number of attempted
    async BackupItemAction operations for this backup.
    """
    backup_item_operations_completed: Annotated[
        Optional[int], Field(alias="backupItemOperationsCompleted")
    ] = None
    """
    BackupItemOperationsCompleted is the total number of successfully completed
    async BackupItemAction operations for this backup.
    """
    backup_item_operations_failed: Annotated[
        Optional[int], Field(alias="backupItemOperationsFailed")
    ] = None
    """
    BackupItemOperationsFailed is the total number of async
    BackupItemAction operations for this backup which ended with an error.
    """
    completion_timestamp: Annotated[Optional[datetime], Field(alias="completionTimestamp")] = None
    """
    CompletionTimestamp records the time a backup was completed.
    Completion time is recorded even on failed backups.
    Completion time is recorded before uploading the backup object.
    The server's time is used for CompletionTimestamps
    """
    csi_volume_snapshots_attempted: Annotated[
        Optional[int], Field(alias="csiVolumeSnapshotsAttempted")
    ] = None
    """
    CSIVolumeSnapshotsAttempted is the total number of attempted
    CSI VolumeSnapshots for this backup.
    """
    csi_volume_snapshots_completed: Annotated[
        Optional[int], Field(alias="csiVolumeSnapshotsCompleted")
    ] = None
    """
    CSIVolumeSnapshotsCompleted is the total number of successfully
    completed CSI VolumeSnapshots for this backup.
    """
    errors: Optional[int] = None
    """
    Errors is a count of all error messages that were generated during
    execution of the backup.  The actual errors are in the backup's log
    file in object storage.
    """
    expiration: Optional[datetime] = None
    """
    Expiration is when this Backup is eligible for garbage-collection.
    """
    failure_reason: Annotated[Optional[str], Field(alias="failureReason")] = None
    """
    FailureReason is an error that caused the entire backup to fail.
    """
    format_version: Annotated[Optional[str], Field(alias="formatVersion")] = None
    """
    FormatVersion is the backup format version, including major, minor, and patch version.
    """
    hook_status: Annotated[Optional[HookStatus], Field(alias="hookStatus")] = None
    """
    HookStatus contains information about the status of the hooks.
    """
    phase: Optional[
        Literal[
            "New",
            "FailedValidation",
            "InProgress",
            "WaitingForPluginOperations",
            "WaitingForPluginOperationsPartiallyFailed",
            "Finalizing",
            "FinalizingPartiallyFailed",
            "Completed",
            "PartiallyFailed",
            "Failed",
            "Deleting",
        ]
    ] = None
    """
    Phase is the current state of the Backup.
    """
    progress: Optional[Progress] = None
    """
    Progress contains information about the backup's execution progress. Note
    that this information is best-effort only -- if Velero fails to update it
    during a backup for any reason, it may be inaccurate/stale.
    """
    start_timestamp: Annotated[Optional[datetime], Field(alias="startTimestamp")] = None
    """
    StartTimestamp records the time a backup was started.
    Separate from CreationTimestamp, since that value changes
    on restores.
    The server's time is used for StartTimestamps
    """
    validation_errors: Annotated[Optional[List[str]], Field(alias="validationErrors")] = None
    """
    ValidationErrors is a slice of all validation errors (if
    applicable).
    """
    version: Optional[int] = None
    """
    Version is the backup format major version.
    Deprecated: Please see FormatVersion
    """
    volume_snapshots_attempted: Annotated[
        Optional[int], Field(alias="volumeSnapshotsAttempted")
    ] = None
    """
    VolumeSnapshotsAttempted is the total number of attempted
    volume snapshots for this backup.
    """
    volume_snapshots_completed: Annotated[
        Optional[int], Field(alias="volumeSnapshotsCompleted")
    ] = None
    """
    VolumeSnapshotsCompleted is the total number of successfully
    completed volume snapshots for this backup.
    """
    warnings: Optional[int] = None
    """
    Warnings is a count of all warning messages that were generated during
    execution of the backup. The actual warnings are in the backup's log
    file in object storage.
    """


class Credential(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Credential"]:
            return Credential

        def build(self) -> "Credential":
            return Credential(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            TODO: Add other useful fields. apiVersion, kind, uid?
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Credential.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Credential.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Credential."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Credential", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Credential.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = None
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    TODO: Add other useful fields. apiVersion, kind, uid?
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ObjectStorage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ObjectStorage"]:
            return ObjectStorage

        def build(self) -> "ObjectStorage":
            return ObjectStorage(**self._attrs)

        def bucket(self, value: str, /) -> Self:
            """
            Bucket is the bucket to use for object storage.
            """
            return self._set("bucket", value)

        def ca_cert(self, value: Optional[str], /) -> Self:
            """
            CACert defines a CA bundle to use when verifying TLS connections to the provider.
            """
            return self._set("ca_cert", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix is the path inside a bucket to use for Velero storage. Optional.
            """
            return self._set("prefix", value)

    class BuilderContext(BuilderContextBase["ObjectStorage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ObjectStorage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ObjectStorage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ObjectStorage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObjectStorage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bucket: str
    """
    Bucket is the bucket to use for object storage.
    """
    ca_cert: Annotated[Optional[str], Field(alias="caCert")] = None
    """
    CACert defines a CA bundle to use when verifying TLS connections to the provider.
    """
    prefix: Optional[str] = None
    """
    Prefix is the path inside a bucket to use for Velero storage. Optional.
    """


class BackupStorageLocationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupStorageLocationSpec"]:
            return BackupStorageLocationSpec

        def build(self) -> "BackupStorageLocationSpec":
            return BackupStorageLocationSpec(**self._attrs)

        def access_mode(self, value: Optional[Literal["ReadOnly", "ReadWrite"]], /) -> Self:
            """
            AccessMode defines the permissions for the backup storage location.
            """
            return self._set("access_mode", value)

        def backup_sync_period(self, value: Optional[str], /) -> Self:
            """
            BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
            """
            return self._set("backup_sync_period", value)

        def config(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Config is for provider-specific configuration fields.
            """
            return self._set("config", value)

        @overload
        def credential(
            self, value_or_callback: Optional[Credential], /
        ) -> "BackupStorageLocationSpec.Builder": ...

        @overload
        def credential(
            self,
            value_or_callback: Callable[[Credential.Builder], Credential.Builder | Credential],
            /,
        ) -> "BackupStorageLocationSpec.Builder": ...

        @overload
        def credential(self, value_or_callback: Never = ...) -> "Credential.BuilderContext": ...

        def credential(self, value_or_callback=None, /):
            """
            Credential contains the credential information intended to be used with this location
            """
            if self._in_context and value_or_callback is None:
                context = Credential.BuilderContext()
                context._parent_builder = self
                context._field_name = "credential"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credential.builder())
                if isinstance(output, Credential.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credential", value)

        def default(self, value: Optional[bool], /) -> Self:
            """
            Default indicates this location is the default backup storage location.
            """
            return self._set("default", value)

        @overload
        def object_storage(
            self, value_or_callback: ObjectStorage, /
        ) -> "BackupStorageLocationSpec.Builder": ...

        @overload
        def object_storage(
            self,
            value_or_callback: Callable[
                [ObjectStorage.Builder], ObjectStorage.Builder | ObjectStorage
            ],
            /,
        ) -> "BackupStorageLocationSpec.Builder": ...

        @overload
        def object_storage(
            self, value_or_callback: Never = ...
        ) -> "ObjectStorage.BuilderContext": ...

        def object_storage(self, value_or_callback=None, /):
            """
            ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
            """
            if self._in_context and value_or_callback is None:
                context = ObjectStorage.BuilderContext()
                context._parent_builder = self
                context._field_name = "object_storage"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectStorage.builder())
                if isinstance(output, ObjectStorage.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_storage", value)

        def provider(self, value: str, /) -> Self:
            """
            Provider is the provider of the backup storage.
            """
            return self._set("provider", value)

        def validation_frequency(self, value: Optional[str], /) -> Self:
            """
            ValidationFrequency defines how frequently to validate the corresponding object storage. A value of 0 disables validation.
            """
            return self._set("validation_frequency", value)

    class BuilderContext(BuilderContextBase["BackupStorageLocationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupStorageLocationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupStorageLocationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupStorageLocationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupStorageLocationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_mode: Annotated[
        Optional[Literal["ReadOnly", "ReadWrite"]], Field(alias="accessMode")
    ] = None
    """
    AccessMode defines the permissions for the backup storage location.
    """
    backup_sync_period: Annotated[Optional[str], Field(alias="backupSyncPeriod")] = None
    """
    BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
    """
    config: Optional[Dict[str, str]] = None
    """
    Config is for provider-specific configuration fields.
    """
    credential: Optional[Credential] = None
    """
    Credential contains the credential information intended to be used with this location
    """
    default: Optional[bool] = None
    """
    Default indicates this location is the default backup storage location.
    """
    object_storage: Annotated[ObjectStorage, Field(alias="objectStorage")]
    """
    ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
    """
    provider: str
    """
    Provider is the provider of the backup storage.
    """
    validation_frequency: Annotated[Optional[str], Field(alias="validationFrequency")] = None
    """
    ValidationFrequency defines how frequently to validate the corresponding object storage. A value of 0 disables validation.
    """


class BackupStorageLocationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupStorageLocationStatus"]:
            return BackupStorageLocationStatus

        def build(self) -> "BackupStorageLocationStatus":
            return BackupStorageLocationStatus(**self._attrs)

        def access_mode(self, value: Optional[Literal["ReadOnly", "ReadWrite"]], /) -> Self:
            """
            AccessMode is an unused field.


            Deprecated: there is now an AccessMode field on the Spec and this field
            will be removed entirely as of v2.0.
            """
            return self._set("access_mode", value)

        def last_synced_revision(self, value: Optional[str], /) -> Self:
            """
            LastSyncedRevision is the value of the `metadata/revision` file in the backup
            storage location the last time the BSL's contents were synced into the cluster.


            Deprecated: this field is no longer updated or used for detecting changes to
            the location's contents and will be removed entirely in v2.0.
            """
            return self._set("last_synced_revision", value)

        def last_synced_time(self, value: Optional[datetime], /) -> Self:
            """
            LastSyncedTime is the last time the contents of the location were synced into
            the cluster.
            """
            return self._set("last_synced_time", value)

        def last_validation_time(self, value: Optional[datetime], /) -> Self:
            """
            LastValidationTime is the last time the backup store location was validated
            the cluster.
            """
            return self._set("last_validation_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is a message about the backup storage location's status.
            """
            return self._set("message", value)

        def phase(self, value: Optional[Literal["Available", "Unavailable"]], /) -> Self:
            """
            Phase is the current state of the BackupStorageLocation.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["BackupStorageLocationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupStorageLocationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupStorageLocationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupStorageLocationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupStorageLocationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_mode: Annotated[
        Optional[Literal["ReadOnly", "ReadWrite"]], Field(alias="accessMode")
    ] = None
    """
    AccessMode is an unused field.


    Deprecated: there is now an AccessMode field on the Spec and this field
    will be removed entirely as of v2.0.
    """
    last_synced_revision: Annotated[Optional[str], Field(alias="lastSyncedRevision")] = None
    """
    LastSyncedRevision is the value of the `metadata/revision` file in the backup
    storage location the last time the BSL's contents were synced into the cluster.


    Deprecated: this field is no longer updated or used for detecting changes to
    the location's contents and will be removed entirely in v2.0.
    """
    last_synced_time: Annotated[Optional[datetime], Field(alias="lastSyncedTime")] = None
    """
    LastSyncedTime is the last time the contents of the location were synced into
    the cluster.
    """
    last_validation_time: Annotated[Optional[datetime], Field(alias="lastValidationTime")] = None
    """
    LastValidationTime is the last time the backup store location was validated
    the cluster.
    """
    message: Optional[str] = None
    """
    Message is a message about the backup storage location's status.
    """
    phase: Optional[Literal["Available", "Unavailable"]] = None
    """
    Phase is the current state of the BackupStorageLocation.
    """


class DeleteBackupRequestSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeleteBackupRequestSpec"]:
            return DeleteBackupRequestSpec

        def build(self) -> "DeleteBackupRequestSpec":
            return DeleteBackupRequestSpec(**self._attrs)

        def backup_name(self, value: str, /) -> Self:
            return self._set("backup_name", value)

    class BuilderContext(BuilderContextBase["DeleteBackupRequestSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeleteBackupRequestSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeleteBackupRequestSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeleteBackupRequestSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeleteBackupRequestSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_name: Annotated[str, Field(alias="backupName")]


class DeleteBackupRequestStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeleteBackupRequestStatus"]:
            return DeleteBackupRequestStatus

        def build(self) -> "DeleteBackupRequestStatus":
            return DeleteBackupRequestStatus(**self._attrs)

        def errors(self, value: Optional[List[str]], /) -> Self:
            """
            Errors contains any errors that were encountered during the deletion process.
            """
            return self._set("errors", value)

        def phase(self, value: Optional[Literal["New", "InProgress", "Processed"]], /) -> Self:
            """
            Phase is the current state of the DeleteBackupRequest.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["DeleteBackupRequestStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeleteBackupRequestStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeleteBackupRequestStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeleteBackupRequestStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeleteBackupRequestStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    errors: Optional[List[str]] = None
    """
    Errors contains any errors that were encountered during the deletion process.
    """
    phase: Optional[Literal["New", "InProgress", "Processed"]] = None
    """
    Phase is the current state of the DeleteBackupRequest.
    """


class Target(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Target"]:
            return Target

        def build(self) -> "Target":
            return Target(**self._attrs)

        def kind(
            self,
            value: Literal[
                "BackupLog",
                "BackupContents",
                "BackupVolumeSnapshots",
                "BackupItemOperations",
                "BackupResourceList",
                "BackupResults",
                "RestoreLog",
                "RestoreResults",
                "RestoreResourceList",
                "RestoreItemOperations",
                "CSIBackupVolumeSnapshots",
                "CSIBackupVolumeSnapshotContents",
                "BackupVolumeInfos",
                "RestoreVolumeInfo",
            ],
            /,
        ) -> Self:
            """
            Kind is the type of file to download.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the Kubernetes resource with which the file is associated.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Target.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Target.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Target."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Target", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Target.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Literal[
        "BackupLog",
        "BackupContents",
        "BackupVolumeSnapshots",
        "BackupItemOperations",
        "BackupResourceList",
        "BackupResults",
        "RestoreLog",
        "RestoreResults",
        "RestoreResourceList",
        "RestoreItemOperations",
        "CSIBackupVolumeSnapshots",
        "CSIBackupVolumeSnapshotContents",
        "BackupVolumeInfos",
        "RestoreVolumeInfo",
    ]
    """
    Kind is the type of file to download.
    """
    name: str
    """
    Name is the name of the Kubernetes resource with which the file is associated.
    """


class DownloadRequestSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownloadRequestSpec"]:
            return DownloadRequestSpec

        def build(self) -> "DownloadRequestSpec":
            return DownloadRequestSpec(**self._attrs)

        @overload
        def target(self, value_or_callback: Target, /) -> "DownloadRequestSpec.Builder": ...

        @overload
        def target(
            self,
            value_or_callback: Callable[[Target.Builder], Target.Builder | Target],
            /,
        ) -> "DownloadRequestSpec.Builder": ...

        @overload
        def target(self, value_or_callback: Never = ...) -> "Target.BuilderContext": ...

        def target(self, value_or_callback=None, /):
            """
            Target is what to download (e.g. logs for a backup).
            """
            if self._in_context and value_or_callback is None:
                context = Target.BuilderContext()
                context._parent_builder = self
                context._field_name = "target"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Target.builder())
                if isinstance(output, Target.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target", value)

    class BuilderContext(BuilderContextBase["DownloadRequestSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownloadRequestSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownloadRequestSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownloadRequestSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownloadRequestSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    target: Target
    """
    Target is what to download (e.g. logs for a backup).
    """


class DownloadRequestStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownloadRequestStatus"]:
            return DownloadRequestStatus

        def build(self) -> "DownloadRequestStatus":
            return DownloadRequestStatus(**self._attrs)

        def download_url(self, value: Optional[str], /) -> Self:
            """
            DownloadURL contains the pre-signed URL for the target file.
            """
            return self._set("download_url", value)

        def expiration(self, value: Optional[datetime], /) -> Self:
            """
            Expiration is when this DownloadRequest expires and can be deleted by the system.
            """
            return self._set("expiration", value)

        def phase(self, value: Optional[Literal["New", "Processed"]], /) -> Self:
            """
            Phase is the current state of the DownloadRequest.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["DownloadRequestStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownloadRequestStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownloadRequestStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownloadRequestStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownloadRequestStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    download_url: Annotated[Optional[str], Field(alias="downloadURL")] = None
    """
    DownloadURL contains the pre-signed URL for the target file.
    """
    expiration: Optional[datetime] = None
    """
    Expiration is when this DownloadRequest expires and can be deleted by the system.
    """
    phase: Optional[Literal["New", "Processed"]] = None
    """
    Phase is the current state of the DownloadRequest.
    """


class Pod(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Pod"]:
            return Pod

        def build(self) -> "Pod":
            return Pod(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string
            should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
            For example, if the object reference is to a container within a pod, this would take on a value like:
            "spec.containers{name}" (where "name" refers to the name of the container that triggered
            the event) or if no container name is specified "spec.containers[2]" (container with
            index 2 in this pod). This syntax is chosen only to have some well-defined way of
            referencing a part of an object.
            TODO: this design is not final and this field is subject to change in the future.
            """
            return self._set("field_path", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Pod.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Pod.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Pod."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Pod", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Pod.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string
    should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    For example, if the object reference is to a container within a pod, this would take on a value like:
    "spec.containers{name}" (where "name" refers to the name of the container that triggered
    the event) or if no container name is specified "spec.containers[2]" (container with
    index 2 in this pod). This syntax is chosen only to have some well-defined way of
    referencing a part of an object.
    TODO: this design is not final and this field is subject to change in the future.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """


class PodVolumeBackupSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodVolumeBackupSpec"]:
            return PodVolumeBackupSpec

        def build(self) -> "PodVolumeBackupSpec":
            return PodVolumeBackupSpec(**self._attrs)

        def backup_storage_location(self, value: str, /) -> Self:
            """
            BackupStorageLocation is the name of the backup storage location
            where the backup repository is stored.
            """
            return self._set("backup_storage_location", value)

        def node(self, value: str, /) -> Self:
            """
            Node is the name of the node that the Pod is running on.
            """
            return self._set("node", value)

        @overload
        def pod(self, value_or_callback: Pod, /) -> "PodVolumeBackupSpec.Builder": ...

        @overload
        def pod(
            self, value_or_callback: Callable[[Pod.Builder], Pod.Builder | Pod], /
        ) -> "PodVolumeBackupSpec.Builder": ...

        @overload
        def pod(self, value_or_callback: Never = ...) -> "Pod.BuilderContext": ...

        def pod(self, value_or_callback=None, /):
            """
            Pod is a reference to the pod containing the volume to be backed up.
            """
            if self._in_context and value_or_callback is None:
                context = Pod.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pod.builder())
                if isinstance(output, Pod.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod", value)

        def repo_identifier(self, value: str, /) -> Self:
            """
            RepoIdentifier is the backup repository identifier.
            """
            return self._set("repo_identifier", value)

        def tags(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Tags are a map of key-value pairs that should be applied to the
            volume backup as tags.
            """
            return self._set("tags", value)

        def uploader_settings(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            UploaderSettings are a map of key-value pairs that should be applied to the
            uploader configuration.
            """
            return self._set("uploader_settings", value)

        def uploader_type(self, value: Optional[Literal["kopia", "restic", ""]], /) -> Self:
            """
            UploaderType is the type of the uploader to handle the data transfer.
            """
            return self._set("uploader_type", value)

        def volume(self, value: str, /) -> Self:
            """
            Volume is the name of the volume within the Pod to be backed
            up.
            """
            return self._set("volume", value)

    class BuilderContext(BuilderContextBase["PodVolumeBackupSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodVolumeBackupSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodVolumeBackupSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodVolumeBackupSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodVolumeBackupSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_storage_location: Annotated[str, Field(alias="backupStorageLocation")]
    """
    BackupStorageLocation is the name of the backup storage location
    where the backup repository is stored.
    """
    node: str
    """
    Node is the name of the node that the Pod is running on.
    """
    pod: Pod
    """
    Pod is a reference to the pod containing the volume to be backed up.
    """
    repo_identifier: Annotated[str, Field(alias="repoIdentifier")]
    """
    RepoIdentifier is the backup repository identifier.
    """
    tags: Optional[Dict[str, str]] = None
    """
    Tags are a map of key-value pairs that should be applied to the
    volume backup as tags.
    """
    uploader_settings: Annotated[Optional[Dict[str, str]], Field(alias="uploaderSettings")] = None
    """
    UploaderSettings are a map of key-value pairs that should be applied to the
    uploader configuration.
    """
    uploader_type: Annotated[
        Optional[Literal["kopia", "restic", ""]], Field(alias="uploaderType")
    ] = None
    """
    UploaderType is the type of the uploader to handle the data transfer.
    """
    volume: str
    """
    Volume is the name of the volume within the Pod to be backed
    up.
    """


class ProgressModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProgressModel"]:
            return ProgressModel

        def build(self) -> "ProgressModel":
            return ProgressModel(**self._attrs)

        def bytes_done(self, value: Optional[int], /) -> Self:
            return self._set("bytes_done", value)

        def total_bytes(self, value: Optional[int], /) -> Self:
            return self._set("total_bytes", value)

    class BuilderContext(BuilderContextBase["ProgressModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProgressModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProgressModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProgressModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProgressModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bytes_done: Annotated[Optional[int], Field(alias="bytesDone")] = None
    total_bytes: Annotated[Optional[int], Field(alias="totalBytes")] = None


class PodVolumeBackupStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodVolumeBackupStatus"]:
            return PodVolumeBackupStatus

        def build(self) -> "PodVolumeBackupStatus":
            return PodVolumeBackupStatus(**self._attrs)

        def completion_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            CompletionTimestamp records the time a backup was completed.
            Completion time is recorded even on failed backups.
            Completion time is recorded before uploading the backup object.
            The server's time is used for CompletionTimestamps
            """
            return self._set("completion_timestamp", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is a message about the pod volume backup's status.
            """
            return self._set("message", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path is the full path within the controller pod being backed up.
            """
            return self._set("path", value)

        def phase(
            self,
            value: Optional[Literal["New", "InProgress", "Completed", "Failed"]],
            /,
        ) -> Self:
            """
            Phase is the current state of the PodVolumeBackup.
            """
            return self._set("phase", value)

        @overload
        def progress(
            self, value_or_callback: Optional[ProgressModel], /
        ) -> "PodVolumeBackupStatus.Builder": ...

        @overload
        def progress(
            self,
            value_or_callback: Callable[
                [ProgressModel.Builder], ProgressModel.Builder | ProgressModel
            ],
            /,
        ) -> "PodVolumeBackupStatus.Builder": ...

        @overload
        def progress(self, value_or_callback: Never = ...) -> "ProgressModel.BuilderContext": ...

        def progress(self, value_or_callback=None, /):
            """
            Progress holds the total number of bytes of the volume and the current
            number of backed up bytes. This can be used to display progress information
            about the backup operation.
            """
            if self._in_context and value_or_callback is None:
                context = ProgressModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "progress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProgressModel.builder())
                if isinstance(output, ProgressModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("progress", value)

        def snapshot_id(self, value: Optional[str], /) -> Self:
            """
            SnapshotID is the identifier for the snapshot of the pod volume.
            """
            return self._set("snapshot_id", value)

        def start_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            StartTimestamp records the time a backup was started.
            Separate from CreationTimestamp, since that value changes
            on restores.
            The server's time is used for StartTimestamps
            """
            return self._set("start_timestamp", value)

    class BuilderContext(BuilderContextBase["PodVolumeBackupStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodVolumeBackupStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodVolumeBackupStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodVolumeBackupStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodVolumeBackupStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    completion_timestamp: Annotated[Optional[datetime], Field(alias="completionTimestamp")] = None
    """
    CompletionTimestamp records the time a backup was completed.
    Completion time is recorded even on failed backups.
    Completion time is recorded before uploading the backup object.
    The server's time is used for CompletionTimestamps
    """
    message: Optional[str] = None
    """
    Message is a message about the pod volume backup's status.
    """
    path: Optional[str] = None
    """
    Path is the full path within the controller pod being backed up.
    """
    phase: Optional[Literal["New", "InProgress", "Completed", "Failed"]] = None
    """
    Phase is the current state of the PodVolumeBackup.
    """
    progress: Optional[ProgressModel] = None
    """
    Progress holds the total number of bytes of the volume and the current
    number of backed up bytes. This can be used to display progress information
    about the backup operation.
    """
    snapshot_id: Annotated[Optional[str], Field(alias="snapshotID")] = None
    """
    SnapshotID is the identifier for the snapshot of the pod volume.
    """
    start_timestamp: Annotated[Optional[datetime], Field(alias="startTimestamp")] = None
    """
    StartTimestamp records the time a backup was started.
    Separate from CreationTimestamp, since that value changes
    on restores.
    The server's time is used for StartTimestamps
    """


class PodVolumeRestoreSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodVolumeRestoreSpec"]:
            return PodVolumeRestoreSpec

        def build(self) -> "PodVolumeRestoreSpec":
            return PodVolumeRestoreSpec(**self._attrs)

        def backup_storage_location(self, value: str, /) -> Self:
            """
            BackupStorageLocation is the name of the backup storage location
            where the backup repository is stored.
            """
            return self._set("backup_storage_location", value)

        @overload
        def pod(self, value_or_callback: Pod, /) -> "PodVolumeRestoreSpec.Builder": ...

        @overload
        def pod(
            self, value_or_callback: Callable[[Pod.Builder], Pod.Builder | Pod], /
        ) -> "PodVolumeRestoreSpec.Builder": ...

        @overload
        def pod(self, value_or_callback: Never = ...) -> "Pod.BuilderContext": ...

        def pod(self, value_or_callback=None, /):
            """
            Pod is a reference to the pod containing the volume to be restored.
            """
            if self._in_context and value_or_callback is None:
                context = Pod.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pod.builder())
                if isinstance(output, Pod.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod", value)

        def repo_identifier(self, value: str, /) -> Self:
            """
            RepoIdentifier is the backup repository identifier.
            """
            return self._set("repo_identifier", value)

        def snapshot_id(self, value: str, /) -> Self:
            """
            SnapshotID is the ID of the volume snapshot to be restored.
            """
            return self._set("snapshot_id", value)

        def source_namespace(self, value: str, /) -> Self:
            """
            SourceNamespace is the original namespace for namaspace mapping.
            """
            return self._set("source_namespace", value)

        def uploader_settings(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            UploaderSettings are a map of key-value pairs that should be applied to the
            uploader configuration.
            """
            return self._set("uploader_settings", value)

        def uploader_type(self, value: Optional[Literal["kopia", "restic", ""]], /) -> Self:
            """
            UploaderType is the type of the uploader to handle the data transfer.
            """
            return self._set("uploader_type", value)

        def volume(self, value: str, /) -> Self:
            """
            Volume is the name of the volume within the Pod to be restored.
            """
            return self._set("volume", value)

    class BuilderContext(BuilderContextBase["PodVolumeRestoreSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodVolumeRestoreSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodVolumeRestoreSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodVolumeRestoreSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodVolumeRestoreSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_storage_location: Annotated[str, Field(alias="backupStorageLocation")]
    """
    BackupStorageLocation is the name of the backup storage location
    where the backup repository is stored.
    """
    pod: Pod
    """
    Pod is a reference to the pod containing the volume to be restored.
    """
    repo_identifier: Annotated[str, Field(alias="repoIdentifier")]
    """
    RepoIdentifier is the backup repository identifier.
    """
    snapshot_id: Annotated[str, Field(alias="snapshotID")]
    """
    SnapshotID is the ID of the volume snapshot to be restored.
    """
    source_namespace: Annotated[str, Field(alias="sourceNamespace")]
    """
    SourceNamespace is the original namespace for namaspace mapping.
    """
    uploader_settings: Annotated[Optional[Dict[str, str]], Field(alias="uploaderSettings")] = None
    """
    UploaderSettings are a map of key-value pairs that should be applied to the
    uploader configuration.
    """
    uploader_type: Annotated[
        Optional[Literal["kopia", "restic", ""]], Field(alias="uploaderType")
    ] = None
    """
    UploaderType is the type of the uploader to handle the data transfer.
    """
    volume: str
    """
    Volume is the name of the volume within the Pod to be restored.
    """


class PodVolumeRestoreStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodVolumeRestoreStatus"]:
            return PodVolumeRestoreStatus

        def build(self) -> "PodVolumeRestoreStatus":
            return PodVolumeRestoreStatus(**self._attrs)

        def completion_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            CompletionTimestamp records the time a restore was completed.
            Completion time is recorded even on failed restores.
            The server's time is used for CompletionTimestamps
            """
            return self._set("completion_timestamp", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is a message about the pod volume restore's status.
            """
            return self._set("message", value)

        def phase(
            self,
            value: Optional[Literal["New", "InProgress", "Completed", "Failed"]],
            /,
        ) -> Self:
            """
            Phase is the current state of the PodVolumeRestore.
            """
            return self._set("phase", value)

        @overload
        def progress(
            self, value_or_callback: Optional[ProgressModel], /
        ) -> "PodVolumeRestoreStatus.Builder": ...

        @overload
        def progress(
            self,
            value_or_callback: Callable[
                [ProgressModel.Builder], ProgressModel.Builder | ProgressModel
            ],
            /,
        ) -> "PodVolumeRestoreStatus.Builder": ...

        @overload
        def progress(self, value_or_callback: Never = ...) -> "ProgressModel.BuilderContext": ...

        def progress(self, value_or_callback=None, /):
            """
            Progress holds the total number of bytes of the snapshot and the current
            number of restored bytes. This can be used to display progress information
            about the restore operation.
            """
            if self._in_context and value_or_callback is None:
                context = ProgressModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "progress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProgressModel.builder())
                if isinstance(output, ProgressModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("progress", value)

        def start_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            StartTimestamp records the time a restore was started.
            The server's time is used for StartTimestamps
            """
            return self._set("start_timestamp", value)

    class BuilderContext(BuilderContextBase["PodVolumeRestoreStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodVolumeRestoreStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodVolumeRestoreStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodVolumeRestoreStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodVolumeRestoreStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    completion_timestamp: Annotated[Optional[datetime], Field(alias="completionTimestamp")] = None
    """
    CompletionTimestamp records the time a restore was completed.
    Completion time is recorded even on failed restores.
    The server's time is used for CompletionTimestamps
    """
    message: Optional[str] = None
    """
    Message is a message about the pod volume restore's status.
    """
    phase: Optional[Literal["New", "InProgress", "Completed", "Failed"]] = None
    """
    Phase is the current state of the PodVolumeRestore.
    """
    progress: Optional[ProgressModel] = None
    """
    Progress holds the total number of bytes of the snapshot and the current
    number of restored bytes. This can be used to display progress information
    about the restore operation.
    """
    start_timestamp: Annotated[Optional[datetime], Field(alias="startTimestamp")] = None
    """
    StartTimestamp records the time a restore was started.
    The server's time is used for StartTimestamps
    """


class ExecModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExecModel"]:
            return ExecModel

        def build(self) -> "ExecModel":
            return ExecModel(**self._attrs)

        def command(self, value: List[str], /) -> Self:
            """
            Command is the command and arguments to execute from within a container after a pod has been restored.
            """
            return self._set("command", value)

        def container(self, value: Optional[str], /) -> Self:
            """
            Container is the container in the pod where the command should be executed. If not specified,
            the pod's first container is used.
            """
            return self._set("container", value)

        def exec_timeout(self, value: Optional[str], /) -> Self:
            """
            ExecTimeout defines the maximum amount of time Velero should wait for the hook to complete before
            considering the execution a failure.
            """
            return self._set("exec_timeout", value)

        def on_error(self, value: Optional[Literal["Continue", "Fail"]], /) -> Self:
            """
            OnError specifies how Velero should behave if it encounters an error executing this hook.
            """
            return self._set("on_error", value)

        def wait_for_ready(self, value: Optional[bool], /) -> Self:
            """
            WaitForReady ensures command will be launched when container is Ready instead of Running.
            """
            return self._set("wait_for_ready", value)

        def wait_timeout(self, value: Optional[str], /) -> Self:
            """
            WaitTimeout defines the maximum amount of time Velero should wait for the container to be Ready
            before attempting to run the command.
            """
            return self._set("wait_timeout", value)

    class BuilderContext(BuilderContextBase["ExecModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExecModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExecModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExecModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExecModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: Annotated[List[str], Field(min_length=1)]
    """
    Command is the command and arguments to execute from within a container after a pod has been restored.
    """
    container: Optional[str] = None
    """
    Container is the container in the pod where the command should be executed. If not specified,
    the pod's first container is used.
    """
    exec_timeout: Annotated[Optional[str], Field(alias="execTimeout")] = None
    """
    ExecTimeout defines the maximum amount of time Velero should wait for the hook to complete before
    considering the execution a failure.
    """
    on_error: Annotated[Optional[Literal["Continue", "Fail"]], Field(alias="onError")] = None
    """
    OnError specifies how Velero should behave if it encounters an error executing this hook.
    """
    wait_for_ready: Annotated[Optional[bool], Field(alias="waitForReady")] = None
    """
    WaitForReady ensures command will be launched when container is Ready instead of Running.
    """
    wait_timeout: Annotated[Optional[str], Field(alias="waitTimeout")] = None
    """
    WaitTimeout defines the maximum amount of time Velero should wait for the container to be Ready
    before attempting to run the command.
    """


class Init(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Init"]:
            return Init

        def build(self) -> "Init":
            return Init(**self._attrs)

        def init_containers(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            InitContainers is list of init containers to be added to a pod during its restore.
            """
            return self._set("init_containers", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout defines the maximum amount of time Velero should wait for the initContainers to complete.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["Init.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Init.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Init."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Init", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Init.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    init_containers: Annotated[Optional[List[Dict[str, Any]]], Field(alias="initContainers")] = None
    """
    InitContainers is list of init containers to be added to a pod during its restore.
    """
    timeout: Optional[str] = None
    """
    Timeout defines the maximum amount of time Velero should wait for the initContainers to complete.
    """


class PostHook(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PostHook"]:
            return PostHook

        def build(self) -> "PostHook":
            return PostHook(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[ExecModel], /) -> "PostHook.Builder": ...

        @overload
        def exec(
            self,
            value_or_callback: Callable[[ExecModel.Builder], ExecModel.Builder | ExecModel],
            /,
        ) -> "PostHook.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "ExecModel.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec defines an exec restore hook.
            """
            if self._in_context and value_or_callback is None:
                context = ExecModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExecModel.builder())
                if isinstance(output, ExecModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        @overload
        def init(self, value_or_callback: Optional[Init], /) -> "PostHook.Builder": ...

        @overload
        def init(
            self, value_or_callback: Callable[[Init.Builder], Init.Builder | Init], /
        ) -> "PostHook.Builder": ...

        @overload
        def init(self, value_or_callback: Never = ...) -> "Init.BuilderContext": ...

        def init(self, value_or_callback=None, /):
            """
            Init defines an init restore hook.
            """
            if self._in_context and value_or_callback is None:
                context = Init.BuilderContext()
                context._parent_builder = self
                context._field_name = "init"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Init.builder())
                if isinstance(output, Init.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("init", value)

    class BuilderContext(BuilderContextBase["PostHook.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PostHook.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PostHook."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PostHook", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PostHook.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[ExecModel] = None
    """
    Exec defines an exec restore hook.
    """
    init: Optional[Init] = None
    """
    Init defines an init restore hook.
    """


class ResourceModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel1"]:
            return ResourceModel1

        def build(self) -> "ResourceModel1":
            return ResourceModel1(**self._attrs)

        def excluded_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
            """
            return self._set("excluded_namespaces", value)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources specifies the resources to which this hook spec does not apply.
            """
            return self._set("excluded_resources", value)

        def included_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
            to all namespaces.
            """
            return self._set("included_namespaces", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
            to all resources.
            """
            return self._set("included_resources", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "ResourceModel1.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "ResourceModel1.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector, if specified, filters the resources to which this hook spec applies.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of this hook.
            """
            return self._set("name", value)

        @overload
        def post_hooks(self, value_or_callback: List[PostHook], /) -> "ResourceModel1.Builder": ...

        @overload
        def post_hooks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PostHook, PostHook.Builder]],
                GenericListBuilder[PostHook, PostHook.Builder] | List[PostHook],
            ],
            /,
        ) -> "ResourceModel1.Builder": ...

        @overload
        def post_hooks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PostHook.Builder]: ...

        def post_hooks(self, value_or_callback=None, /):
            """
            PostHooks is a list of RestoreResourceHooks to execute during and after restoring a resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PostHook.Builder]()
                context._parent_builder = self
                context._field_name = "post_hooks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PostHook.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("post_hooks", value)

    class BuilderContext(BuilderContextBase["ResourceModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    excluded_namespaces: Annotated[Optional[List[str]], Field(alias="excludedNamespaces")] = None
    """
    ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
    """
    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources specifies the resources to which this hook spec does not apply.
    """
    included_namespaces: Annotated[Optional[List[str]], Field(alias="includedNamespaces")] = None
    """
    IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
    to all namespaces.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
    to all resources.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector, if specified, filters the resources to which this hook spec applies.
    """
    name: str
    """
    Name is the name of this hook.
    """
    post_hooks: Annotated[Optional[List[PostHook]], Field(alias="postHooks")] = None
    """
    PostHooks is a list of RestoreResourceHooks to execute during and after restoring a resource.
    """


class HooksModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HooksModel"]:
            return HooksModel

        def build(self) -> "HooksModel":
            return HooksModel(**self._attrs)

        @overload
        def resources(self, value_or_callback: List[ResourceModel1], /) -> "HooksModel.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel1, ResourceModel1.Builder]],
                GenericListBuilder[ResourceModel1, ResourceModel1.Builder] | List[ResourceModel1],
            ],
            /,
        ) -> "HooksModel.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel1.Builder]: ...

        def resources(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel1.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

    class BuilderContext(BuilderContextBase["HooksModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HooksModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HooksModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HooksModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HooksModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resources: Optional[List[ResourceModel1]] = None


class ResourceModifier(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModifier"]:
            return ResourceModifier

        def build(self) -> "ResourceModifier":
            return ResourceModifier(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced.
            If APIGroup is not specified, the specified Kind must be in the core API group.
            For any other third-party types, APIGroup is required.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ResourceModifier.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModifier.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModifier."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModifier", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModifier.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced.
    If APIGroup is not specified, the specified Kind must be in the core API group.
    For any other third-party types, APIGroup is required.
    """
    kind: str
    """
    Kind is the type of resource being referenced
    """
    name: str
    """
    Name is the name of resource being referenced
    """


class RestoreStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RestoreStatus"]:
            return RestoreStatus

        def build(self) -> "RestoreStatus":
            return RestoreStatus(**self._attrs)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources specifies the resources to which will not restore the status.
            """
            return self._set("excluded_resources", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources specifies the resources to which will restore the status.
            If empty, it applies to all resources.
            """
            return self._set("included_resources", value)

    class BuilderContext(BuilderContextBase["RestoreStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RestoreStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RestoreStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RestoreStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RestoreStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources specifies the resources to which will not restore the status.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources specifies the resources to which will restore the status.
    If empty, it applies to all resources.
    """


class UploaderConfigModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UploaderConfigModel"]:
            return UploaderConfigModel

        def build(self) -> "UploaderConfigModel":
            return UploaderConfigModel(**self._attrs)

        def parallel_files_download(self, value: Optional[int], /) -> Self:
            """
            ParallelFilesDownload is the concurrency number setting for restore.
            """
            return self._set("parallel_files_download", value)

        def write_sparse_files(self, value: Optional[bool], /) -> Self:
            """
            WriteSparseFiles is a flag to indicate whether write files sparsely or not.
            """
            return self._set("write_sparse_files", value)

    class BuilderContext(BuilderContextBase["UploaderConfigModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UploaderConfigModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UploaderConfigModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UploaderConfigModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UploaderConfigModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    parallel_files_download: Annotated[Optional[int], Field(alias="parallelFilesDownload")] = None
    """
    ParallelFilesDownload is the concurrency number setting for restore.
    """
    write_sparse_files: Annotated[Optional[bool], Field(alias="writeSparseFiles")] = None
    """
    WriteSparseFiles is a flag to indicate whether write files sparsely or not.
    """


class RestoreSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RestoreSpec"]:
            return RestoreSpec

        def build(self) -> "RestoreSpec":
            return RestoreSpec(**self._attrs)

        def backup_name(self, value: Optional[str], /) -> Self:
            """
            BackupName is the unique name of the Velero backup to restore
            from.
            """
            return self._set("backup_name", value)

        def excluded_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaces contains a list of namespaces that are not
            included in the restore.
            """
            return self._set("excluded_namespaces", value)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources is a slice of resource names that are not
            included in the restore.
            """
            return self._set("excluded_resources", value)

        def existing_resource_policy(self, value: Optional[str], /) -> Self:
            """
            ExistingResourcePolicy specifies the restore behavior for the Kubernetes resource to be restored
            """
            return self._set("existing_resource_policy", value)

        @overload
        def hooks(self, value_or_callback: Optional[HooksModel], /) -> "RestoreSpec.Builder": ...

        @overload
        def hooks(
            self,
            value_or_callback: Callable[[HooksModel.Builder], HooksModel.Builder | HooksModel],
            /,
        ) -> "RestoreSpec.Builder": ...

        @overload
        def hooks(self, value_or_callback: Never = ...) -> "HooksModel.BuilderContext": ...

        def hooks(self, value_or_callback=None, /):
            """
            Hooks represent custom behaviors that should be executed during or post restore.
            """
            if self._in_context and value_or_callback is None:
                context = HooksModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "hooks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HooksModel.builder())
                if isinstance(output, HooksModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("hooks", value)

        def include_cluster_resources(self, value: Optional[bool], /) -> Self:
            """
            IncludeClusterResources specifies whether cluster-scoped resources
            should be included for consideration in the restore. If null, defaults
            to true.
            """
            return self._set("include_cluster_resources", value)

        def included_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaces is a slice of namespace names to include objects
            from. If empty, all namespaces are included.
            """
            return self._set("included_namespaces", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources is a slice of resource names to include
            in the restore. If empty, all resources in the backup are included.
            """
            return self._set("included_resources", value)

        def item_operation_timeout(self, value: Optional[str], /) -> Self:
            """
            ItemOperationTimeout specifies the time used to wait for RestoreItemAction operations
            The default value is 4 hour.
            """
            return self._set("item_operation_timeout", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "RestoreSpec.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "RestoreSpec.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is a metav1.LabelSelector to filter with
            when restoring individual objects from the backup. If empty
            or nil, all objects are included. Optional.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def namespace_mapping(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            NamespaceMapping is a map of source namespace names
            to target namespace names to restore into. Any source
            namespaces not included in the map will be restored into
            namespaces of the same name.
            """
            return self._set("namespace_mapping", value)

        @overload
        def or_label_selectors(
            self, value_or_callback: List[OrLabelSelector], /
        ) -> "RestoreSpec.Builder": ...

        @overload
        def or_label_selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OrLabelSelector, OrLabelSelector.Builder]],
                GenericListBuilder[OrLabelSelector, OrLabelSelector.Builder]
                | List[OrLabelSelector],
            ],
            /,
        ) -> "RestoreSpec.Builder": ...

        @overload
        def or_label_selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OrLabelSelector.Builder]: ...

        def or_label_selectors(self, value_or_callback=None, /):
            """
            OrLabelSelectors is list of metav1.LabelSelector to filter with
            when restoring individual objects from the backup. If multiple provided
            they will be joined by the OR operator. LabelSelector as well as
            OrLabelSelectors cannot co-exist in restore request, only one of them
            can be used
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OrLabelSelector.Builder]()
                context._parent_builder = self
                context._field_name = "or_label_selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OrLabelSelector.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("or_label_selectors", value)

        def preserve_node_ports(self, value: Optional[bool], /) -> Self:
            """
            PreserveNodePorts specifies whether to restore old nodePorts from backup.
            """
            return self._set("preserve_node_ports", value)

        @overload
        def resource_modifier(
            self, value_or_callback: Optional[ResourceModifier], /
        ) -> "RestoreSpec.Builder": ...

        @overload
        def resource_modifier(
            self,
            value_or_callback: Callable[
                [ResourceModifier.Builder], ResourceModifier.Builder | ResourceModifier
            ],
            /,
        ) -> "RestoreSpec.Builder": ...

        @overload
        def resource_modifier(
            self, value_or_callback: Never = ...
        ) -> "ResourceModifier.BuilderContext": ...

        def resource_modifier(self, value_or_callback=None, /):
            """
            ResourceModifier specifies the reference to JSON resource patches that should be applied to resources before restoration.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceModifier.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_modifier"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModifier.builder())
                if isinstance(output, ResourceModifier.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_modifier", value)

        def restore_p_vs(self, value: Optional[bool], /) -> Self:
            """
            RestorePVs specifies whether to restore all included
            PVs from snapshot
            """
            return self._set("restore_p_vs", value)

        @overload
        def restore_status(
            self, value_or_callback: Optional[RestoreStatus], /
        ) -> "RestoreSpec.Builder": ...

        @overload
        def restore_status(
            self,
            value_or_callback: Callable[
                [RestoreStatus.Builder], RestoreStatus.Builder | RestoreStatus
            ],
            /,
        ) -> "RestoreSpec.Builder": ...

        @overload
        def restore_status(
            self, value_or_callback: Never = ...
        ) -> "RestoreStatus.BuilderContext": ...

        def restore_status(self, value_or_callback=None, /):
            """
            RestoreStatus specifies which resources we should restore the status
            field. If nil, no objects are included. Optional.
            """
            if self._in_context and value_or_callback is None:
                context = RestoreStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "restore_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RestoreStatus.builder())
                if isinstance(output, RestoreStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("restore_status", value)

        def schedule_name(self, value: Optional[str], /) -> Self:
            """
            ScheduleName is the unique name of the Velero schedule to restore
            from. If specified, and BackupName is empty, Velero will restore
            from the most recent successful backup created from this schedule.
            """
            return self._set("schedule_name", value)

        @overload
        def uploader_config(
            self, value_or_callback: Optional[UploaderConfigModel], /
        ) -> "RestoreSpec.Builder": ...

        @overload
        def uploader_config(
            self,
            value_or_callback: Callable[
                [UploaderConfigModel.Builder],
                UploaderConfigModel.Builder | UploaderConfigModel,
            ],
            /,
        ) -> "RestoreSpec.Builder": ...

        @overload
        def uploader_config(
            self, value_or_callback: Never = ...
        ) -> "UploaderConfigModel.BuilderContext": ...

        def uploader_config(self, value_or_callback=None, /):
            """
            UploaderConfig specifies the configuration for the restore.
            """
            if self._in_context and value_or_callback is None:
                context = UploaderConfigModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "uploader_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UploaderConfigModel.builder())
                if isinstance(output, UploaderConfigModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("uploader_config", value)

    class BuilderContext(BuilderContextBase["RestoreSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RestoreSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RestoreSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RestoreSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RestoreSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_name: Annotated[Optional[str], Field(alias="backupName")] = None
    """
    BackupName is the unique name of the Velero backup to restore
    from.
    """
    excluded_namespaces: Annotated[Optional[List[str]], Field(alias="excludedNamespaces")] = None
    """
    ExcludedNamespaces contains a list of namespaces that are not
    included in the restore.
    """
    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources is a slice of resource names that are not
    included in the restore.
    """
    existing_resource_policy: Annotated[Optional[str], Field(alias="existingResourcePolicy")] = None
    """
    ExistingResourcePolicy specifies the restore behavior for the Kubernetes resource to be restored
    """
    hooks: Optional[HooksModel] = None
    """
    Hooks represent custom behaviors that should be executed during or post restore.
    """
    include_cluster_resources: Annotated[Optional[bool], Field(alias="includeClusterResources")] = (
        None
    )
    """
    IncludeClusterResources specifies whether cluster-scoped resources
    should be included for consideration in the restore. If null, defaults
    to true.
    """
    included_namespaces: Annotated[Optional[List[str]], Field(alias="includedNamespaces")] = None
    """
    IncludedNamespaces is a slice of namespace names to include objects
    from. If empty, all namespaces are included.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources is a slice of resource names to include
    in the restore. If empty, all resources in the backup are included.
    """
    item_operation_timeout: Annotated[Optional[str], Field(alias="itemOperationTimeout")] = None
    """
    ItemOperationTimeout specifies the time used to wait for RestoreItemAction operations
    The default value is 4 hour.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is a metav1.LabelSelector to filter with
    when restoring individual objects from the backup. If empty
    or nil, all objects are included. Optional.
    """
    namespace_mapping: Annotated[Optional[Dict[str, str]], Field(alias="namespaceMapping")] = None
    """
    NamespaceMapping is a map of source namespace names
    to target namespace names to restore into. Any source
    namespaces not included in the map will be restored into
    namespaces of the same name.
    """
    or_label_selectors: Annotated[
        Optional[List[OrLabelSelector]], Field(alias="orLabelSelectors")
    ] = None
    """
    OrLabelSelectors is list of metav1.LabelSelector to filter with
    when restoring individual objects from the backup. If multiple provided
    they will be joined by the OR operator. LabelSelector as well as
    OrLabelSelectors cannot co-exist in restore request, only one of them
    can be used
    """
    preserve_node_ports: Annotated[Optional[bool], Field(alias="preserveNodePorts")] = None
    """
    PreserveNodePorts specifies whether to restore old nodePorts from backup.
    """
    resource_modifier: Annotated[Optional[ResourceModifier], Field(alias="resourceModifier")] = None
    """
    ResourceModifier specifies the reference to JSON resource patches that should be applied to resources before restoration.
    """
    restore_p_vs: Annotated[Optional[bool], Field(alias="restorePVs")] = None
    """
    RestorePVs specifies whether to restore all included
    PVs from snapshot
    """
    restore_status: Annotated[Optional[RestoreStatus], Field(alias="restoreStatus")] = None
    """
    RestoreStatus specifies which resources we should restore the status
    field. If nil, no objects are included. Optional.
    """
    schedule_name: Annotated[Optional[str], Field(alias="scheduleName")] = None
    """
    ScheduleName is the unique name of the Velero schedule to restore
    from. If specified, and BackupName is empty, Velero will restore
    from the most recent successful backup created from this schedule.
    """
    uploader_config: Annotated[Optional[UploaderConfigModel], Field(alias="uploaderConfig")] = None
    """
    UploaderConfig specifies the configuration for the restore.
    """


class ProgressModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProgressModel1"]:
            return ProgressModel1

        def build(self) -> "ProgressModel1":
            return ProgressModel1(**self._attrs)

        def items_restored(self, value: Optional[int], /) -> Self:
            """
            ItemsRestored is the number of items that have actually been restored so far
            """
            return self._set("items_restored", value)

        def total_items(self, value: Optional[int], /) -> Self:
            """
            TotalItems is the total number of items to be restored. This number may change
            throughout the execution of the restore due to plugins that return additional related
            items to restore
            """
            return self._set("total_items", value)

    class BuilderContext(BuilderContextBase["ProgressModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProgressModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProgressModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProgressModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProgressModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items_restored: Annotated[Optional[int], Field(alias="itemsRestored")] = None
    """
    ItemsRestored is the number of items that have actually been restored so far
    """
    total_items: Annotated[Optional[int], Field(alias="totalItems")] = None
    """
    TotalItems is the total number of items to be restored. This number may change
    throughout the execution of the restore due to plugins that return additional related
    items to restore
    """


class RestoreStatusModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RestoreStatusModel"]:
            return RestoreStatusModel

        def build(self) -> "RestoreStatusModel":
            return RestoreStatusModel(**self._attrs)

        def completion_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            CompletionTimestamp records the time the restore operation was completed.
            Completion time is recorded even on failed restore.
            The server's time is used for StartTimestamps
            """
            return self._set("completion_timestamp", value)

        def errors(self, value: Optional[int], /) -> Self:
            """
            Errors is a count of all error messages that were generated during
            execution of the restore. The actual errors are stored in object storage.
            """
            return self._set("errors", value)

        def failure_reason(self, value: Optional[str], /) -> Self:
            """
            FailureReason is an error that caused the entire restore to fail.
            """
            return self._set("failure_reason", value)

        @overload
        def hook_status(
            self, value_or_callback: Optional[HookStatus], /
        ) -> "RestoreStatusModel.Builder": ...

        @overload
        def hook_status(
            self,
            value_or_callback: Callable[[HookStatus.Builder], HookStatus.Builder | HookStatus],
            /,
        ) -> "RestoreStatusModel.Builder": ...

        @overload
        def hook_status(self, value_or_callback: Never = ...) -> "HookStatus.BuilderContext": ...

        def hook_status(self, value_or_callback=None, /):
            """
            HookStatus contains information about the status of the hooks.
            """
            if self._in_context and value_or_callback is None:
                context = HookStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "hook_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HookStatus.builder())
                if isinstance(output, HookStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("hook_status", value)

        def phase(
            self,
            value: Optional[
                Literal[
                    "New",
                    "FailedValidation",
                    "InProgress",
                    "WaitingForPluginOperations",
                    "WaitingForPluginOperationsPartiallyFailed",
                    "Completed",
                    "PartiallyFailed",
                    "Failed",
                    "Finalizing",
                    "FinalizingPartiallyFailed",
                ]
            ],
            /,
        ) -> Self:
            """
            Phase is the current state of the Restore
            """
            return self._set("phase", value)

        @overload
        def progress(
            self, value_or_callback: Optional[ProgressModel1], /
        ) -> "RestoreStatusModel.Builder": ...

        @overload
        def progress(
            self,
            value_or_callback: Callable[
                [ProgressModel1.Builder], ProgressModel1.Builder | ProgressModel1
            ],
            /,
        ) -> "RestoreStatusModel.Builder": ...

        @overload
        def progress(self, value_or_callback: Never = ...) -> "ProgressModel1.BuilderContext": ...

        def progress(self, value_or_callback=None, /):
            """
            Progress contains information about the restore's execution progress. Note
            that this information is best-effort only -- if Velero fails to update it
            during a restore for any reason, it may be inaccurate/stale.
            """
            if self._in_context and value_or_callback is None:
                context = ProgressModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "progress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProgressModel1.builder())
                if isinstance(output, ProgressModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("progress", value)

        def restore_item_operations_attempted(self, value: Optional[int], /) -> Self:
            """
            RestoreItemOperationsAttempted is the total number of attempted
            async RestoreItemAction operations for this restore.
            """
            return self._set("restore_item_operations_attempted", value)

        def restore_item_operations_completed(self, value: Optional[int], /) -> Self:
            """
            RestoreItemOperationsCompleted is the total number of successfully completed
            async RestoreItemAction operations for this restore.
            """
            return self._set("restore_item_operations_completed", value)

        def restore_item_operations_failed(self, value: Optional[int], /) -> Self:
            """
            RestoreItemOperationsFailed is the total number of async
            RestoreItemAction operations for this restore which ended with an error.
            """
            return self._set("restore_item_operations_failed", value)

        def start_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            StartTimestamp records the time the restore operation was started.
            The server's time is used for StartTimestamps
            """
            return self._set("start_timestamp", value)

        def validation_errors(self, value: Optional[List[str]], /) -> Self:
            """
            ValidationErrors is a slice of all validation errors (if
            applicable)
            """
            return self._set("validation_errors", value)

        def warnings(self, value: Optional[int], /) -> Self:
            """
            Warnings is a count of all warning messages that were generated during
            execution of the restore. The actual warnings are stored in object storage.
            """
            return self._set("warnings", value)

    class BuilderContext(BuilderContextBase["RestoreStatusModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RestoreStatusModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RestoreStatusModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RestoreStatusModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RestoreStatusModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    completion_timestamp: Annotated[Optional[datetime], Field(alias="completionTimestamp")] = None
    """
    CompletionTimestamp records the time the restore operation was completed.
    Completion time is recorded even on failed restore.
    The server's time is used for StartTimestamps
    """
    errors: Optional[int] = None
    """
    Errors is a count of all error messages that were generated during
    execution of the restore. The actual errors are stored in object storage.
    """
    failure_reason: Annotated[Optional[str], Field(alias="failureReason")] = None
    """
    FailureReason is an error that caused the entire restore to fail.
    """
    hook_status: Annotated[Optional[HookStatus], Field(alias="hookStatus")] = None
    """
    HookStatus contains information about the status of the hooks.
    """
    phase: Optional[
        Literal[
            "New",
            "FailedValidation",
            "InProgress",
            "WaitingForPluginOperations",
            "WaitingForPluginOperationsPartiallyFailed",
            "Completed",
            "PartiallyFailed",
            "Failed",
            "Finalizing",
            "FinalizingPartiallyFailed",
        ]
    ] = None
    """
    Phase is the current state of the Restore
    """
    progress: Optional[ProgressModel1] = None
    """
    Progress contains information about the restore's execution progress. Note
    that this information is best-effort only -- if Velero fails to update it
    during a restore for any reason, it may be inaccurate/stale.
    """
    restore_item_operations_attempted: Annotated[
        Optional[int], Field(alias="restoreItemOperationsAttempted")
    ] = None
    """
    RestoreItemOperationsAttempted is the total number of attempted
    async RestoreItemAction operations for this restore.
    """
    restore_item_operations_completed: Annotated[
        Optional[int], Field(alias="restoreItemOperationsCompleted")
    ] = None
    """
    RestoreItemOperationsCompleted is the total number of successfully completed
    async RestoreItemAction operations for this restore.
    """
    restore_item_operations_failed: Annotated[
        Optional[int], Field(alias="restoreItemOperationsFailed")
    ] = None
    """
    RestoreItemOperationsFailed is the total number of async
    RestoreItemAction operations for this restore which ended with an error.
    """
    start_timestamp: Annotated[Optional[datetime], Field(alias="startTimestamp")] = None
    """
    StartTimestamp records the time the restore operation was started.
    The server's time is used for StartTimestamps
    """
    validation_errors: Annotated[Optional[List[str]], Field(alias="validationErrors")] = None
    """
    ValidationErrors is a slice of all validation errors (if
    applicable)
    """
    warnings: Optional[int] = None
    """
    Warnings is a count of all warning messages that were generated during
    execution of the restore. The actual warnings are stored in object storage.
    """


class ExecModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExecModel1"]:
            return ExecModel1

        def build(self) -> "ExecModel1":
            return ExecModel1(**self._attrs)

        def command(self, value: List[str], /) -> Self:
            """
            Command is the command and arguments to execute.
            """
            return self._set("command", value)

        def container(self, value: Optional[str], /) -> Self:
            """
            Container is the container in the pod where the command should be executed. If not specified,
            the pod's first container is used.
            """
            return self._set("container", value)

        def on_error(self, value: Optional[Literal["Continue", "Fail"]], /) -> Self:
            """
            OnError specifies how Velero should behave if it encounters an error executing this hook.
            """
            return self._set("on_error", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout defines the maximum amount of time Velero should wait for the hook to complete before
            considering the execution a failure.
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["ExecModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExecModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExecModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExecModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExecModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: Annotated[List[str], Field(min_length=1)]
    """
    Command is the command and arguments to execute.
    """
    container: Optional[str] = None
    """
    Container is the container in the pod where the command should be executed. If not specified,
    the pod's first container is used.
    """
    on_error: Annotated[Optional[Literal["Continue", "Fail"]], Field(alias="onError")] = None
    """
    OnError specifies how Velero should behave if it encounters an error executing this hook.
    """
    timeout: Optional[str] = None
    """
    Timeout defines the maximum amount of time Velero should wait for the hook to complete before
    considering the execution a failure.
    """


class ResourceModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel2"]:
            return ResourceModel2

        def build(self) -> "ResourceModel2":
            return ResourceModel2(**self._attrs)

        def excluded_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
            """
            return self._set("excluded_namespaces", value)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources specifies the resources to which this hook spec does not apply.
            """
            return self._set("excluded_resources", value)

        def included_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
            to all namespaces.
            """
            return self._set("included_namespaces", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
            to all resources.
            """
            return self._set("included_resources", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "ResourceModel2.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "ResourceModel2.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector, if specified, filters the resources to which this hook spec applies.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of this hook.
            """
            return self._set("name", value)

        @overload
        def post(self, value_or_callback: List[Post], /) -> "ResourceModel2.Builder": ...

        @overload
        def post(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Post, Post.Builder]],
                GenericListBuilder[Post, Post.Builder] | List[Post],
            ],
            /,
        ) -> "ResourceModel2.Builder": ...

        @overload
        def post(self, value_or_callback: Never = ...) -> ListBuilderContext[Post.Builder]: ...

        def post(self, value_or_callback=None, /):
            """
            PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup.
            These are executed after all "additional items" from item actions are processed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Post.Builder]()
                context._parent_builder = self
                context._field_name = "post"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Post.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("post", value)

        @overload
        def pre(self, value_or_callback: List[Pre], /) -> "ResourceModel2.Builder": ...

        @overload
        def pre(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pre, Pre.Builder]],
                GenericListBuilder[Pre, Pre.Builder] | List[Pre],
            ],
            /,
        ) -> "ResourceModel2.Builder": ...

        @overload
        def pre(self, value_or_callback: Never = ...) -> ListBuilderContext[Pre.Builder]: ...

        def pre(self, value_or_callback=None, /):
            """
            PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup.
            These are executed before any "additional items" from item actions are processed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pre.Builder]()
                context._parent_builder = self
                context._field_name = "pre"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pre.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pre", value)

    class BuilderContext(BuilderContextBase["ResourceModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    excluded_namespaces: Annotated[Optional[List[str]], Field(alias="excludedNamespaces")] = None
    """
    ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
    """
    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources specifies the resources to which this hook spec does not apply.
    """
    included_namespaces: Annotated[Optional[List[str]], Field(alias="includedNamespaces")] = None
    """
    IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies
    to all namespaces.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources specifies the resources to which this hook spec applies. If empty, it applies
    to all resources.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector, if specified, filters the resources to which this hook spec applies.
    """
    name: str
    """
    Name is the name of this hook.
    """
    post: Optional[List[Post]] = None
    """
    PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup.
    These are executed after all "additional items" from item actions are processed.
    """
    pre: Optional[List[Pre]] = None
    """
    PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup.
    These are executed before any "additional items" from item actions are processed.
    """


class HooksModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HooksModel1"]:
            return HooksModel1

        def build(self) -> "HooksModel1":
            return HooksModel1(**self._attrs)

        @overload
        def resources(
            self, value_or_callback: List[ResourceModel2], /
        ) -> "HooksModel1.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel2, ResourceModel2.Builder]],
                GenericListBuilder[ResourceModel2, ResourceModel2.Builder] | List[ResourceModel2],
            ],
            /,
        ) -> "HooksModel1.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel2.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Resources are hooks that should be executed when backing up individual instances of a resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel2.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

    class BuilderContext(BuilderContextBase["HooksModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HooksModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HooksModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HooksModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HooksModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resources: Optional[List[ResourceModel2]] = None
    """
    Resources are hooks that should be executed when backing up individual instances of a resource.
    """


class UploaderConfigModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UploaderConfigModel1"]:
            return UploaderConfigModel1

        def build(self) -> "UploaderConfigModel1":
            return UploaderConfigModel1(**self._attrs)

        def parallel_files_upload(self, value: Optional[int], /) -> Self:
            """
            ParallelFilesUpload is the number of files parallel uploads to perform when using the uploader.
            """
            return self._set("parallel_files_upload", value)

    class BuilderContext(BuilderContextBase["UploaderConfigModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UploaderConfigModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UploaderConfigModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UploaderConfigModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UploaderConfigModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    parallel_files_upload: Annotated[Optional[int], Field(alias="parallelFilesUpload")] = None
    """
    ParallelFilesUpload is the number of files parallel uploads to perform when using the uploader.
    """


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        def csi_snapshot_timeout(self, value: Optional[str], /) -> Self:
            """
            CSISnapshotTimeout specifies the time used to wait for CSI VolumeSnapshot status turns to
            ReadyToUse during creation, before returning error as timeout.
            The default value is 10 minute.
            """
            return self._set("csi_snapshot_timeout", value)

        def datamover(self, value: Optional[str], /) -> Self:
            """
            DataMover specifies the data mover to be used by the backup.
            If DataMover is "" or "velero", the built-in data mover will be used.
            """
            return self._set("datamover", value)

        def default_volumes_to_fs_backup(self, value: Optional[bool], /) -> Self:
            """
            DefaultVolumesToFsBackup specifies whether pod volume file system backup should be used
            for all volumes by default.
            """
            return self._set("default_volumes_to_fs_backup", value)

        def default_volumes_to_restic(self, value: Optional[bool], /) -> Self:
            """
            DefaultVolumesToRestic specifies whether restic should be used to take a
            backup of all pod volumes by default.


            Deprecated: this field is no longer used and will be removed entirely in future. Use DefaultVolumesToFsBackup instead.
            """
            return self._set("default_volumes_to_restic", value)

        def excluded_cluster_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedClusterScopedResources is a slice of cluster-scoped
            resource type names to exclude from the backup.
            If set to "*", all cluster-scoped resource types are excluded.
            The default value is empty.
            """
            return self._set("excluded_cluster_scoped_resources", value)

        def excluded_namespace_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaceScopedResources is a slice of namespace-scoped
            resource type names to exclude from the backup.
            If set to "*", all namespace-scoped resource types are excluded.
            The default value is empty.
            """
            return self._set("excluded_namespace_scoped_resources", value)

        def excluded_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedNamespaces contains a list of namespaces that are not
            included in the backup.
            """
            return self._set("excluded_namespaces", value)

        def excluded_resources(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedResources is a slice of resource names that are not
            included in the backup.
            """
            return self._set("excluded_resources", value)

        @overload
        def hooks(self, value_or_callback: Optional[HooksModel1], /) -> "Template.Builder": ...

        @overload
        def hooks(
            self,
            value_or_callback: Callable[[HooksModel1.Builder], HooksModel1.Builder | HooksModel1],
            /,
        ) -> "Template.Builder": ...

        @overload
        def hooks(self, value_or_callback: Never = ...) -> "HooksModel1.BuilderContext": ...

        def hooks(self, value_or_callback=None, /):
            """
            Hooks represent custom behaviors that should be executed at different phases of the backup.
            """
            if self._in_context and value_or_callback is None:
                context = HooksModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "hooks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HooksModel1.builder())
                if isinstance(output, HooksModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("hooks", value)

        def include_cluster_resources(self, value: Optional[bool], /) -> Self:
            """
            IncludeClusterResources specifies whether cluster-scoped resources
            should be included for consideration in the backup.
            """
            return self._set("include_cluster_resources", value)

        def included_cluster_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedClusterScopedResources is a slice of cluster-scoped
            resource type names to include in the backup.
            If set to "*", all cluster-scoped resource types are included.
            The default value is empty, which means only related
            cluster-scoped resources are included.
            """
            return self._set("included_cluster_scoped_resources", value)

        def included_namespace_scoped_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaceScopedResources is a slice of namespace-scoped
            resource type names to include in the backup.
            The default value is "*".
            """
            return self._set("included_namespace_scoped_resources", value)

        def included_namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedNamespaces is a slice of namespace names to include objects
            from. If empty, all namespaces are included.
            """
            return self._set("included_namespaces", value)

        def included_resources(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedResources is a slice of resource names to include
            in the backup. If empty, all resources are included.
            """
            return self._set("included_resources", value)

        def item_operation_timeout(self, value: Optional[str], /) -> Self:
            """
            ItemOperationTimeout specifies the time used to wait for asynchronous BackupItemAction operations
            The default value is 4 hour.
            """
            return self._set("item_operation_timeout", value)

        @overload
        def label_selector(
            self, value_or_callback: Optional[LabelSelector], /
        ) -> "Template.Builder": ...

        @overload
        def label_selector(
            self,
            value_or_callback: Callable[
                [LabelSelector.Builder], LabelSelector.Builder | LabelSelector
            ],
            /,
        ) -> "Template.Builder": ...

        @overload
        def label_selector(
            self, value_or_callback: Never = ...
        ) -> "LabelSelector.BuilderContext": ...

        def label_selector(self, value_or_callback=None, /):
            """
            LabelSelector is a metav1.LabelSelector to filter with
            when adding individual objects to the backup. If empty
            or nil, all objects are included. Optional.
            """
            if self._in_context and value_or_callback is None:
                context = LabelSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "label_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LabelSelector.builder())
                if isinstance(output, LabelSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("label_selector", value)

        @overload
        def metadata(self, value_or_callback: Optional[Metadata], /) -> "Template.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "Template.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def or_label_selectors(
            self, value_or_callback: List[OrLabelSelector], /
        ) -> "Template.Builder": ...

        @overload
        def or_label_selectors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[OrLabelSelector, OrLabelSelector.Builder]],
                GenericListBuilder[OrLabelSelector, OrLabelSelector.Builder]
                | List[OrLabelSelector],
            ],
            /,
        ) -> "Template.Builder": ...

        @overload
        def or_label_selectors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[OrLabelSelector.Builder]: ...

        def or_label_selectors(self, value_or_callback=None, /):
            """
            OrLabelSelectors is list of metav1.LabelSelector to filter with
            when adding individual objects to the backup. If multiple provided
            they will be joined by the OR operator. LabelSelector as well as
            OrLabelSelectors cannot co-exist in backup request, only one of them
            can be used.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[OrLabelSelector.Builder]()
                context._parent_builder = self
                context._field_name = "or_label_selectors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OrLabelSelector.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("or_label_selectors", value)

        def ordered_resources(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            OrderedResources specifies the backup order of resources of specific Kind.
            The map key is the resource name and value is a list of object names separated by commas.
            Each resource name has format "namespace/objectname".  For cluster resources, simply use "objectname".
            """
            return self._set("ordered_resources", value)

        @overload
        def resource_policy(
            self, value_or_callback: Optional[ResourcePolicy], /
        ) -> "Template.Builder": ...

        @overload
        def resource_policy(
            self,
            value_or_callback: Callable[
                [ResourcePolicy.Builder], ResourcePolicy.Builder | ResourcePolicy
            ],
            /,
        ) -> "Template.Builder": ...

        @overload
        def resource_policy(
            self, value_or_callback: Never = ...
        ) -> "ResourcePolicy.BuilderContext": ...

        def resource_policy(self, value_or_callback=None, /):
            """
            ResourcePolicy specifies the referenced resource policies that backup should follow
            """
            if self._in_context and value_or_callback is None:
                context = ResourcePolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourcePolicy.builder())
                if isinstance(output, ResourcePolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_policy", value)

        def snapshot_move_data(self, value: Optional[bool], /) -> Self:
            """
            SnapshotMoveData specifies whether snapshot data should be moved
            """
            return self._set("snapshot_move_data", value)

        def snapshot_volumes(self, value: Optional[bool], /) -> Self:
            """
            SnapshotVolumes specifies whether to take snapshots
            of any PV's referenced in the set of objects included
            in the Backup.
            """
            return self._set("snapshot_volumes", value)

        def storage_location(self, value: Optional[str], /) -> Self:
            """
            StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
            """
            return self._set("storage_location", value)

        def ttl(self, value: Optional[str], /) -> Self:
            """
            TTL is a time.Duration-parseable string describing how long
            the Backup should be retained for.
            """
            return self._set("ttl", value)

        @overload
        def uploader_config(
            self, value_or_callback: Optional[UploaderConfigModel1], /
        ) -> "Template.Builder": ...

        @overload
        def uploader_config(
            self,
            value_or_callback: Callable[
                [UploaderConfigModel1.Builder],
                UploaderConfigModel1.Builder | UploaderConfigModel1,
            ],
            /,
        ) -> "Template.Builder": ...

        @overload
        def uploader_config(
            self, value_or_callback: Never = ...
        ) -> "UploaderConfigModel1.BuilderContext": ...

        def uploader_config(self, value_or_callback=None, /):
            """
            UploaderConfig specifies the configuration for the uploader.
            """
            if self._in_context and value_or_callback is None:
                context = UploaderConfigModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "uploader_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UploaderConfigModel1.builder())
                if isinstance(output, UploaderConfigModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("uploader_config", value)

        def volume_snapshot_locations(self, value: Optional[List[str]], /) -> Self:
            """
            VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
            """
            return self._set("volume_snapshot_locations", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    csi_snapshot_timeout: Annotated[Optional[str], Field(alias="csiSnapshotTimeout")] = None
    """
    CSISnapshotTimeout specifies the time used to wait for CSI VolumeSnapshot status turns to
    ReadyToUse during creation, before returning error as timeout.
    The default value is 10 minute.
    """
    datamover: Optional[str] = None
    """
    DataMover specifies the data mover to be used by the backup.
    If DataMover is "" or "velero", the built-in data mover will be used.
    """
    default_volumes_to_fs_backup: Annotated[
        Optional[bool], Field(alias="defaultVolumesToFsBackup")
    ] = None
    """
    DefaultVolumesToFsBackup specifies whether pod volume file system backup should be used
    for all volumes by default.
    """
    default_volumes_to_restic: Annotated[Optional[bool], Field(alias="defaultVolumesToRestic")] = (
        None
    )
    """
    DefaultVolumesToRestic specifies whether restic should be used to take a
    backup of all pod volumes by default.


    Deprecated: this field is no longer used and will be removed entirely in future. Use DefaultVolumesToFsBackup instead.
    """
    excluded_cluster_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="excludedClusterScopedResources")
    ] = None
    """
    ExcludedClusterScopedResources is a slice of cluster-scoped
    resource type names to exclude from the backup.
    If set to "*", all cluster-scoped resource types are excluded.
    The default value is empty.
    """
    excluded_namespace_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="excludedNamespaceScopedResources")
    ] = None
    """
    ExcludedNamespaceScopedResources is a slice of namespace-scoped
    resource type names to exclude from the backup.
    If set to "*", all namespace-scoped resource types are excluded.
    The default value is empty.
    """
    excluded_namespaces: Annotated[Optional[List[str]], Field(alias="excludedNamespaces")] = None
    """
    ExcludedNamespaces contains a list of namespaces that are not
    included in the backup.
    """
    excluded_resources: Annotated[Optional[List[str]], Field(alias="excludedResources")] = None
    """
    ExcludedResources is a slice of resource names that are not
    included in the backup.
    """
    hooks: Optional[HooksModel1] = None
    """
    Hooks represent custom behaviors that should be executed at different phases of the backup.
    """
    include_cluster_resources: Annotated[Optional[bool], Field(alias="includeClusterResources")] = (
        None
    )
    """
    IncludeClusterResources specifies whether cluster-scoped resources
    should be included for consideration in the backup.
    """
    included_cluster_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="includedClusterScopedResources")
    ] = None
    """
    IncludedClusterScopedResources is a slice of cluster-scoped
    resource type names to include in the backup.
    If set to "*", all cluster-scoped resource types are included.
    The default value is empty, which means only related
    cluster-scoped resources are included.
    """
    included_namespace_scoped_resources: Annotated[
        Optional[List[str]], Field(alias="includedNamespaceScopedResources")
    ] = None
    """
    IncludedNamespaceScopedResources is a slice of namespace-scoped
    resource type names to include in the backup.
    The default value is "*".
    """
    included_namespaces: Annotated[Optional[List[str]], Field(alias="includedNamespaces")] = None
    """
    IncludedNamespaces is a slice of namespace names to include objects
    from. If empty, all namespaces are included.
    """
    included_resources: Annotated[Optional[List[str]], Field(alias="includedResources")] = None
    """
    IncludedResources is a slice of resource names to include
    in the backup. If empty, all resources are included.
    """
    item_operation_timeout: Annotated[Optional[str], Field(alias="itemOperationTimeout")] = None
    """
    ItemOperationTimeout specifies the time used to wait for asynchronous BackupItemAction operations
    The default value is 4 hour.
    """
    label_selector: Annotated[Optional[LabelSelector], Field(alias="labelSelector")] = None
    """
    LabelSelector is a metav1.LabelSelector to filter with
    when adding individual objects to the backup. If empty
    or nil, all objects are included. Optional.
    """
    metadata: Optional[Metadata] = None
    or_label_selectors: Annotated[
        Optional[List[OrLabelSelector]], Field(alias="orLabelSelectors")
    ] = None
    """
    OrLabelSelectors is list of metav1.LabelSelector to filter with
    when adding individual objects to the backup. If multiple provided
    they will be joined by the OR operator. LabelSelector as well as
    OrLabelSelectors cannot co-exist in backup request, only one of them
    can be used.
    """
    ordered_resources: Annotated[Optional[Dict[str, str]], Field(alias="orderedResources")] = None
    """
    OrderedResources specifies the backup order of resources of specific Kind.
    The map key is the resource name and value is a list of object names separated by commas.
    Each resource name has format "namespace/objectname".  For cluster resources, simply use "objectname".
    """
    resource_policy: Annotated[Optional[ResourcePolicy], Field(alias="resourcePolicy")] = None
    """
    ResourcePolicy specifies the referenced resource policies that backup should follow
    """
    snapshot_move_data: Annotated[Optional[bool], Field(alias="snapshotMoveData")] = None
    """
    SnapshotMoveData specifies whether snapshot data should be moved
    """
    snapshot_volumes: Annotated[Optional[bool], Field(alias="snapshotVolumes")] = None
    """
    SnapshotVolumes specifies whether to take snapshots
    of any PV's referenced in the set of objects included
    in the Backup.
    """
    storage_location: Annotated[Optional[str], Field(alias="storageLocation")] = None
    """
    StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
    """
    ttl: Optional[str] = None
    """
    TTL is a time.Duration-parseable string describing how long
    the Backup should be retained for.
    """
    uploader_config: Annotated[Optional[UploaderConfigModel1], Field(alias="uploaderConfig")] = None
    """
    UploaderConfig specifies the configuration for the uploader.
    """
    volume_snapshot_locations: Annotated[
        Optional[List[str]], Field(alias="volumeSnapshotLocations")
    ] = None
    """
    VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
    """


class ScheduleSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScheduleSpec"]:
            return ScheduleSpec

        def build(self) -> "ScheduleSpec":
            return ScheduleSpec(**self._attrs)

        def paused(self, value: Optional[bool], /) -> Self:
            """
            Paused specifies whether the schedule is paused or not
            """
            return self._set("paused", value)

        def schedule(self, value: str, /) -> Self:
            """
            Schedule is a Cron expression defining when to run
            the Backup.
            """
            return self._set("schedule", value)

        def skip_immediately(self, value: Optional[bool], /) -> Self:
            """
            SkipImmediately specifies whether to skip backup if schedule is due immediately from `schedule.status.lastBackup` timestamp when schedule is unpaused or if schedule is new.
            If true, backup will be skipped immediately when schedule is unpaused if it is due based on .Status.LastBackupTimestamp or schedule is new, and will run at next schedule time.
            If false, backup will not be skipped immediately when schedule is unpaused, but will run at next schedule time.
            If empty, will follow server configuration (default: false).
            """
            return self._set("skip_immediately", value)

        @overload
        def template(self, value_or_callback: Template, /) -> "ScheduleSpec.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ScheduleSpec.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            Template is the definition of the Backup to be run
            on the provided schedule
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

        def use_owner_references_in_backup(self, value: Optional[bool], /) -> Self:
            """
            UseOwnerReferencesBackup specifies whether to use
            OwnerReferences on backups created by this Schedule.
            """
            return self._set("use_owner_references_in_backup", value)

    class BuilderContext(BuilderContextBase["ScheduleSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScheduleSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScheduleSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScheduleSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScheduleSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    paused: Optional[bool] = None
    """
    Paused specifies whether the schedule is paused or not
    """
    schedule: str
    """
    Schedule is a Cron expression defining when to run
    the Backup.
    """
    skip_immediately: Annotated[Optional[bool], Field(alias="skipImmediately")] = None
    """
    SkipImmediately specifies whether to skip backup if schedule is due immediately from `schedule.status.lastBackup` timestamp when schedule is unpaused or if schedule is new.
    If true, backup will be skipped immediately when schedule is unpaused if it is due based on .Status.LastBackupTimestamp or schedule is new, and will run at next schedule time.
    If false, backup will not be skipped immediately when schedule is unpaused, but will run at next schedule time.
    If empty, will follow server configuration (default: false).
    """
    template: Template
    """
    Template is the definition of the Backup to be run
    on the provided schedule
    """
    use_owner_references_in_backup: Annotated[
        Optional[bool], Field(alias="useOwnerReferencesInBackup")
    ] = None
    """
    UseOwnerReferencesBackup specifies whether to use
    OwnerReferences on backups created by this Schedule.
    """


class ScheduleStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScheduleStatus"]:
            return ScheduleStatus

        def build(self) -> "ScheduleStatus":
            return ScheduleStatus(**self._attrs)

        def last_backup(self, value: Optional[datetime], /) -> Self:
            """
            LastBackup is the last time a Backup was run for this
            Schedule schedule
            """
            return self._set("last_backup", value)

        def last_skipped(self, value: Optional[datetime], /) -> Self:
            """
            LastSkipped is the last time a Schedule was skipped
            """
            return self._set("last_skipped", value)

        def phase(self, value: Optional[Literal["New", "Enabled", "FailedValidation"]], /) -> Self:
            """
            Phase is the current phase of the Schedule
            """
            return self._set("phase", value)

        def validation_errors(self, value: Optional[List[str]], /) -> Self:
            """
            ValidationErrors is a slice of all validation errors (if
            applicable)
            """
            return self._set("validation_errors", value)

    class BuilderContext(BuilderContextBase["ScheduleStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScheduleStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScheduleStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScheduleStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScheduleStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_backup: Annotated[Optional[datetime], Field(alias="lastBackup")] = None
    """
    LastBackup is the last time a Backup was run for this
    Schedule schedule
    """
    last_skipped: Annotated[Optional[datetime], Field(alias="lastSkipped")] = None
    """
    LastSkipped is the last time a Schedule was skipped
    """
    phase: Optional[Literal["New", "Enabled", "FailedValidation"]] = None
    """
    Phase is the current phase of the Schedule
    """
    validation_errors: Annotated[Optional[List[str]], Field(alias="validationErrors")] = None
    """
    ValidationErrors is a slice of all validation errors (if
    applicable)
    """


class ServerStatusRequestSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServerStatusRequestSpec"]:
            return ServerStatusRequestSpec

        def build(self) -> "ServerStatusRequestSpec":
            return ServerStatusRequestSpec(**self._attrs)

    class BuilderContext(BuilderContextBase["ServerStatusRequestSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServerStatusRequestSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServerStatusRequestSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServerStatusRequestSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServerStatusRequestSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    pass


class Plugin(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Plugin"]:
            return Plugin

        def build(self) -> "Plugin":
            return Plugin(**self._attrs)

        def kind(self, value: str, /) -> Self:
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Plugin.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Plugin.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Plugin."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Plugin", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Plugin.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: str
    name: str


class ServerStatusRequestStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServerStatusRequestStatus"]:
            return ServerStatusRequestStatus

        def build(self) -> "ServerStatusRequestStatus":
            return ServerStatusRequestStatus(**self._attrs)

        def phase(self, value: Optional[Literal["New", "Processed"]], /) -> Self:
            """
            Phase is the current lifecycle phase of the ServerStatusRequest.
            """
            return self._set("phase", value)

        @overload
        def plugins(
            self, value_or_callback: List[Plugin], /
        ) -> "ServerStatusRequestStatus.Builder": ...

        @overload
        def plugins(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Plugin, Plugin.Builder]],
                GenericListBuilder[Plugin, Plugin.Builder] | List[Plugin],
            ],
            /,
        ) -> "ServerStatusRequestStatus.Builder": ...

        @overload
        def plugins(self, value_or_callback: Never = ...) -> ListBuilderContext[Plugin.Builder]: ...

        def plugins(self, value_or_callback=None, /):
            """
            Plugins list information about the plugins running on the Velero server
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Plugin.Builder]()
                context._parent_builder = self
                context._field_name = "plugins"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Plugin.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("plugins", value)

        def processed_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            ProcessedTimestamp is when the ServerStatusRequest was processed
            by the ServerStatusRequestController.
            """
            return self._set("processed_timestamp", value)

        def server_version(self, value: Optional[str], /) -> Self:
            """
            ServerVersion is the Velero server version.
            """
            return self._set("server_version", value)

    class BuilderContext(BuilderContextBase["ServerStatusRequestStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServerStatusRequestStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServerStatusRequestStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServerStatusRequestStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServerStatusRequestStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    phase: Optional[Literal["New", "Processed"]] = None
    """
    Phase is the current lifecycle phase of the ServerStatusRequest.
    """
    plugins: Optional[List[Plugin]] = None
    """
    Plugins list information about the plugins running on the Velero server
    """
    processed_timestamp: Annotated[Optional[datetime], Field(alias="processedTimestamp")] = None
    """
    ProcessedTimestamp is when the ServerStatusRequest was processed
    by the ServerStatusRequestController.
    """
    server_version: Annotated[Optional[str], Field(alias="serverVersion")] = None
    """
    ServerVersion is the Velero server version.
    """


class VolumeSnapshotLocationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeSnapshotLocationSpec"]:
            return VolumeSnapshotLocationSpec

        def build(self) -> "VolumeSnapshotLocationSpec":
            return VolumeSnapshotLocationSpec(**self._attrs)

        def config(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Config is for provider-specific configuration fields.
            """
            return self._set("config", value)

        @overload
        def credential(
            self, value_or_callback: Optional[Credential], /
        ) -> "VolumeSnapshotLocationSpec.Builder": ...

        @overload
        def credential(
            self,
            value_or_callback: Callable[[Credential.Builder], Credential.Builder | Credential],
            /,
        ) -> "VolumeSnapshotLocationSpec.Builder": ...

        @overload
        def credential(self, value_or_callback: Never = ...) -> "Credential.BuilderContext": ...

        def credential(self, value_or_callback=None, /):
            """
            Credential contains the credential information intended to be used with this location
            """
            if self._in_context and value_or_callback is None:
                context = Credential.BuilderContext()
                context._parent_builder = self
                context._field_name = "credential"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credential.builder())
                if isinstance(output, Credential.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credential", value)

        def provider(self, value: str, /) -> Self:
            """
            Provider is the provider of the volume storage.
            """
            return self._set("provider", value)

    class BuilderContext(BuilderContextBase["VolumeSnapshotLocationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeSnapshotLocationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeSnapshotLocationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeSnapshotLocationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeSnapshotLocationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config: Optional[Dict[str, str]] = None
    """
    Config is for provider-specific configuration fields.
    """
    credential: Optional[Credential] = None
    """
    Credential contains the credential information intended to be used with this location
    """
    provider: str
    """
    Provider is the provider of the volume storage.
    """


class VolumeSnapshotLocationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeSnapshotLocationStatus"]:
            return VolumeSnapshotLocationStatus

        def build(self) -> "VolumeSnapshotLocationStatus":
            return VolumeSnapshotLocationStatus(**self._attrs)

        def phase(self, value: Optional[Literal["Available", "Unavailable"]], /) -> Self:
            """
            VolumeSnapshotLocationPhase is the lifecycle phase of a Velero VolumeSnapshotLocation.
            """
            return self._set("phase", value)

    class BuilderContext(BuilderContextBase["VolumeSnapshotLocationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeSnapshotLocationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeSnapshotLocationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeSnapshotLocationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeSnapshotLocationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    phase: Optional[Literal["Available", "Unavailable"]] = None
    """
    VolumeSnapshotLocationPhase is the lifecycle phase of a Velero VolumeSnapshotLocation.
    """


class BackupRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupRepository"]:
            return BackupRepository

        def build(self) -> "BackupRepository":
            return BackupRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["BackupRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BackupRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BackupRepository.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[BackupRepositorySpec], /
        ) -> "BackupRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BackupRepositorySpec.Builder],
                BackupRepositorySpec.Builder | BackupRepositorySpec,
            ],
            /,
        ) -> "BackupRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BackupRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackupRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupRepositorySpec.builder())
                if isinstance(output, BackupRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BackupRepositoryStatus], /
        ) -> "BackupRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BackupRepositoryStatus.Builder],
                BackupRepositoryStatus.Builder | BackupRepositoryStatus,
            ],
            /,
        ) -> "BackupRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "BackupRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackupRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupRepositoryStatus.builder())
                if isinstance(output, BackupRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BackupRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["BackupRepository"]] = "BackupRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BackupRepositorySpec] = None
    status: Optional[BackupRepositoryStatus] = None


class Backup(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Backup"]:
            return Backup

        def build(self) -> "Backup":
            return Backup(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Backup"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Backup.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Backup.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[BackupSpec], /) -> "Backup.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BackupSpec.Builder], BackupSpec.Builder | BackupSpec],
            /,
        ) -> "Backup.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BackupSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackupSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupSpec.builder())
                if isinstance(output, BackupSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BackupStatus], /) -> "Backup.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BackupStatus.Builder], BackupStatus.Builder | BackupStatus
            ],
            /,
        ) -> "Backup.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BackupStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackupStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupStatus.builder())
                if isinstance(output, BackupStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Backup.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Backup.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Backup."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Backup", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Backup.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Backup"]] = "Backup"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BackupSpec] = None
    status: Optional[BackupStatus] = None


class BackupStorageLocation(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackupStorageLocation"]:
            return BackupStorageLocation

        def build(self) -> "BackupStorageLocation":
            return BackupStorageLocation(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["BackupStorageLocation"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BackupStorageLocation.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BackupStorageLocation.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[BackupStorageLocationSpec], /
        ) -> "BackupStorageLocation.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BackupStorageLocationSpec.Builder],
                BackupStorageLocationSpec.Builder | BackupStorageLocationSpec,
            ],
            /,
        ) -> "BackupStorageLocation.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "BackupStorageLocationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackupStorageLocationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupStorageLocationSpec.builder())
                if isinstance(output, BackupStorageLocationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[BackupStorageLocationStatus], /
        ) -> "BackupStorageLocation.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BackupStorageLocationStatus.Builder],
                BackupStorageLocationStatus.Builder | BackupStorageLocationStatus,
            ],
            /,
        ) -> "BackupStorageLocation.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "BackupStorageLocationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackupStorageLocationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackupStorageLocationStatus.builder())
                if isinstance(output, BackupStorageLocationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["BackupStorageLocation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackupStorageLocation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackupStorageLocation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackupStorageLocation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackupStorageLocation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["BackupStorageLocation"]] = "BackupStorageLocation"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[BackupStorageLocationSpec] = None
    status: Optional[BackupStorageLocationStatus] = None


class DeleteBackupRequest(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeleteBackupRequest"]:
            return DeleteBackupRequest

        def build(self) -> "DeleteBackupRequest":
            return DeleteBackupRequest(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DeleteBackupRequest"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DeleteBackupRequest.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DeleteBackupRequest.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[DeleteBackupRequestSpec], /
        ) -> "DeleteBackupRequest.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [DeleteBackupRequestSpec.Builder],
                DeleteBackupRequestSpec.Builder | DeleteBackupRequestSpec,
            ],
            /,
        ) -> "DeleteBackupRequest.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "DeleteBackupRequestSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DeleteBackupRequestSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeleteBackupRequestSpec.builder())
                if isinstance(output, DeleteBackupRequestSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[DeleteBackupRequestStatus], /
        ) -> "DeleteBackupRequest.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [DeleteBackupRequestStatus.Builder],
                DeleteBackupRequestStatus.Builder | DeleteBackupRequestStatus,
            ],
            /,
        ) -> "DeleteBackupRequest.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "DeleteBackupRequestStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DeleteBackupRequestStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeleteBackupRequestStatus.builder())
                if isinstance(output, DeleteBackupRequestStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DeleteBackupRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeleteBackupRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeleteBackupRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeleteBackupRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeleteBackupRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["DeleteBackupRequest"]] = "DeleteBackupRequest"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[DeleteBackupRequestSpec] = None
    status: Optional[DeleteBackupRequestStatus] = None


class DownloadRequest(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownloadRequest"]:
            return DownloadRequest

        def build(self) -> "DownloadRequest":
            return DownloadRequest(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DownloadRequest"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DownloadRequest.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DownloadRequest.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[DownloadRequestSpec], /
        ) -> "DownloadRequest.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [DownloadRequestSpec.Builder],
                DownloadRequestSpec.Builder | DownloadRequestSpec,
            ],
            /,
        ) -> "DownloadRequest.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "DownloadRequestSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DownloadRequestSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownloadRequestSpec.builder())
                if isinstance(output, DownloadRequestSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[DownloadRequestStatus], /
        ) -> "DownloadRequest.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [DownloadRequestStatus.Builder],
                DownloadRequestStatus.Builder | DownloadRequestStatus,
            ],
            /,
        ) -> "DownloadRequest.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "DownloadRequestStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DownloadRequestStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownloadRequestStatus.builder())
                if isinstance(output, DownloadRequestStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DownloadRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownloadRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownloadRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownloadRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownloadRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["DownloadRequest"]] = "DownloadRequest"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[DownloadRequestSpec] = None
    status: Optional[DownloadRequestStatus] = None


class PodVolumeBackup(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodVolumeBackup"]:
            return PodVolumeBackup

        def build(self) -> "PodVolumeBackup":
            return PodVolumeBackup(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PodVolumeBackup"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PodVolumeBackup.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PodVolumeBackup.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[PodVolumeBackupSpec], /
        ) -> "PodVolumeBackup.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PodVolumeBackupSpec.Builder],
                PodVolumeBackupSpec.Builder | PodVolumeBackupSpec,
            ],
            /,
        ) -> "PodVolumeBackup.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PodVolumeBackupSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodVolumeBackupSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodVolumeBackupSpec.builder())
                if isinstance(output, PodVolumeBackupSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PodVolumeBackupStatus], /
        ) -> "PodVolumeBackup.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PodVolumeBackupStatus.Builder],
                PodVolumeBackupStatus.Builder | PodVolumeBackupStatus,
            ],
            /,
        ) -> "PodVolumeBackup.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "PodVolumeBackupStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodVolumeBackupStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodVolumeBackupStatus.builder())
                if isinstance(output, PodVolumeBackupStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["PodVolumeBackup.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodVolumeBackup.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodVolumeBackup."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodVolumeBackup", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodVolumeBackup.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PodVolumeBackup"]] = "PodVolumeBackup"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[PodVolumeBackupSpec] = None
    status: Optional[PodVolumeBackupStatus] = None


class PodVolumeRestore(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodVolumeRestore"]:
            return PodVolumeRestore

        def build(self) -> "PodVolumeRestore":
            return PodVolumeRestore(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PodVolumeRestore"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PodVolumeRestore.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PodVolumeRestore.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[PodVolumeRestoreSpec], /
        ) -> "PodVolumeRestore.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PodVolumeRestoreSpec.Builder],
                PodVolumeRestoreSpec.Builder | PodVolumeRestoreSpec,
            ],
            /,
        ) -> "PodVolumeRestore.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PodVolumeRestoreSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodVolumeRestoreSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodVolumeRestoreSpec.builder())
                if isinstance(output, PodVolumeRestoreSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PodVolumeRestoreStatus], /
        ) -> "PodVolumeRestore.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PodVolumeRestoreStatus.Builder],
                PodVolumeRestoreStatus.Builder | PodVolumeRestoreStatus,
            ],
            /,
        ) -> "PodVolumeRestore.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "PodVolumeRestoreStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodVolumeRestoreStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodVolumeRestoreStatus.builder())
                if isinstance(output, PodVolumeRestoreStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["PodVolumeRestore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodVolumeRestore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodVolumeRestore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodVolumeRestore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodVolumeRestore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PodVolumeRestore"]] = "PodVolumeRestore"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[PodVolumeRestoreSpec] = None
    status: Optional[PodVolumeRestoreStatus] = None


class Restore(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Restore"]:
            return Restore

        def build(self) -> "Restore":
            return Restore(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Restore"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Restore.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Restore.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[RestoreSpec], /) -> "Restore.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[RestoreSpec.Builder], RestoreSpec.Builder | RestoreSpec],
            /,
        ) -> "Restore.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "RestoreSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RestoreSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RestoreSpec.builder())
                if isinstance(output, RestoreSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[RestoreStatusModel], /
        ) -> "Restore.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [RestoreStatusModel.Builder],
                RestoreStatusModel.Builder | RestoreStatusModel,
            ],
            /,
        ) -> "Restore.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "RestoreStatusModel.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RestoreStatusModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RestoreStatusModel.builder())
                if isinstance(output, RestoreStatusModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Restore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Restore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Restore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Restore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Restore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Restore"]] = "Restore"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[RestoreSpec] = None
    status: Optional[RestoreStatusModel] = None


class Schedule(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Schedule"]:
            return Schedule

        def build(self) -> "Schedule":
            return Schedule(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Schedule"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Schedule.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Schedule.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[ScheduleSpec], /) -> "Schedule.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ScheduleSpec.Builder], ScheduleSpec.Builder | ScheduleSpec
            ],
            /,
        ) -> "Schedule.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ScheduleSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ScheduleSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScheduleSpec.builder())
                if isinstance(output, ScheduleSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ScheduleStatus], /) -> "Schedule.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ScheduleStatus.Builder], ScheduleStatus.Builder | ScheduleStatus
            ],
            /,
        ) -> "Schedule.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ScheduleStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ScheduleStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScheduleStatus.builder())
                if isinstance(output, ScheduleStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Schedule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Schedule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Schedule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Schedule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Schedule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Schedule"]] = "Schedule"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ScheduleSpec] = None
    status: Optional[ScheduleStatus] = None


class ServerStatusRequest(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServerStatusRequest"]:
            return ServerStatusRequest

        def build(self) -> "ServerStatusRequest":
            return ServerStatusRequest(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ServerStatusRequest"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ServerStatusRequest.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ServerStatusRequest.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ServerStatusRequestSpec], /
        ) -> "ServerStatusRequest.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ServerStatusRequestSpec.Builder],
                ServerStatusRequestSpec.Builder | ServerStatusRequestSpec,
            ],
            /,
        ) -> "ServerStatusRequest.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ServerStatusRequestSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServerStatusRequestSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServerStatusRequestSpec.builder())
                if isinstance(output, ServerStatusRequestSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ServerStatusRequestStatus], /
        ) -> "ServerStatusRequest.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ServerStatusRequestStatus.Builder],
                ServerStatusRequestStatus.Builder | ServerStatusRequestStatus,
            ],
            /,
        ) -> "ServerStatusRequest.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ServerStatusRequestStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServerStatusRequestStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServerStatusRequestStatus.builder())
                if isinstance(output, ServerStatusRequestStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ServerStatusRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServerStatusRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServerStatusRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServerStatusRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServerStatusRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ServerStatusRequest"]] = "ServerStatusRequest"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ServerStatusRequestSpec] = None
    status: Optional[ServerStatusRequestStatus] = None


class VolumeSnapshotLocation(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeSnapshotLocation"]:
            return VolumeSnapshotLocation

        def build(self) -> "VolumeSnapshotLocation":
            return VolumeSnapshotLocation(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["VolumeSnapshotLocation"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "VolumeSnapshotLocation.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "VolumeSnapshotLocation.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[VolumeSnapshotLocationSpec], /
        ) -> "VolumeSnapshotLocation.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [VolumeSnapshotLocationSpec.Builder],
                VolumeSnapshotLocationSpec.Builder | VolumeSnapshotLocationSpec,
            ],
            /,
        ) -> "VolumeSnapshotLocation.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "VolumeSnapshotLocationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = VolumeSnapshotLocationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeSnapshotLocationSpec.builder())
                if isinstance(output, VolumeSnapshotLocationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[VolumeSnapshotLocationStatus], /
        ) -> "VolumeSnapshotLocation.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [VolumeSnapshotLocationStatus.Builder],
                VolumeSnapshotLocationStatus.Builder | VolumeSnapshotLocationStatus,
            ],
            /,
        ) -> "VolumeSnapshotLocation.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "VolumeSnapshotLocationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = VolumeSnapshotLocationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeSnapshotLocationStatus.builder())
                if isinstance(output, VolumeSnapshotLocationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["VolumeSnapshotLocation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeSnapshotLocation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeSnapshotLocation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeSnapshotLocation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeSnapshotLocation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v1"]], Field(alias="apiVersion")] = (
        "velero.io/v1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["VolumeSnapshotLocation"]] = "VolumeSnapshotLocation"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[VolumeSnapshotLocationSpec] = None
    status: Optional[VolumeSnapshotLocationStatus] = None
