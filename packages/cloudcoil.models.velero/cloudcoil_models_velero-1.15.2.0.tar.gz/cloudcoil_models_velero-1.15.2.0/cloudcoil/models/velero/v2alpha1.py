# Generated by cloudcoil-model-codegen v0.4.3
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class TargetVolume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TargetVolume"]:
            return TargetVolume

        def build(self) -> "TargetVolume":
            return TargetVolume(**self._attrs)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace is the target namespace
            """
            return self._set("namespace", value)

        def pv(self, value: str, /) -> Self:
            """
            PV is the name of the target PV that is created by Velero restore
            """
            return self._set("pv", value)

        def pvc(self, value: str, /) -> Self:
            """
            PVC is the name of the target PVC that is created by Velero restore
            """
            return self._set("pvc", value)

    class BuilderContext(BuilderContextBase["TargetVolume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TargetVolume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TargetVolume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TargetVolume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TargetVolume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace: str
    """
    Namespace is the target namespace
    """
    pv: str
    """
    PV is the name of the target PV that is created by Velero restore
    """
    pvc: str
    """
    PVC is the name of the target PVC that is created by Velero restore
    """


class DataDownloadSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataDownloadSpec"]:
            return DataDownloadSpec

        def build(self) -> "DataDownloadSpec":
            return DataDownloadSpec(**self._attrs)

        def backup_storage_location(self, value: str, /) -> Self:
            """
            BackupStorageLocation is the name of the backup storage location
            where the backup repository is stored.
            """
            return self._set("backup_storage_location", value)

        def cancel(self, value: Optional[bool], /) -> Self:
            """
            Cancel indicates request to cancel the ongoing DataDownload. It can be set
            when the DataDownload is in InProgress phase
            """
            return self._set("cancel", value)

        def data_mover_config(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            DataMoverConfig is for data-mover-specific configuration fields.
            """
            return self._set("data_mover_config", value)

        def datamover(self, value: Optional[str], /) -> Self:
            """
            DataMover specifies the data mover to be used by the backup.
            If DataMover is "" or "velero", the built-in data mover will be used.
            """
            return self._set("datamover", value)

        def operation_timeout(self, value: str, /) -> Self:
            """
            OperationTimeout specifies the time used to wait internal operations,
            before returning error as timeout.
            """
            return self._set("operation_timeout", value)

        def snapshot_id(self, value: str, /) -> Self:
            """
            SnapshotID is the ID of the Velero backup snapshot to be restored from.
            """
            return self._set("snapshot_id", value)

        def source_namespace(self, value: str, /) -> Self:
            """
            SourceNamespace is the original namespace where the volume is backed up from.
            It may be different from SourcePVC's namespace if namespace is remapped during restore.
            """
            return self._set("source_namespace", value)

        @overload
        def target_volume(
            self, value_or_callback: TargetVolume, /
        ) -> "DataDownloadSpec.Builder": ...

        @overload
        def target_volume(
            self,
            value_or_callback: Callable[
                [TargetVolume.Builder], TargetVolume.Builder | TargetVolume
            ],
            /,
        ) -> "DataDownloadSpec.Builder": ...

        @overload
        def target_volume(
            self, value_or_callback: Never = ...
        ) -> "TargetVolume.BuilderContext": ...

        def target_volume(self, value_or_callback=None, /):
            """
            TargetVolume is the information of the target PVC and PV.
            """
            if self._in_context and value_or_callback is None:
                context = TargetVolume.BuilderContext()
                context._parent_builder = self
                context._field_name = "target_volume"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TargetVolume.builder())
                if isinstance(output, TargetVolume.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("target_volume", value)

    class BuilderContext(BuilderContextBase["DataDownloadSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataDownloadSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataDownloadSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataDownloadSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataDownloadSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_storage_location: Annotated[str, Field(alias="backupStorageLocation")]
    """
    BackupStorageLocation is the name of the backup storage location
    where the backup repository is stored.
    """
    cancel: Optional[bool] = None
    """
    Cancel indicates request to cancel the ongoing DataDownload. It can be set
    when the DataDownload is in InProgress phase
    """
    data_mover_config: Annotated[Optional[Dict[str, str]], Field(alias="dataMoverConfig")] = None
    """
    DataMoverConfig is for data-mover-specific configuration fields.
    """
    datamover: Optional[str] = None
    """
    DataMover specifies the data mover to be used by the backup.
    If DataMover is "" or "velero", the built-in data mover will be used.
    """
    operation_timeout: Annotated[str, Field(alias="operationTimeout")]
    """
    OperationTimeout specifies the time used to wait internal operations,
    before returning error as timeout.
    """
    snapshot_id: Annotated[str, Field(alias="snapshotID")]
    """
    SnapshotID is the ID of the Velero backup snapshot to be restored from.
    """
    source_namespace: Annotated[str, Field(alias="sourceNamespace")]
    """
    SourceNamespace is the original namespace where the volume is backed up from.
    It may be different from SourcePVC's namespace if namespace is remapped during restore.
    """
    target_volume: Annotated[TargetVolume, Field(alias="targetVolume")]
    """
    TargetVolume is the information of the target PVC and PV.
    """


class Progress(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Progress"]:
            return Progress

        def build(self) -> "Progress":
            return Progress(**self._attrs)

        def bytes_done(self, value: Optional[int], /) -> Self:
            return self._set("bytes_done", value)

        def total_bytes(self, value: Optional[int], /) -> Self:
            return self._set("total_bytes", value)

    class BuilderContext(BuilderContextBase["Progress.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Progress.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Progress."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Progress", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Progress.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bytes_done: Annotated[Optional[int], Field(alias="bytesDone")] = None
    total_bytes: Annotated[Optional[int], Field(alias="totalBytes")] = None


class DataDownloadStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataDownloadStatus"]:
            return DataDownloadStatus

        def build(self) -> "DataDownloadStatus":
            return DataDownloadStatus(**self._attrs)

        def completion_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            CompletionTimestamp records the time a restore was completed.
            Completion time is recorded even on failed restores.
            The server's time is used for CompletionTimestamps
            """
            return self._set("completion_timestamp", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is a message about the DataDownload's status.
            """
            return self._set("message", value)

        def node(self, value: Optional[str], /) -> Self:
            """
            Node is name of the node where the DataDownload is processed.
            """
            return self._set("node", value)

        def phase(
            self,
            value: Optional[
                Literal[
                    "New",
                    "Accepted",
                    "Prepared",
                    "InProgress",
                    "Canceling",
                    "Canceled",
                    "Completed",
                    "Failed",
                ]
            ],
            /,
        ) -> Self:
            """
            Phase is the current state of the DataDownload.
            """
            return self._set("phase", value)

        @overload
        def progress(
            self, value_or_callback: Optional[Progress], /
        ) -> "DataDownloadStatus.Builder": ...

        @overload
        def progress(
            self,
            value_or_callback: Callable[[Progress.Builder], Progress.Builder | Progress],
            /,
        ) -> "DataDownloadStatus.Builder": ...

        @overload
        def progress(self, value_or_callback: Never = ...) -> "Progress.BuilderContext": ...

        def progress(self, value_or_callback=None, /):
            """
            Progress holds the total number of bytes of the snapshot and the current
            number of restored bytes. This can be used to display progress information
            about the restore operation.
            """
            if self._in_context and value_or_callback is None:
                context = Progress.BuilderContext()
                context._parent_builder = self
                context._field_name = "progress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Progress.builder())
                if isinstance(output, Progress.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("progress", value)

        def start_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            StartTimestamp records the time a restore was started.
            The server's time is used for StartTimestamps
            """
            return self._set("start_timestamp", value)

    class BuilderContext(BuilderContextBase["DataDownloadStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataDownloadStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataDownloadStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataDownloadStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataDownloadStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    completion_timestamp: Annotated[Optional[datetime], Field(alias="completionTimestamp")] = None
    """
    CompletionTimestamp records the time a restore was completed.
    Completion time is recorded even on failed restores.
    The server's time is used for CompletionTimestamps
    """
    message: Optional[str] = None
    """
    Message is a message about the DataDownload's status.
    """
    node: Optional[str] = None
    """
    Node is name of the node where the DataDownload is processed.
    """
    phase: Optional[
        Literal[
            "New",
            "Accepted",
            "Prepared",
            "InProgress",
            "Canceling",
            "Canceled",
            "Completed",
            "Failed",
        ]
    ] = None
    """
    Phase is the current state of the DataDownload.
    """
    progress: Optional[Progress] = None
    """
    Progress holds the total number of bytes of the snapshot and the current
    number of restored bytes. This can be used to display progress information
    about the restore operation.
    """
    start_timestamp: Annotated[Optional[datetime], Field(alias="startTimestamp")] = None
    """
    StartTimestamp records the time a restore was started.
    The server's time is used for StartTimestamps
    """


class CsiSnapshot(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CsiSnapshot"]:
            return CsiSnapshot

        def build(self) -> "CsiSnapshot":
            return CsiSnapshot(**self._attrs)

        def snapshot_class(self, value: Optional[str], /) -> Self:
            """
            SnapshotClass is the name of the snapshot class that the volume snapshot is created with
            """
            return self._set("snapshot_class", value)

        def storage_class(self, value: str, /) -> Self:
            """
            StorageClass is the name of the storage class of the PVC that the volume snapshot is created from
            """
            return self._set("storage_class", value)

        def volume_snapshot(self, value: str, /) -> Self:
            """
            VolumeSnapshot is the name of the volume snapshot to be backed up
            """
            return self._set("volume_snapshot", value)

    class BuilderContext(BuilderContextBase["CsiSnapshot.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CsiSnapshot.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CsiSnapshot."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CsiSnapshot", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CsiSnapshot.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    snapshot_class: Annotated[Optional[str], Field(alias="snapshotClass")] = None
    """
    SnapshotClass is the name of the snapshot class that the volume snapshot is created with
    """
    storage_class: Annotated[str, Field(alias="storageClass")]
    """
    StorageClass is the name of the storage class of the PVC that the volume snapshot is created from
    """
    volume_snapshot: Annotated[str, Field(alias="volumeSnapshot")]
    """
    VolumeSnapshot is the name of the volume snapshot to be backed up
    """


class DataUploadSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataUploadSpec"]:
            return DataUploadSpec

        def build(self) -> "DataUploadSpec":
            return DataUploadSpec(**self._attrs)

        def backup_storage_location(self, value: str, /) -> Self:
            """
            BackupStorageLocation is the name of the backup storage location
            where the backup repository is stored.
            """
            return self._set("backup_storage_location", value)

        def cancel(self, value: Optional[bool], /) -> Self:
            """
            Cancel indicates request to cancel the ongoing DataUpload. It can be set
            when the DataUpload is in InProgress phase
            """
            return self._set("cancel", value)

        @overload
        def csi_snapshot(
            self, value_or_callback: Optional[CsiSnapshot], /
        ) -> "DataUploadSpec.Builder": ...

        @overload
        def csi_snapshot(
            self,
            value_or_callback: Callable[[CsiSnapshot.Builder], CsiSnapshot.Builder | CsiSnapshot],
            /,
        ) -> "DataUploadSpec.Builder": ...

        @overload
        def csi_snapshot(self, value_or_callback: Never = ...) -> "CsiSnapshot.BuilderContext": ...

        def csi_snapshot(self, value_or_callback=None, /):
            """
            If SnapshotType is CSI, CSISnapshot provides the information of the CSI snapshot.
            """
            if self._in_context and value_or_callback is None:
                context = CsiSnapshot.BuilderContext()
                context._parent_builder = self
                context._field_name = "csi_snapshot"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CsiSnapshot.builder())
                if isinstance(output, CsiSnapshot.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("csi_snapshot", value)

        def data_mover_config(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            DataMoverConfig is for data-mover-specific configuration fields.
            """
            return self._set("data_mover_config", value)

        def datamover(self, value: Optional[str], /) -> Self:
            """
            DataMover specifies the data mover to be used by the backup.
            If DataMover is "" or "velero", the built-in data mover will be used.
            """
            return self._set("datamover", value)

        def operation_timeout(self, value: str, /) -> Self:
            """
            OperationTimeout specifies the time used to wait internal operations,
            before returning error as timeout.
            """
            return self._set("operation_timeout", value)

        def snapshot_type(self, value: str, /) -> Self:
            """
            SnapshotType is the type of the snapshot to be backed up.
            """
            return self._set("snapshot_type", value)

        def source_namespace(self, value: str, /) -> Self:
            """
            SourceNamespace is the original namespace where the volume is backed up from.
            It is the same namespace for SourcePVC and CSI namespaced objects.
            """
            return self._set("source_namespace", value)

        def source_pvc(self, value: str, /) -> Self:
            """
            SourcePVC is the name of the PVC which the snapshot is taken for.
            """
            return self._set("source_pvc", value)

    class BuilderContext(BuilderContextBase["DataUploadSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataUploadSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataUploadSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataUploadSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataUploadSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backup_storage_location: Annotated[str, Field(alias="backupStorageLocation")]
    """
    BackupStorageLocation is the name of the backup storage location
    where the backup repository is stored.
    """
    cancel: Optional[bool] = None
    """
    Cancel indicates request to cancel the ongoing DataUpload. It can be set
    when the DataUpload is in InProgress phase
    """
    csi_snapshot: Annotated[Optional[CsiSnapshot], Field(alias="csiSnapshot")] = None
    """
    If SnapshotType is CSI, CSISnapshot provides the information of the CSI snapshot.
    """
    data_mover_config: Annotated[Optional[Dict[str, str]], Field(alias="dataMoverConfig")] = None
    """
    DataMoverConfig is for data-mover-specific configuration fields.
    """
    datamover: Optional[str] = None
    """
    DataMover specifies the data mover to be used by the backup.
    If DataMover is "" or "velero", the built-in data mover will be used.
    """
    operation_timeout: Annotated[str, Field(alias="operationTimeout")]
    """
    OperationTimeout specifies the time used to wait internal operations,
    before returning error as timeout.
    """
    snapshot_type: Annotated[str, Field(alias="snapshotType")]
    """
    SnapshotType is the type of the snapshot to be backed up.
    """
    source_namespace: Annotated[str, Field(alias="sourceNamespace")]
    """
    SourceNamespace is the original namespace where the volume is backed up from.
    It is the same namespace for SourcePVC and CSI namespaced objects.
    """
    source_pvc: Annotated[str, Field(alias="sourcePVC")]
    """
    SourcePVC is the name of the PVC which the snapshot is taken for.
    """


class DataUploadStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataUploadStatus"]:
            return DataUploadStatus

        def build(self) -> "DataUploadStatus":
            return DataUploadStatus(**self._attrs)

        def completion_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            CompletionTimestamp records the time a backup was completed.
            Completion time is recorded even on failed backups.
            Completion time is recorded before uploading the backup object.
            The server's time is used for CompletionTimestamps
            """
            return self._set("completion_timestamp", value)

        def data_mover_result(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            DataMoverResult stores data-mover-specific information as a result of the DataUpload.
            """
            return self._set("data_mover_result", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is a message about the DataUpload's status.
            """
            return self._set("message", value)

        def node(self, value: Optional[str], /) -> Self:
            """
            Node is name of the node where the DataUpload is processed.
            """
            return self._set("node", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path is the full path of the snapshot volume being backed up.
            """
            return self._set("path", value)

        def phase(
            self,
            value: Optional[
                Literal[
                    "New",
                    "Accepted",
                    "Prepared",
                    "InProgress",
                    "Canceling",
                    "Canceled",
                    "Completed",
                    "Failed",
                ]
            ],
            /,
        ) -> Self:
            """
            Phase is the current state of the DataUpload.
            """
            return self._set("phase", value)

        @overload
        def progress(
            self, value_or_callback: Optional[Progress], /
        ) -> "DataUploadStatus.Builder": ...

        @overload
        def progress(
            self,
            value_or_callback: Callable[[Progress.Builder], Progress.Builder | Progress],
            /,
        ) -> "DataUploadStatus.Builder": ...

        @overload
        def progress(self, value_or_callback: Never = ...) -> "Progress.BuilderContext": ...

        def progress(self, value_or_callback=None, /):
            """
            Progress holds the total number of bytes of the volume and the current
            number of backed up bytes. This can be used to display progress information
            about the backup operation.
            """
            if self._in_context and value_or_callback is None:
                context = Progress.BuilderContext()
                context._parent_builder = self
                context._field_name = "progress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Progress.builder())
                if isinstance(output, Progress.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("progress", value)

        def snapshot_id(self, value: Optional[str], /) -> Self:
            """
            SnapshotID is the identifier for the snapshot in the backup repository.
            """
            return self._set("snapshot_id", value)

        def start_timestamp(self, value: Optional[datetime], /) -> Self:
            """
            StartTimestamp records the time a backup was started.
            Separate from CreationTimestamp, since that value changes
            on restores.
            The server's time is used for StartTimestamps
            """
            return self._set("start_timestamp", value)

    class BuilderContext(BuilderContextBase["DataUploadStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataUploadStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataUploadStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataUploadStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataUploadStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    completion_timestamp: Annotated[Optional[datetime], Field(alias="completionTimestamp")] = None
    """
    CompletionTimestamp records the time a backup was completed.
    Completion time is recorded even on failed backups.
    Completion time is recorded before uploading the backup object.
    The server's time is used for CompletionTimestamps
    """
    data_mover_result: Annotated[Optional[Dict[str, str]], Field(alias="dataMoverResult")] = None
    """
    DataMoverResult stores data-mover-specific information as a result of the DataUpload.
    """
    message: Optional[str] = None
    """
    Message is a message about the DataUpload's status.
    """
    node: Optional[str] = None
    """
    Node is name of the node where the DataUpload is processed.
    """
    path: Optional[str] = None
    """
    Path is the full path of the snapshot volume being backed up.
    """
    phase: Optional[
        Literal[
            "New",
            "Accepted",
            "Prepared",
            "InProgress",
            "Canceling",
            "Canceled",
            "Completed",
            "Failed",
        ]
    ] = None
    """
    Phase is the current state of the DataUpload.
    """
    progress: Optional[Progress] = None
    """
    Progress holds the total number of bytes of the volume and the current
    number of backed up bytes. This can be used to display progress information
    about the backup operation.
    """
    snapshot_id: Annotated[Optional[str], Field(alias="snapshotID")] = None
    """
    SnapshotID is the identifier for the snapshot in the backup repository.
    """
    start_timestamp: Annotated[Optional[datetime], Field(alias="startTimestamp")] = None
    """
    StartTimestamp records the time a backup was started.
    Separate from CreationTimestamp, since that value changes
    on restores.
    The server's time is used for StartTimestamps
    """


class DataDownload(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataDownload"]:
            return DataDownload

        def build(self) -> "DataDownload":
            return DataDownload(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v2alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DataDownload"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DataDownload.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DataDownload.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[DataDownloadSpec], /
        ) -> "DataDownload.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [DataDownloadSpec.Builder], DataDownloadSpec.Builder | DataDownloadSpec
            ],
            /,
        ) -> "DataDownload.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "DataDownloadSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DataDownloadSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataDownloadSpec.builder())
                if isinstance(output, DataDownloadSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[DataDownloadStatus], /
        ) -> "DataDownload.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [DataDownloadStatus.Builder],
                DataDownloadStatus.Builder | DataDownloadStatus,
            ],
            /,
        ) -> "DataDownload.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "DataDownloadStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DataDownloadStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataDownloadStatus.builder())
                if isinstance(output, DataDownloadStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DataDownload.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataDownload.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataDownload."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataDownload", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataDownload.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v2alpha1"]], Field(alias="apiVersion")] = (
        "velero.io/v2alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["DataDownload"]] = "DataDownload"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[DataDownloadSpec] = None
    status: Optional[DataDownloadStatus] = None


class DataUpload(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DataUpload"]:
            return DataUpload

        def build(self) -> "DataUpload":
            return DataUpload(**self._attrs)

        def api_version(self, value: Optional[Literal["velero.io/v2alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DataUpload"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DataUpload.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DataUpload.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[DataUploadSpec], /) -> "DataUpload.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [DataUploadSpec.Builder], DataUploadSpec.Builder | DataUploadSpec
            ],
            /,
        ) -> "DataUpload.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "DataUploadSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DataUploadSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataUploadSpec.builder())
                if isinstance(output, DataUploadSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[DataUploadStatus], /
        ) -> "DataUpload.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [DataUploadStatus.Builder], DataUploadStatus.Builder | DataUploadStatus
            ],
            /,
        ) -> "DataUpload.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "DataUploadStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DataUploadStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DataUploadStatus.builder())
                if isinstance(output, DataUploadStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DataUpload.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DataUpload.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DataUpload."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DataUpload", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DataUpload.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["velero.io/v2alpha1"]], Field(alias="apiVersion")] = (
        "velero.io/v2alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["DataUpload"]] = "DataUpload"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[DataUploadSpec] = None
    status: Optional[DataUploadStatus] = None
