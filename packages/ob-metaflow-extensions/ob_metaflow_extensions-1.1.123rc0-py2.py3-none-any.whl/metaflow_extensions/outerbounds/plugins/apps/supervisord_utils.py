import argparse
import os
import configparser
import tempfile
import sys
import subprocess
from pathlib import Path
import shutil
from enum import Enum
import time


class SupervisorClientException(Exception):
    pass


class SupervisorClient:
    class SupervisodProcessCodes(Enum):
        STOPPED = 0
        STARTING = 10
        RUNNING = 20
        BACKOFF = 30
        STOPPING = 40
        EXITED = 100
        FATAL = 200
        UNKNOWN = 1000

    def __init__(self, wait_time_seconds_for_app_start: int):
        self.supervisor_conf_loc = os.environ.get("SUPERVISOR_CONF_PATH")

        self.wait_time_seconds_for_app_start = wait_time_seconds_for_app_start
        if self.supervisor_conf_loc is None or not os.path.exists(
            self.supervisor_conf_loc
        ):
            raise SupervisorClientException(
                "This workstation does not support deploying apps! Please reach out to Outerbounds for support."
            )

        self.metaflow_envs_persistent_path = os.environ.get(
            "SUPERVISOR_PYTHON_ENVS_PATH"
        )
        if self.metaflow_envs_persistent_path is None:
            raise SupervisorClientException(
                "This workstation does not support deploying apps! Please reach out to Outerbounds for support."
            )

        # Check if supervisorctl is installed
        if not shutil.which("supervisorctl"):
            raise SupervisorClientException(
                "This workstation does not support deploying apps! Please reach out to Outerbounds for support."
            )

    def start_process_with_supervisord(self, app_name, entrypoint, directory=None):
        """Add a new program entry to supervisor configuration."""

        persistent_path_for_executable = (
            self.persist_metaflow_generated_python_environment()
        )

        command = f"{persistent_path_for_executable} {entrypoint}"

        entry = {
            "command": command,
            "directory": directory or os.getcwd(),
            "autostart": "true",
            "autorestart": "true",
        }

        supervisor_config = configparser.ConfigParser()
        supervisor_config.read(self.supervisor_conf_loc)

        supervisor_config[f"program:{app_name}"] = entry

        with tempfile.NamedTemporaryFile(
            "w", dir=os.path.dirname(self.supervisor_conf_loc), delete=False
        ) as f:
            supervisor_config.write(f)
            tmp_file = f.name
        os.rename(tmp_file, self.supervisor_conf_loc)

        # Execute supervisorctl reload
        # Capture the exit code
        exit_code = subprocess.run(
            ["supervisorctl", "reload"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        ).returncode
        if exit_code != 0:
            print("Failed to reload supervisor configuration!", file=sys.stderr)
            return

        print(
            f"Waiting for {self.wait_time_seconds_for_app_start} seconds for {app_name} to start..."
        )
        time.sleep(self.wait_time_seconds_for_app_start)
        status = self._get_launched_prcoess_status(app_name)

        if status not in [
            self.SupervisodProcessCodes.RUNNING,
            self.SupervisodProcessCodes.STARTING,
        ]:
            raise SupervisorClientException(
                f"Failed to start {app_name}! Try running {command} manually to debug."
            )

    def _get_launched_prcoess_status(self, app_name):
        status_cmd_output = subprocess.run(
            ["supervisorctl", "status", app_name],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        ).stdout.decode("utf-8")

        status_cmd_output_parts = [
            x.strip() for x in status_cmd_output.split(" ") if x.strip()
        ]

        status_str = status_cmd_output_parts[1]

        if status_str == "RUNNING":
            return self.SupervisodProcessCodes.RUNNING
        elif status_str == "STOPPED":
            return self.SupervisodProcessCodes.STOPPED
        elif status_str == "STARTING":
            return self.SupervisodProcessCodes.STARTING
        elif status_str == "BACKOFF":
            return self.SupervisodProcessCodes.BACKOFF
        elif status_str == "STOPPING":
            return self.SupervisodProcessCodes.STOPPING
        elif status_str == "EXITED":
            return self.SupervisodProcessCodes.EXITED
        elif status_str == "FATAL":
            return self.SupervisodProcessCodes.FATAL
        else:
            return self.SupervisodProcessCodes.UNKNOWN

    # By default, an environment generated by metaflow will end up in a path like: /root/micromamba/envs/metaflow/linux-64/02699a4d2d50cfc/bin/python
    # However, on a workstation these environments are not persisted, so we need to copy them over to /home/ob-workspace
    def persist_metaflow_generated_python_environment(self):
        current_executable = sys.executable
        environment_path = Path(current_executable).parent.parent

        persistent_path_for_this_environment = os.path.join(
            self.metaflow_envs_persistent_path,
            environment_path.parent.name,
            environment_path.name,
        )

        final_executable_path = os.path.join(
            persistent_path_for_this_environment,
            Path(current_executable).parent.name,
            Path(current_executable).name,
        )

        if os.path.exists(final_executable_path):
            return final_executable_path

        os.makedirs(persistent_path_for_this_environment, exist_ok=True)

        for item in os.listdir(environment_path):
            src_path = os.path.join(environment_path, item)
            dst_path = os.path.join(persistent_path_for_this_environment, item)
            if os.path.isdir(src_path):
                shutil.copytree(src_path, dst_path, dirs_exist_ok=True)
            else:
                shutil.copy2(src_path, dst_path)

        return final_executable_path
