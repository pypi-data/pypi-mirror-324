from typing import List, Any, Dict, Tuple

# noinspection PyPackageRequirements
from graphql import (
    GraphQLSchema,
    GraphQLObjectType,
    GraphQLField,
    GraphQLString,
    is_named_type,
    ExecutionResult,
    GraphQLType,
    specified_directives,
    GraphQLDirective,
    GraphQLNamedType,
)

from graphql_api import GraphQLError

from graphql_api.executor import GraphQLExecutor, GraphQLBaseExecutor
from graphql_api.middleware import GraphQLMiddleware
from graphql_api.reduce import GraphQLSchemaReducer, GraphQLFilter
from graphql_api.mapper import GraphQLTypeMapper


class GraphQLFieldContext:
    def __init__(self, meta, query=None):
        self.meta = meta
        self.query = query

    def __str__(self):
        query_str = ""
        if self.query:
            query_str = f", query: {query_str}" if self.query else ""
        return f"<Node meta: {self.meta}{query_str}>"


class GraphQLRequestContext:
    def __init__(self, args, info):
        self.args = args
        self.info = info


def add_schema_directives(value, directives):
    if directives:
        if hasattr(value, "_schema_directives"):
            directives = [*directives, *getattr(value, "_schema_directives", [])]

        value._schema_directives = directives
    return value


# noinspection PyShadowingBuiltins
def tag_value(
    value,
    graphql_type: str,
    schema: "GraphQLAPI" = None,
    meta: Dict = None,
    directives: List = None,
    is_root_type: bool = False,
):
    if not hasattr(value, "_graphql"):
        value._graphql = True

    if not hasattr(value, "_defined_on"):
        value._defined_on = value

    if not hasattr(value, "_schemas"):
        value._schemas = {}

    if hasattr(value, "_schemas"):
        # noinspection PyProtectedMember
        value._schemas[schema] = {
            "defined_on": value,
            "meta": meta or {},
            "graphql_type": graphql_type,
            "schema": schema,
        }

    add_schema_directives(value, directives)

    if is_root_type:
        if graphql_type != "object":
            raise TypeError(f"Cannot set '{value}' of type '{graphql_type}' as a root.")

        if schema:
            schema.set_root_type(value)

    return value


# noinspection PyShadowingBuiltins
def build_decorator(
    a,
    b,
    graphql_type,
    mutable=None,
    interface=None,
    abstract=None,
    directives: List = None,
    is_root_type: bool = False,
):
    if graphql_type == "object":
        if interface:
            graphql_type = "interface"
        elif abstract:
            graphql_type = "abstract"

    if graphql_type == "field":
        if mutable:
            graphql_type = "mutable_field"

    func = a if callable(a) else b if callable(b) else None
    meta = a if isinstance(a, dict) else b if isinstance(b, dict) else None
    schema = (
        a if isinstance(a, GraphQLAPI) else b if isinstance(b, GraphQLAPI) else None
    )

    if func:
        return tag_value(
            value=func,
            graphql_type=graphql_type,
            schema=schema,
            meta=meta,
            directives=directives,
            is_root_type=is_root_type,
        )

    return lambda f: tag_value(
        value=f,
        graphql_type=graphql_type,
        schema=schema,
        meta=meta,
        directives=directives,
        is_root_type=is_root_type,
    )


class GraphQLRootTypeDelegate:
    infer_subclass_fields = True

    @classmethod
    def validate_graphql_schema(cls, schema: GraphQLSchema) -> GraphQLSchema:
        """
        This method is called whenever a schema is created with this
        class as the root type.
        :param schema: The GraphQL schema that is generated by
        :return:schema: The validated and updated GraphQL schema.
        """
        return schema


class GraphQLAPI(GraphQLBaseExecutor):
    def field(self=None, meta=None, mutable=False, directives: List = None):
        return build_decorator(
            self, meta, graphql_type="field", mutable=mutable, directives=directives
        )

    def type(
        self=None,
        meta=None,
        abstract=False,
        interface=False,
        is_root_type=False,
        directives: List = None,
    ):
        return build_decorator(
            self,
            meta,
            graphql_type="object",
            abstract=abstract,
            interface=interface,
            directives=directives,
            is_root_type=is_root_type,
        )

    def set_root_type(self, root_type):
        self.root_type = root_type
        return root_type

    def __init__(
        self,
        root_type=None,
        middleware: List[GraphQLMiddleware] = None,
        directives: List[GraphQLDirective] = None,
        types: List[GraphQLNamedType] = None,
        filters: List[GraphQLFilter] = None,
        error_protection=True,
        ignore_middleware_during_introspection: bool = True,
    ):
        super().__init__()
        if middleware is None:
            middleware = []

        if directives is None:
            directives = []

        self.root_type = root_type
        self.middleware = middleware
        self.directives = {
            directive.name: directive
            for directive in [*specified_directives, *directives]
        }
        self.types = set(types) if types else set()
        self.filters = filters
        self.query_mapper = None
        self.mutation_mapper = None
        self.error_protection = error_protection
        self.ignore_middleware_during_introspection = (
            ignore_middleware_during_introspection
        )
        self._cached_graphql_schema = None

    def graphql_schema(self, ignore_cache: bool = False) -> Tuple[GraphQLSchema, Dict]:
        schema_args = {}
        meta = {}
        if not ignore_cache and self._cached_graphql_schema:
            return self._cached_graphql_schema

        if self.root_type:
            # Create the root query
            query_mapper = GraphQLTypeMapper(schema=self)
            query: GraphQLType = query_mapper.map(self.root_type)

            if not isinstance(query, GraphQLObjectType):
                raise GraphQLError(f"Query {query} was not a valid ObjectType.")

            # Filter the root query
            filtered_query = GraphQLSchemaReducer.reduce_query(
                query_mapper, query, filters=self.filters
            )

            if query_mapper.validate(filtered_query, evaluate=True):
                schema_args["query"] = filtered_query
                query_types = query_mapper.types()
                registry = query_mapper.registry

            else:
                query_types = set()
                registry = None

            # Create the root mutation
            mutation_mapper = GraphQLTypeMapper(
                as_mutable=True, suffix="Mutable", registry=registry, schema=self
            )
            mutation: GraphQLType = mutation_mapper.map(self.root_type)

            if not isinstance(mutation, GraphQLObjectType):
                raise GraphQLError(f"Mutation {mutation} was not a valid ObjectType.")

            # Filter the root mutation
            filtered_mutation = GraphQLSchemaReducer.reduce_mutation(
                mutation_mapper, mutation
            )

            if mutation_mapper.validate(filtered_mutation, evaluate=True):
                schema_args["mutation"] = filtered_mutation
                mutation_types = mutation_mapper.types()
            else:
                mutation_types = set()

            schema_args["types"] = list(query_types | mutation_types | self.types)
            schema_args["types"] = [
                type_ for type_ in schema_args["types"] if is_named_type(type_)
            ]

            meta = {**query_mapper.meta, **mutation_mapper.meta}

            self.query_mapper = query_mapper
            self.mutation_mapper = mutation_mapper

        # Create a placeholder query (every GraphQL schema must have a query)
        if "query" not in schema_args:
            placeholder = GraphQLField(type_=GraphQLString, resolve=lambda *_: "")
            schema_args["query"] = GraphQLObjectType(
                name="PlaceholderQuery", fields={"placeholder": placeholder}
            )

        schema_directives = [
            *self.query_mapper.schema_directives,
            *self.mutation_mapper.schema_directives,
        ]
        for key, graphql_type, schema_directives in schema_directives:
            key: str
            graphql_type: GraphQLType

            for schema_directive in schema_directives:
                graphql_directive = schema_directive.directive
                self.directives[graphql_directive.name] = graphql_directive

        schema_args["directives"] = self.directives.values()

        schema = GraphQLSchema(**schema_args)

        if self.root_type and issubclass(self.root_type, GraphQLRootTypeDelegate):
            schema = self.root_type.validate_graphql_schema(schema)

        self._cached_graphql_schema = schema, meta

        return schema, meta

    def execute(
        self,
        query,
        variables=None,
        operation_name=None,
        root_value: Any = None,
    ) -> ExecutionResult:
        return self.executor(root_value=root_value).execute(
            query=query,
            variables=variables,
            operation_name=operation_name,
        )

    def executor(
        self,
        root_value: Any = None,
    ) -> GraphQLExecutor:
        schema, meta = self.graphql_schema()

        if callable(self.root_type) and root_value is None:
            root_value = self.root_type()

        ignore_middleware = self.ignore_middleware_during_introspection

        return GraphQLExecutor(
            schema=schema,
            meta=meta,
            root_value=root_value,
            middleware=self.middleware,
            ignore_middleware_during_introspection=ignore_middleware,
            error_protection=self.error_protection
            if self.error_protection is not None
            else self.error_protection,
        )
