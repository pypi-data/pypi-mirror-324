from _typeshed import Incomplete

from .batteryrunners import BatteryRunner as BatteryRunner
from .volumeutils import Recoder as Recoder
from .volumeutils import endian_codes as endian_codes
from .volumeutils import native_code as native_code
from .volumeutils import pretty_mapping as pretty_mapping
from .volumeutils import swapped_code as swapped_code

class WrapStructError(Exception): ...

class WrapStruct:
    template_dtype: Incomplete
    def __init__(
        self,
        binaryblock: Incomplete | None = None,
        endianness: Incomplete | None = None,
        check: bool = True,
    ) -> None: ...
    @classmethod
    def from_fileobj(
        klass, fileobj, endianness: Incomplete | None = None, check: bool = True
    ): ...
    @property
    def binaryblock(self): ...
    def write_to(self, fileobj) -> None: ...
    @property
    def endianness(self): ...
    def copy(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __getitem__(self, item): ...
    def __setitem__(self, item, value) -> None: ...
    def __iter__(self): ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...
    def get(self, k, d: Incomplete | None = None): ...
    def check_fix(
        self, logger: Incomplete | None = None, error_level: Incomplete | None = None
    ) -> None: ...
    @classmethod
    def diagnose_binaryblock(
        klass, binaryblock, endianness: Incomplete | None = None
    ): ...
    @classmethod
    def guessed_endian(self, mapping) -> None: ...
    @classmethod
    def default_structarr(klass, endianness: Incomplete | None = None): ...
    @property
    def structarr(self): ...
    def as_byteswapped(self, endianness: Incomplete | None = None): ...

class LabeledWrapStruct(WrapStruct):
    def get_value_label(self, fieldname): ...
