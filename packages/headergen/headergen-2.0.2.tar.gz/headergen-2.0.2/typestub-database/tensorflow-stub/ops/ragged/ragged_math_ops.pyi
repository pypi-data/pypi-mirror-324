import typing
from tensorflow.python.framework import dtypes as dtypes, errors as errors, ops as ops, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, check_ops as check_ops, gen_ragged_math_ops as gen_ragged_math_ops, map_fn as map_fn, math_ops as math_ops, nn_ops as nn_ops
from tensorflow.python.ops.ragged import ragged_functional_ops as ragged_functional_ops, ragged_tensor as ragged_tensor, segment_id_ops as segment_id_ops
from tensorflow.python.util import dispatch as dispatch
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any

def range(starts, limits: Any | None = ..., deltas: int = ..., dtype: Any | None = ..., name: Any | None = ..., row_splits_dtype=...): ...
def segment_sum(data: ragged_tensor.RaggedOrDense, segment_ids: ragged_tensor.RaggedOrDense, num_segments, name: Any | None = ...): ...
def segment_prod(data: ragged_tensor.RaggedOrDense, segment_ids: ragged_tensor.RaggedOrDense, num_segments, name: Any | None = ...): ...
def segment_min(data: ragged_tensor.RaggedOrDense, segment_ids: ragged_tensor.RaggedOrDense, num_segments, name: Any | None = ...): ...
def segment_max(data: ragged_tensor.RaggedOrDense, segment_ids: ragged_tensor.RaggedOrDense, num_segments, name: Any | None = ...): ...
def segment_mean(data: ragged_tensor.RaggedOrDense, segment_ids: ragged_tensor.RaggedOrDense, num_segments, name: Any | None = ...): ...
def segment_sqrt_n(data: ragged_tensor.RaggedOrDense, segment_ids: ragged_tensor.RaggedOrDense, num_segments, name: Any | None = ...): ...
def ragged_reduce_aggregate(reduce_op, unsorted_segment_op, rt_input, axis, keepdims, separator: Any | None = ..., name: Any | None = ...): ...
def reduce_sum(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def reduce_prod(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def reduce_min(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def reduce_max(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def reduce_mean(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def reduce_variance(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: bool = ..., name: Any | None = ...): ...
def reduce_std(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: bool = ..., name: Any | None = ...): ...
def reduce_all(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def reduce_any(input_tensor: ragged_tensor.Ragged, axis: Any | None = ..., keepdims: Any | None = ..., name: Any | None = ...): ...
def matmul(a: ragged_tensor.RaggedOrDense, b: ragged_tensor.RaggedOrDense, transpose_a: bool = ..., transpose_b: bool = ..., adjoint_a: bool = ..., adjoint_b: bool = ..., a_is_sparse: bool = ..., b_is_sparse: bool = ..., output_type: Any | None = ..., name: Any | None = ...): ...
def softmax(logits: ragged_tensor.Ragged, axis: Any | None = ..., name: Any | None = ...): ...
def add_n(inputs: typing.List[ragged_tensor.RaggedOrDense], name: Any | None = ...): ...
def dropout_v1(x: ragged_tensor.Ragged, keep_prob: Any | None = ..., noise_shape: Any | None = ..., seed: Any | None = ..., name: Any | None = ..., rate: Any | None = ...): ...
def dropout_v2(x: ragged_tensor.Ragged, rate, noise_shape: Any | None = ..., seed: Any | None = ..., name: Any | None = ...): ...
def tensor_equals(self, other: ragged_tensor.RaggedOrDense): ...
def tensor_not_equals(self, other: ragged_tensor.RaggedOrDense): ...
