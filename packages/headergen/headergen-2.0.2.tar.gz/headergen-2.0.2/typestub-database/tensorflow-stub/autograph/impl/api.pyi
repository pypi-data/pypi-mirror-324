from tensorflow.python.autograph import operators as operators, utils as utils
from tensorflow.python.autograph.converters import asserts as asserts, break_statements as break_statements, call_trees as call_trees, conditional_expressions as conditional_expressions, continue_statements as continue_statements, control_flow as control_flow, directives as directives, functions as functions, lists as lists, logical_expressions as logical_expressions, return_statements as return_statements, slices as slices, variables as variables
from tensorflow.python.autograph.core import ag_ctx as ag_ctx, converter as converter, function_wrappers as function_wrappers, unsupported_features_checker as unsupported_features_checker
from tensorflow.python.autograph.impl import conversion as conversion
from tensorflow.python.autograph.lang import special_functions as special_functions
from tensorflow.python.autograph.operators import py_builtins as py_builtins
from tensorflow.python.autograph.pyct import anno as anno, cfg as cfg, error_utils as error_utils, errors as errors, inspect_utils as inspect_utils, origin_info as origin_info, qual_names as qual_names, transpiler as transpiler
from tensorflow.python.autograph.pyct.static_analysis import activity as activity, reaching_definitions as reaching_definitions
from tensorflow.python.eager import function as function
from tensorflow.python.framework import errors_impl as errors_impl
from tensorflow.python.util import tf_decorator as tf_decorator, tf_inspect as tf_inspect, tf_stack as tf_stack
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any

def is_autograph_strict_conversion_mode(): ...

class AutoGraphError(errors.PyCTError): ...
class ConversionError(AutoGraphError): ...
class StagingError(AutoGraphError): ...

class _ErrorMetadata(error_utils.ErrorMetadataBase):
    def create_exception(self, source_error): ...

class StackTraceMapper(tf_stack.StackTraceMapper):
    def __init__(self, converted_fn) -> None: ...
    def get_effective_source_map(self): ...

class PyToTF(transpiler.PyToPy):
    def __init__(self) -> None: ...
    def get_transformed_name(self, node): ...
    def get_extra_locals(self): ...
    def get_caching_key(self, ctx): ...
    def initial_analysis(self, node, ctx): ...
    def transform_ast(self, node, ctx): ...

def autograph_artifact(entity, extras: Any | None = ...): ...
def is_autograph_artifact(entity): ...
def converted_call(f, args, kwargs, caller_fn_scope: Any | None = ..., options: Any | None = ...): ...
def tf_convert(f, ctx, convert_by_default: bool = ..., user_requested: bool = ...): ...
def call_with_unspecified_conversion_status(func): ...
def do_not_convert(func: Any | None = ...): ...
def convert(recursive: bool = ..., optional_features: Any | None = ..., user_requested: bool = ..., conversion_ctx=...): ...
def to_graph(entity, recursive: bool = ..., experimental_optional_features: Any | None = ...): ...
def to_graph_v1(entity, recursive: bool = ..., arg_values: Any | None = ..., arg_types: Any | None = ..., experimental_optional_features: Any | None = ...): ...
def to_code_v1(entity, recursive: bool = ..., arg_values: Any | None = ..., arg_types: Any | None = ..., indentation: str = ..., experimental_optional_features: Any | None = ...): ...
def to_code(entity, recursive: bool = ..., experimental_optional_features: Any | None = ...): ...
