import pyarrow
from pandas._config import get_option as get_option
from pandas._libs import lib as lib
from pandas._libs.arrays import NDArrayBacked as NDArrayBacked
from pandas._typing import Dtype as Dtype, Scalar as Scalar, type_t as type_t
from pandas.compat import pa_version_under1p01 as pa_version_under1p01
from pandas.core import ops as ops
from pandas.core.array_algos import masked_reductions as masked_reductions
from pandas.core.arrays import FloatingArray as FloatingArray, IntegerArray as IntegerArray, PandasArray as PandasArray
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.arrays.floating import FloatingDtype as FloatingDtype
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.base import ExtensionDtype as ExtensionDtype, register_extension_dtype as register_extension_dtype
from pandas.core.dtypes.common import is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_dtype_equal as is_dtype_equal, is_integer_dtype as is_integer_dtype, is_object_dtype as is_object_dtype, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.indexers import check_array_indexer as check_array_indexer
from pandas.core.missing import isna as isna
from typing import Union, Any

class StringDtype(ExtensionDtype):
    name: str
    na_value: Any
    storage: Any
    def __init__(self, storage: Any | None = ...) -> None: ...
    @property
    def type(self) -> type[str]: ...
    @classmethod
    def construct_from_string(cls, string): ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def construct_array_type(self) -> type_t[BaseStringArray]: ...
    def __from_arrow__(self, array: Union[pyarrow.Array, pyarrow.ChunkedArray]) -> BaseStringArray: ...

class BaseStringArray(ExtensionArray): ...

class StringArray(BaseStringArray, PandasArray):
    def __init__(self, values, copy: bool = ...) -> None: ...
    def __arrow_array__(self, type: Any | None = ...): ...
    def __setitem__(self, key, value) -> None: ...
    def astype(self, dtype, copy: bool = ...): ...
    def min(self, axis: Any | None = ..., skipna: bool = ..., **kwargs) -> Scalar: ...
    def max(self, axis: Any | None = ..., skipna: bool = ..., **kwargs) -> Scalar: ...
    def value_counts(self, dropna: bool = ...): ...
    def memory_usage(self, deep: bool = ...) -> int: ...
