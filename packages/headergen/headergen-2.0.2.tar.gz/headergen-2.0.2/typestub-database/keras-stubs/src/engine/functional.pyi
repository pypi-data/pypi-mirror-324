from typing import Any

from keras import backend as backend
from keras.src.engine import base_layer as base_layer
from keras.src.engine import base_layer_utils as base_layer_utils
from keras.src.engine import functional_utils as functional_utils
from keras.src.engine import input_spec as input_spec
from keras.src.engine import training as training_lib
from keras.src.engine import training_utils as training_utils
from keras.src.saving.saved_model import network_serialization as network_serialization
from keras.utils import generic_utils as generic_utils
from keras.utils import tf_inspect as tf_inspect
from keras.utils import tf_utils as tf_utils

class Functional(training_lib.Model):
    def __init__(
        self, inputs, outputs, name: Any | None = ..., trainable: bool = ..., **kwargs
    ) -> None: ...
    @property
    def input(self): ...
    @property
    def input_shape(self): ...
    @property
    def input_spec(self): ...
    @input_spec.setter
    def input_spec(self, value) -> None: ...
    @property
    def output(self): ...
    @property
    def output_shape(self): ...
    def compute_mask(self, inputs, mask): ...
    def call(self, inputs, training: Any | None = ..., mask: Any | None = ...): ...
    def compute_output_shape(self, input_shape): ...
    def get_config(self): ...
    @classmethod
    def from_config(cls, config, custom_objects: Any | None = ...): ...

def connect_ancillary_layers(model, created_layers): ...
def reconstruct_from_config(
    config, custom_objects: Any | None = ..., created_layers: Any | None = ...
): ...
def get_network_config(network, serialize_layer_fn: Any | None = ...): ...
def shape_with_no_batch_size(x): ...

class ModuleWrapper(base_layer.Layer):
    def __init__(self, module, method_name: Any | None = ..., **kwargs) -> None: ...
    def call(self, *args, **kwargs): ...
