import abc
import builtins
import ctypes as ct
import datetime as dt
import os
from abc import abstractmethod
from contextlib import ContextDecorator
from numpy.core._internal import _ctypes
from numpy.core._ufunc_config import _ErrDictOptional, _ErrKind
from numpy.typing import ArrayLike as ArrayLike, DTypeLike as DTypeLike, NBitBase as NBitBase, NDArray as NDArray, _ArrayLikeBool_co, _ArrayLikeComplex_co, _ArrayLikeDT64_co, _ArrayLikeFloat_co, _ArrayLikeInt_co, _ArrayLikeNumber_co, _ArrayLikeObject_co, _ArrayLikeTD64_co, _ArrayLikeUInt_co, _BoolCodes, _ByteCodes, _BytesCodes, _CDoubleCodes, _CLongDoubleCodes, _CSingleCodes, _CharLike_co, _Complex128Codes, _Complex64Codes, _DT64Codes, _DoubleCodes, _Float16Codes, _Float32Codes, _Float64Codes, _FloatLike_co, _GUFunc_Nin2_Nout1, _HalfCodes, _Int16Codes, _Int32Codes, _Int64Codes, _Int8Codes, _IntCCodes, _IntCodes, _IntLike_co, _IntPCodes, _LongDoubleCodes, _LongLongCodes, _NestedSequence, _NumberLike_co, _ObjectCodes, _RecursiveSequence, _ScalarLike_co, _Shape, _ShapeLike, _ShortCodes, _SingleCodes, _StrCodes, _SupportsArray, _SupportsDType, _TD64Codes, _TD64Like_co, _UByteCodes, _UFunc_Nin1_Nout1, _UFunc_Nin1_Nout2, _UFunc_Nin2_Nout1, _UFunc_Nin2_Nout2, _UInt16Codes, _UInt32Codes, _UInt64Codes, _UInt8Codes, _UIntCCodes, _UIntCodes, _UIntPCodes, _ULongLongCodes, _UShortCodes, _VoidCodes, _VoidDTypeLike
from numpy.typing._callable import _BoolBitOp, _BoolDivMod, _BoolMod, _BoolOp, _BoolSub, _BoolTrueDiv, _ComparisonOp, _ComplexOp, _FloatDivMod, _FloatMod, _FloatOp, _IntTrueDiv, _NumberOp, _SignedIntBitOp, _SignedIntDivMod, _SignedIntMod, _SignedIntOp, _TD64Div, _UnsignedIntBitOp, _UnsignedIntDivMod, _UnsignedIntMod, _UnsignedIntOp
from types import TracebackType
from typing import Any, Callable, IO, Iterator, List, Mapping, NoReturn, Optional, Sequence, Tuple, Type, Union, overload
from typing_extensions import Final as Final, Literal as L, Protocol as Protocol, SupportsIndex

__path__: List[str]
__git_version__: str

class MachAr:
    def __init__(self, float_conv: Any = ..., int_conv: Any = ..., float_to_float: Any = ..., float_to_str: Any = ..., title: Any = ...) -> None: ...
    def __getattr__(self, key: str) -> Any: ...

class busdaycalendar:
    def __new__(cls, weekmask: Any = ..., holidays: Any = ...) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class chararray(ndarray[_ShapeType, _DType_co]):
    def __new__(subtype, shape: Any, itemsize: Any = ..., unicode: Any = ..., buffer: Any = ..., offset: Any = ..., strides: Any = ..., order: Any = ...) -> Any: ...
    def __array_finalize__(self, obj) -> None: ...
    def argsort(self, axis=..., kind=..., order=...) -> None: ...
    def capitalize(self) -> None: ...
    def center(self, width, fillchar=...) -> None: ...
    def count(self, sub, start=..., end=...) -> None: ...
    def decode(self, encoding=..., errors=...) -> None: ...
    def encode(self, encoding=..., errors=...) -> None: ...
    def endswith(self, suffix, start=..., end=...) -> None: ...
    def expandtabs(self, tabsize=...) -> None: ...
    def find(self, sub, start=..., end=...) -> None: ...
    def index(self, sub, start=..., end=...) -> None: ...
    def isalnum(self) -> None: ...
    def isalpha(self) -> None: ...
    def isdigit(self) -> None: ...
    def islower(self) -> None: ...
    def isspace(self) -> None: ...
    def istitle(self) -> None: ...
    def isupper(self) -> None: ...
    def join(self, seq) -> None: ...
    def ljust(self, width, fillchar=...) -> None: ...
    def lower(self) -> None: ...
    def lstrip(self, chars=...) -> None: ...
    def partition(self, sep) -> None: ...
    def replace(self, old, new, count=...) -> None: ...
    def rfind(self, sub, start=..., end=...) -> None: ...
    def rindex(self, sub, start=..., end=...) -> None: ...
    def rjust(self, width, fillchar=...) -> None: ...
    def rpartition(self, sep) -> None: ...
    def rsplit(self, sep=..., maxsplit=...) -> None: ...
    def rstrip(self, chars=...) -> None: ...
    def split(self, sep=..., maxsplit=...) -> None: ...
    def splitlines(self, keepends=...) -> None: ...
    def startswith(self, prefix, start=..., end=...) -> None: ...
    def strip(self, chars=...) -> None: ...
    def swapcase(self) -> None: ...
    def title(self) -> None: ...
    def translate(self, table, deletechars=...) -> None: ...
    def upper(self) -> None: ...
    def zfill(self, width) -> None: ...
    def isnumeric(self) -> None: ...
    def isdecimal(self) -> None: ...

class finfo:
    def __new__(cls, dtype: Any) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class format_parser:
    def __init__(self, formats: Any, names: Any, titles: Any, aligned: Any = ..., byteorder: Any = ...) -> None: ...

class iinfo:
    def __init__(self, int_type: Any) -> None: ...
    def __getattr__(self, key: str) -> Any: ...

class matrix(ndarray[_ShapeType, _DType_co]):
    def __new__(subtype, data: Any, dtype: Any = ..., copy: Any = ...) -> Any: ...
    def __array_finalize__(self, obj) -> None: ...
    def __getitem__(self, index) -> None: ...
    def __mul__(self, other) -> None: ...
    def __rmul__(self, other) -> None: ...
    def __imul__(self, other) -> None: ...
    def __pow__(self, other) -> None: ...
    def __ipow__(self, other) -> None: ...
    def __rpow__(self, other) -> None: ...
    def tolist(self) -> None: ...
    def sum(self, axis=..., dtype=..., out=...) -> None: ...
    def squeeze(self, axis=...) -> None: ...
    def flatten(self, order=...) -> None: ...
    def mean(self, axis=..., dtype=..., out=...) -> None: ...
    def std(self, axis=..., dtype=..., out=..., ddof=...) -> None: ...
    def var(self, axis=..., dtype=..., out=..., ddof=...) -> None: ...
    def prod(self, axis=..., dtype=..., out=...) -> None: ...
    def any(self, axis=..., out=...) -> None: ...
    def all(self, axis=..., out=...) -> None: ...
    def max(self, axis=..., out=...) -> None: ...
    def argmax(self, axis=..., out=...) -> None: ...
    def min(self, axis=..., out=...) -> None: ...
    def argmin(self, axis=..., out=...) -> None: ...
    def ptp(self, axis=..., out=...) -> None: ...
    def ravel(self, order=...) -> None: ...
    @property
    def T(self) -> None: ...
    @property
    def I(self) -> None: ...
    @property
    def A(self) -> None: ...
    @property
    def A1(self) -> None: ...
    @property
    def H(self) -> None: ...
    def getT(self) -> None: ...
    def getA(self) -> None: ...
    def getA1(self) -> None: ...
    def getH(self) -> None: ...
    def getI(self) -> None: ...

class memmap(ndarray[_ShapeType, _DType_co]):
    def __new__(subtype, filename: Any, dtype: Any = ..., mode: Any = ..., offset: Any = ..., shape: Any = ..., order: Any = ...) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...

class nditer:
    def __new__(cls, op: Any, flags: Any = ..., op_flags: Any = ..., op_dtypes: Any = ..., order: Any = ..., casting: Any = ..., op_axes: Any = ..., itershape: Any = ..., buffersize: Any = ...) -> Any: ...
    def __getattr__(self, key: str) -> Any: ...
    def __enter__(self) -> nditer: ...
    def __exit__(self, exc_type: Union[None, Type[BaseException]], exc_value: Union[None, BaseException], traceback: Union[None, TracebackType]) -> None: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __next__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __copy__(self) -> nditer: ...
    def __getitem__(self, index: Union[SupportsIndex, slice]) -> Any: ...
    def __setitem__(self, index: Union[SupportsIndex, slice], value: Any) -> None: ...
    def __delitem__(self, key: Union[SupportsIndex, slice]) -> None: ...

class poly1d:
    def __init__(self, c_or_r: Any, r: Any = ..., variable: Any = ...) -> None: ...
    def __call__(self, val: Any) -> Any: ...
    __hash__: Any
    @property
    def coeffs(self) -> None: ...
    @coeffs.setter
    def coeffs(self, value) -> None: ...
    @property
    def c(self) -> None: ...
    @c.setter
    def c(self, value) -> None: ...
    @property
    def coef(self) -> None: ...
    @coef.setter
    def coef(self, value) -> None: ...
    @property
    def coefficients(self) -> None: ...
    @coefficients.setter
    def coefficients(self, value) -> None: ...
    @property
    def variable(self) -> None: ...
    @property
    def order(self) -> None: ...
    @property
    def o(self) -> None: ...
    @property
    def roots(self) -> None: ...
    @property
    def r(self) -> None: ...
    def __array__(self, t=...) -> None: ...
    def __len__(self) -> None: ...
    def __neg__(self) -> None: ...
    def __pos__(self) -> None: ...
    def __mul__(self, other) -> None: ...
    def __rmul__(self, other) -> None: ...
    def __add__(self, other) -> None: ...
    def __radd__(self, other) -> None: ...
    def __pow__(self, val) -> None: ...
    def __sub__(self, other) -> None: ...
    def __rsub__(self, other) -> None: ...
    def __div__(self, other) -> None: ...
    def __truediv__(self, other) -> None: ...
    def __rdiv__(self, other) -> None: ...
    def __rtruediv__(self, other) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __getitem__(self, val) -> None: ...
    def __setitem__(self, key, val) -> None: ...
    def __iter__(self): ...
    def integ(self, m=..., k=...) -> None: ...
    def deriv(self, m=...) -> None: ...

class recarray(ndarray[_ShapeType, _DType_co]):
    def __new__(subtype, shape: Any, dtype: Any = ..., buf: Any = ..., offset: Any = ..., strides: Any = ..., formats: Any = ..., names: Any = ..., titles: Any = ..., byteorder: Any = ..., aligned: Any = ..., order: Any = ...) -> Any: ...
    def __array_finalize__(self, obj) -> None: ...
    def __getattribute__(self, attr) -> None: ...
    def __setattr__(self, attr, val) -> None: ...
    def __getitem__(self, indx) -> None: ...
    def field(self, attr, val=...) -> None: ...

class record(void):
    def __getattribute__(self, attr) -> None: ...
    def __setattr__(self, attr, val) -> None: ...
    def __getitem__(self, indx) -> None: ...
    def pprint(self) -> None: ...

class vectorize:
    pyfunc: Any
    cache: Any
    signature: Any
    otypes: Any
    excluded: Any
    __doc__: Any
    def __init__(self, pyfunc, otypes: Any = ..., doc: Any = ..., excluded: Any = ..., cache: Any = ..., signature: Any = ...) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

def asmatrix(data, dtype=...) -> None: ...
def asscalar(a) -> None: ...
def cumproduct(*args, **kwargs) -> None: ...
def histogram(a, bins=..., range=..., normed=..., weights=..., density=...) -> None: ...
def histogram_bin_edges(a, bins=..., range=..., weights=...) -> None: ...
def histogramdd(sample, bins=..., range=..., normed=..., weights=..., density=...) -> None: ...
def mat(data, dtype=...) -> None: ...
def max(a, axis=..., out=..., keepdims=..., initial=..., where=...) -> None: ...
def min(a, axis=..., out=..., keepdims=..., initial=..., where=...) -> None: ...
def product(*args, **kwargs) -> None: ...
def round(a, decimals=..., out=...) -> None: ...
def round_(a, decimals=..., out=...) -> None: ...
def show_config() -> None: ...
@overload
def arange(stop, dtype=..., *, like=...) -> None: ...
@overload
def arange(start, stop, step=..., dtype=..., *, like=...) -> None: ...
def busday_count(begindates, enddates, weekmask=..., holidays=..., busdaycal=..., out=...) -> None: ...
def busday_offset(dates, offsets, roll=..., weekmask=..., holidays=..., busdaycal=..., out=...) -> None: ...
def can_cast(from_, to, casting=...) -> None: ...
def compare_chararrays(a, b, cmp_op, rstrip) -> None: ...
def concatenate(__a, axis=..., out=..., dtype=..., casting=...) -> None: ...
def copyto(dst, src, casting=..., where=...) -> None: ...
def datetime_as_string(arr, unit=..., timezone=..., casting=...) -> None: ...
def datetime_data(__dtype) -> None: ...
def dot(a, b, out=...) -> None: ...
def frombuffer(buffer, dtype=..., count=..., offset=..., *, like=...) -> None: ...
def fromfile(file, dtype=..., count=..., sep=..., offset=..., *, like=...) -> None: ...
def fromiter(iter, dtype, count=..., *, like=...) -> None: ...
def frompyfunc(func, nin, nout, *identity) -> None: ...
def fromstring(string, dtype=..., count=..., sep=..., *, like=...) -> None: ...
def geterrobj() -> None: ...
def inner(a, b) -> None: ...
def is_busday(dates, weekmask=..., holidays=..., busdaycal=..., out=...) -> None: ...
def lexsort(keys, axis=...) -> None: ...
def may_share_memory(a, b, max_work=...) -> None: ...
def min_scalar_type(a) -> None: ...
def nested_iters(*args, **kwargs) -> None: ...
def promote_types(type1, type2) -> None: ...
def putmask(a, mask, values) -> None: ...
def result_type(*arrays_and_dtypes) -> None: ...
def seterrobj(errobj) -> None: ...
def shares_memory(a, b, max_work=...) -> None: ...
def vdot(a, b) -> None: ...
@overload
def where(__condition) -> None: ...
@overload
def where(__condition, __x, __y) -> None: ...

class dtype:
    @overload
    def __new__(cls, dtype: Type[_DTypeScalar_co], align: bool = ..., copy: bool = ...) -> dtype[_DTypeScalar_co]: ...
    @overload
    def __new__(cls, dtype: Type[bool], align: bool = ..., copy: bool = ...) -> dtype[bool_]: ...
    @overload
    def __new__(cls, dtype: Type[int], align: bool = ..., copy: bool = ...) -> dtype[int_]: ...
    @overload
    def __new__(cls, dtype: Optional[Type[float]], align: bool = ..., copy: bool = ...) -> dtype[float_]: ...
    @overload
    def __new__(cls, dtype: Type[complex], align: bool = ..., copy: bool = ...) -> dtype[complex_]: ...
    @overload
    def __new__(cls, dtype: Type[builtins.str], align: bool = ..., copy: bool = ...) -> dtype[str_]: ...
    @overload
    def __new__(cls, dtype: Type[bytes], align: bool = ..., copy: bool = ...) -> dtype[bytes_]: ...
    @overload
    def __new__(cls, dtype: Union[_UInt8Codes, Type[ct.c_uint8]], align: bool = ..., copy: bool = ...) -> dtype[uint8]: ...
    @overload
    def __new__(cls, dtype: Union[_UInt16Codes, Type[ct.c_uint16]], align: bool = ..., copy: bool = ...) -> dtype[uint16]: ...
    @overload
    def __new__(cls, dtype: Union[_UInt32Codes, Type[ct.c_uint32]], align: bool = ..., copy: bool = ...) -> dtype[uint32]: ...
    @overload
    def __new__(cls, dtype: Union[_UInt64Codes, Type[ct.c_uint64]], align: bool = ..., copy: bool = ...) -> dtype[uint64]: ...
    @overload
    def __new__(cls, dtype: Union[_UByteCodes, Type[ct.c_ubyte]], align: bool = ..., copy: bool = ...) -> dtype[ubyte]: ...
    @overload
    def __new__(cls, dtype: Union[_UShortCodes, Type[ct.c_ushort]], align: bool = ..., copy: bool = ...) -> dtype[ushort]: ...
    @overload
    def __new__(cls, dtype: Union[_UIntCCodes, Type[ct.c_uint]], align: bool = ..., copy: bool = ...) -> dtype[uintc]: ...
    @overload
    def __new__(cls, dtype: Union[_UIntPCodes, Type[ct.c_void_p], Type[ct.c_size_t]], align: bool = ..., copy: bool = ...) -> dtype[uintp]: ...
    @overload
    def __new__(cls, dtype: Union[_UIntCodes, Type[ct.c_ulong]], align: bool = ..., copy: bool = ...) -> dtype[uint]: ...
    @overload
    def __new__(cls, dtype: Union[_ULongLongCodes, Type[ct.c_ulonglong]], align: bool = ..., copy: bool = ...) -> dtype[ulonglong]: ...
    @overload
    def __new__(cls, dtype: Union[_Int8Codes, Type[ct.c_int8]], align: bool = ..., copy: bool = ...) -> dtype[int8]: ...
    @overload
    def __new__(cls, dtype: Union[_Int16Codes, Type[ct.c_int16]], align: bool = ..., copy: bool = ...) -> dtype[int16]: ...
    @overload
    def __new__(cls, dtype: Union[_Int32Codes, Type[ct.c_int32]], align: bool = ..., copy: bool = ...) -> dtype[int32]: ...
    @overload
    def __new__(cls, dtype: Union[_Int64Codes, Type[ct.c_int64]], align: bool = ..., copy: bool = ...) -> dtype[int64]: ...
    @overload
    def __new__(cls, dtype: Union[_ByteCodes, Type[ct.c_byte]], align: bool = ..., copy: bool = ...) -> dtype[byte]: ...
    @overload
    def __new__(cls, dtype: Union[_ShortCodes, Type[ct.c_short]], align: bool = ..., copy: bool = ...) -> dtype[short]: ...
    @overload
    def __new__(cls, dtype: Union[_IntCCodes, Type[ct.c_int]], align: bool = ..., copy: bool = ...) -> dtype[intc]: ...
    @overload
    def __new__(cls, dtype: Union[_IntPCodes, Type[ct.c_ssize_t]], align: bool = ..., copy: bool = ...) -> dtype[intp]: ...
    @overload
    def __new__(cls, dtype: Union[_IntCodes, Type[ct.c_long]], align: bool = ..., copy: bool = ...) -> dtype[int_]: ...
    @overload
    def __new__(cls, dtype: Union[_LongLongCodes, Type[ct.c_longlong]], align: bool = ..., copy: bool = ...) -> dtype[longlong]: ...
    @overload
    def __new__(cls, dtype: _Float16Codes, align: bool = ..., copy: bool = ...) -> dtype[float16]: ...
    @overload
    def __new__(cls, dtype: _Float32Codes, align: bool = ..., copy: bool = ...) -> dtype[float32]: ...
    @overload
    def __new__(cls, dtype: _Float64Codes, align: bool = ..., copy: bool = ...) -> dtype[float64]: ...
    @overload
    def __new__(cls, dtype: _HalfCodes, align: bool = ..., copy: bool = ...) -> dtype[half]: ...
    @overload
    def __new__(cls, dtype: Union[_SingleCodes, Type[ct.c_float]], align: bool = ..., copy: bool = ...) -> dtype[single]: ...
    @overload
    def __new__(cls, dtype: Union[_DoubleCodes, Type[ct.c_double]], align: bool = ..., copy: bool = ...) -> dtype[double]: ...
    @overload
    def __new__(cls, dtype: Union[_LongDoubleCodes, Type[ct.c_longdouble]], align: bool = ..., copy: bool = ...) -> dtype[longdouble]: ...
    @overload
    def __new__(cls, dtype: _Complex64Codes, align: bool = ..., copy: bool = ...) -> dtype[complex64]: ...
    @overload
    def __new__(cls, dtype: _Complex128Codes, align: bool = ..., copy: bool = ...) -> dtype[complex128]: ...
    @overload
    def __new__(cls, dtype: _CSingleCodes, align: bool = ..., copy: bool = ...) -> dtype[csingle]: ...
    @overload
    def __new__(cls, dtype: _CDoubleCodes, align: bool = ..., copy: bool = ...) -> dtype[cdouble]: ...
    @overload
    def __new__(cls, dtype: _CLongDoubleCodes, align: bool = ..., copy: bool = ...) -> dtype[clongdouble]: ...
    @overload
    def __new__(cls, dtype: Union[_BoolCodes, Type[ct.c_bool]], align: bool = ..., copy: bool = ...) -> dtype[bool_]: ...
    @overload
    def __new__(cls, dtype: _TD64Codes, align: bool = ..., copy: bool = ...) -> dtype[timedelta64]: ...
    @overload
    def __new__(cls, dtype: _DT64Codes, align: bool = ..., copy: bool = ...) -> dtype[datetime64]: ...
    @overload
    def __new__(cls, dtype: _StrCodes, align: bool = ..., copy: bool = ...) -> dtype[str_]: ...
    @overload
    def __new__(cls, dtype: Union[_BytesCodes, Type[ct.c_char]], align: bool = ..., copy: bool = ...) -> dtype[bytes_]: ...
    @overload
    def __new__(cls, dtype: _VoidCodes, align: bool = ..., copy: bool = ...) -> dtype[void]: ...
    @overload
    def __new__(cls, dtype: Union[_ObjectCodes, Type[ct.py_object]], align: bool = ..., copy: bool = ...) -> dtype[object_]: ...
    @overload
    def __new__(cls, dtype: dtype[_DTypeScalar_co], align: bool = ..., copy: bool = ...) -> dtype[_DTypeScalar_co]: ...
    @overload
    def __new__(cls, dtype: _SupportsDType[dtype[_DTypeScalar_co]], align: bool = ..., copy: bool = ...) -> dtype[_DTypeScalar_co]: ...
    @overload
    def __new__(cls, dtype: builtins.str, align: bool = ..., copy: bool = ...) -> dtype[Any]: ...
    @overload
    def __new__(cls, dtype: _VoidDTypeLike, align: bool = ..., copy: bool = ...) -> dtype[void]: ...
    @overload
    def __new__(cls, dtype: Type[object], align: bool = ..., copy: bool = ...) -> dtype[object_]: ...
    @overload
    def __getitem__(self, key: List[builtins.str]) -> dtype[void]: ...
    @overload
    def __getitem__(self, key: Union[builtins.str, int]) -> dtype[Any]: ...
    @overload
    def __mul__(self, value: L[0]) -> None: ...
    @overload
    def __mul__(self, value: L[1]) -> _DType: ...
    @overload
    def __mul__(self, value: int) -> dtype[void]: ...
    def __rmul__(self, value: int) -> Any: ...
    def __gt__(self, other: DTypeLike) -> bool: ...
    def __ge__(self, other: DTypeLike) -> bool: ...
    def __lt__(self, other: DTypeLike) -> bool: ...
    def __le__(self, other: DTypeLike) -> bool: ...
    @property
    def alignment(self) -> int: ...
    @property
    def base(self) -> _DType: ...
    @property
    def byteorder(self) -> builtins.str: ...
    @property
    def char(self) -> builtins.str: ...
    @property
    def descr(self) -> List[Union[Tuple[builtins.str, builtins.str], Tuple[builtins.str, builtins.str, _Shape]]]: ...
    @property
    def fields(self) -> Optional[Mapping[builtins.str, Union[Tuple[dtype[Any], int], Tuple[dtype[Any], int, Any]]]]: ...
    @property
    def flags(self) -> int: ...
    @property
    def hasobject(self) -> bool: ...
    @property
    def isbuiltin(self) -> int: ...
    @property
    def isnative(self) -> bool: ...
    @property
    def isalignedstruct(self) -> bool: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def kind(self) -> builtins.str: ...
    @property
    def metadata(self) -> Optional[Mapping[builtins.str, Any]]: ...
    @property
    def name(self) -> builtins.str: ...
    @property
    def names(self) -> Optional[Tuple[str, ...]]: ...
    @property
    def num(self) -> int: ...
    @property
    def shape(self) -> _Shape: ...
    @property
    def ndim(self) -> int: ...
    @property
    def subdtype(self) -> Optional[Tuple[_DType, _Shape]]: ...
    def newbyteorder(self, __new_order: _ByteOrder = ...) -> _DType: ...
    @property
    def str(self) -> builtins.str: ...
    @property
    def type(self) -> Type[_DTypeScalar_co]: ...

class _flagsobj:
    aligned: bool
    updateifcopy: bool
    writeable: bool
    writebackifcopy: bool
    @property
    def behaved(self) -> bool: ...
    @property
    def c_contiguous(self) -> bool: ...
    @property
    def carray(self) -> bool: ...
    @property
    def contiguous(self) -> bool: ...
    @property
    def f_contiguous(self) -> bool: ...
    @property
    def farray(self) -> bool: ...
    @property
    def fnc(self) -> bool: ...
    @property
    def forc(self) -> bool: ...
    @property
    def fortran(self) -> bool: ...
    @property
    def num(self) -> int: ...
    @property
    def owndata(self) -> bool: ...
    def __getitem__(self, key: str) -> bool: ...
    def __setitem__(self, key: str, value: bool) -> None: ...

class flatiter:
    @property
    def base(self) -> _NdArraySubClass: ...
    @property
    def coords(self) -> _Shape: ...
    @property
    def index(self) -> int: ...
    def copy(self) -> _NdArraySubClass: ...
    def __iter__(self) -> _FlatIterSelf: ...
    def __next__(self) -> _ScalarType: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: Union[int, integer]) -> _ScalarType: ...
    @overload
    def __getitem__(self, key: Union[_ArrayLikeInt, slice, ellipsis]) -> _NdArraySubClass: ...
    @overload
    def __array__(self, __dtype: None = ...) -> ndarray[Any, _DType]: ...
    @overload
    def __array__(self, __dtype: _DType) -> ndarray[Any, _DType]: ...

class _ArrayOrScalarCommon:
    @property
    def T(self) -> _ArraySelf: ...
    @property
    def data(self) -> memoryview: ...
    @property
    def flags(self) -> _flagsobj: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __bytes__(self) -> bytes: ...
    def __copy__(self) -> _ArraySelf: ...
    def __deepcopy__(self, __memo: Optional[dict] = ...) -> _ArraySelf: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def copy(self, order: _OrderKACF = ...) -> _ArraySelf: ...
    def dump(self, file: str) -> None: ...
    def dumps(self) -> bytes: ...
    def tobytes(self, order: _OrderKACF = ...) -> bytes: ...
    def tofile(self, fid: Union[IO[bytes], str, bytes, os.PathLike[Any]], sep: str = ..., format: str = ...) -> None: ...
    def tolist(self) -> Any: ...
    def __getitem__(self, key) -> Any: ...
    @property
    def __array_interface__(self) -> None: ...
    @property
    def __array_priority__(self) -> None: ...
    @property
    def __array_struct__(self) -> None: ...
    def __array_wrap__(array, context=...) -> None: ...
    @overload
    def all(self, axis: None = ..., out: None = ..., keepdims: L[False] = ...) -> bool_: ...
    @overload
    def all(self, axis: Optional[_ShapeLike] = ..., out: None = ..., keepdims: bool = ...) -> Any: ...
    @overload
    def all(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ..., keepdims: bool = ...) -> _NdArraySubClass: ...
    @overload
    def any(self, axis: None = ..., out: None = ..., keepdims: L[False] = ...) -> bool_: ...
    @overload
    def any(self, axis: Optional[_ShapeLike] = ..., out: None = ..., keepdims: bool = ...) -> Any: ...
    @overload
    def any(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ..., keepdims: bool = ...) -> _NdArraySubClass: ...
    @overload
    def argmax(self, axis: None = ..., out: None = ...) -> intp: ...
    @overload
    def argmax(self, axis: _ShapeLike = ..., out: None = ...) -> Any: ...
    @overload
    def argmax(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    @overload
    def argmin(self, axis: None = ..., out: None = ...) -> intp: ...
    @overload
    def argmin(self, axis: _ShapeLike = ..., out: None = ...) -> Any: ...
    @overload
    def argmin(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    def argsort(self, axis: Optional[SupportsIndex] = ..., kind: Optional[_SortKind] = ..., order: Union[None, str, Sequence[str]] = ...) -> ndarray: ...
    @overload
    def choose(self, choices: ArrayLike, out: None = ..., mode: _ModeKind = ...) -> ndarray: ...
    @overload
    def choose(self, choices: ArrayLike, out: _NdArraySubClass = ..., mode: _ModeKind = ...) -> _NdArraySubClass: ...
    @overload
    def clip(self, min: ArrayLike = ..., max: Optional[ArrayLike] = ..., out: None = ..., **kwargs: Any) -> ndarray: ...
    @overload
    def clip(self, min: None = ..., max: ArrayLike = ..., out: None = ..., **kwargs: Any) -> ndarray: ...
    @overload
    def clip(self, min: ArrayLike = ..., max: Optional[ArrayLike] = ..., out: _NdArraySubClass = ..., **kwargs: Any) -> _NdArraySubClass: ...
    @overload
    def clip(self, min: None = ..., max: ArrayLike = ..., out: _NdArraySubClass = ..., **kwargs: Any) -> _NdArraySubClass: ...
    @overload
    def compress(self, a: ArrayLike, axis: Optional[SupportsIndex] = ..., out: None = ...) -> ndarray: ...
    @overload
    def compress(self, a: ArrayLike, axis: Optional[SupportsIndex] = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    def conj(self) -> _ArraySelf: ...
    def conjugate(self) -> _ArraySelf: ...
    @overload
    def cumprod(self, axis: Optional[SupportsIndex] = ..., dtype: DTypeLike = ..., out: None = ...) -> ndarray: ...
    @overload
    def cumprod(self, axis: Optional[SupportsIndex] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    @overload
    def cumsum(self, axis: Optional[SupportsIndex] = ..., dtype: DTypeLike = ..., out: None = ...) -> ndarray: ...
    @overload
    def cumsum(self, axis: Optional[SupportsIndex] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    @overload
    def max(self, axis: Optional[_ShapeLike] = ..., out: None = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> Any: ...
    @overload
    def max(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> _NdArraySubClass: ...
    @overload
    def mean(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: None = ..., keepdims: bool = ...) -> Any: ...
    @overload
    def mean(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ..., keepdims: bool = ...) -> _NdArraySubClass: ...
    @overload
    def min(self, axis: Optional[_ShapeLike] = ..., out: None = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> Any: ...
    @overload
    def min(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> _NdArraySubClass: ...
    def newbyteorder(self, __new_order: _ByteOrder = ...) -> _ArraySelf: ...
    @overload
    def prod(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: None = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> Any: ...
    @overload
    def prod(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> _NdArraySubClass: ...
    @overload
    def ptp(self, axis: Optional[_ShapeLike] = ..., out: None = ..., keepdims: bool = ...) -> Any: ...
    @overload
    def ptp(self, axis: Optional[_ShapeLike] = ..., out: _NdArraySubClass = ..., keepdims: bool = ...) -> _NdArraySubClass: ...
    @overload
    def round(self, decimals: SupportsIndex = ..., out: None = ...) -> _ArraySelf: ...
    @overload
    def round(self, decimals: SupportsIndex = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    @overload
    def std(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: None = ..., ddof: int = ..., keepdims: bool = ...) -> Any: ...
    @overload
    def std(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ..., ddof: int = ..., keepdims: bool = ...) -> _NdArraySubClass: ...
    @overload
    def sum(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: None = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> Any: ...
    @overload
    def sum(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ..., keepdims: bool = ..., initial: _NumberLike_co = ..., where: _ArrayLikeBool_co = ...) -> _NdArraySubClass: ...
    @overload
    def var(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: None = ..., ddof: int = ..., keepdims: bool = ...) -> Any: ...
    @overload
    def var(self, axis: Optional[_ShapeLike] = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ..., ddof: int = ..., keepdims: bool = ...) -> _NdArraySubClass: ...

class _SupportsItem:
    def item(self, __args: Any) -> _T_co: ...

class _SupportsReal:
    @property
    def real(self) -> _T_co: ...

class _SupportsImag:
    @property
    def imag(self) -> _T_co: ...

class ndarray(_ArrayOrScalarCommon):
    @property
    def base(self) -> Optional[ndarray]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def real(self) -> ndarray[_ShapeType, _dtype[_ScalarType]]: ...
    @real.setter
    def real(self, value: ArrayLike) -> None: ...
    @property
    def imag(self) -> ndarray[_ShapeType, _dtype[_ScalarType]]: ...
    @imag.setter
    def imag(self, value: ArrayLike) -> None: ...
    def __new__(cls, shape: _ShapeLike, dtype: DTypeLike = ..., buffer: _BufferType = ..., offset: int = ..., strides: _ShapeLike = ..., order: _OrderKACF = ...) -> _ArraySelf: ...
    @overload
    def __array__(self, __dtype: None = ...) -> ndarray[Any, _DType_co]: ...
    @overload
    def __array__(self, __dtype: _DType) -> ndarray[Any, _DType]: ...
    @property
    def ctypes(self) -> _ctypes[int]: ...
    @property
    def shape(self) -> _Shape: ...
    @shape.setter
    def shape(self, value: _ShapeLike) -> None: ...
    @property
    def strides(self) -> _Shape: ...
    @strides.setter
    def strides(self, value: _ShapeLike) -> None: ...
    def byteswap(self, inplace: bool = ...) -> _ArraySelf: ...
    @overload
    def clip(self, min: ArrayLike = ..., max: Optional[ArrayLike] = ..., out: None = ..., **kwargs: Any) -> ndarray: ...
    @overload
    def clip(self, min: None = ..., max: ArrayLike = ..., out: None = ..., **kwargs: Any) -> ndarray: ...
    @overload
    def clip(self, min: ArrayLike = ..., max: Optional[ArrayLike] = ..., out: _NdArraySubClass = ..., **kwargs: Any) -> _NdArraySubClass: ...
    @overload
    def clip(self, min: None = ..., max: ArrayLike = ..., out: _NdArraySubClass = ..., **kwargs: Any) -> _NdArraySubClass: ...
    def fill(self, value: Any) -> None: ...
    @property
    def flat(self) -> flatiter[_NdArraySubClass]: ...
    @overload
    def item(self, *args: SupportsIndex) -> _T: ...
    @overload
    def item(self, __args: Tuple[SupportsIndex, ...]) -> _T: ...
    @overload
    def itemset(self, __value: Any) -> None: ...
    @overload
    def itemset(self, __item: _ShapeLike, __value: Any) -> None: ...
    @overload
    def resize(self, __new_shape: _ShapeLike, *, refcheck: bool = ...) -> None: ...
    @overload
    def resize(self, *new_shape: SupportsIndex, refcheck: bool = ...) -> None: ...
    def setflags(self, write: bool = ..., align: bool = ..., uic: bool = ...) -> None: ...
    def squeeze(self, axis: Union[SupportsIndex, Tuple[SupportsIndex, ...]] = ...) -> ndarray[Any, _DType_co]: ...
    def swapaxes(self, axis1: SupportsIndex, axis2: SupportsIndex) -> ndarray[Any, _DType_co]: ...
    @overload
    def transpose(self, __axes: _ShapeLike) -> _ArraySelf: ...
    @overload
    def transpose(self, *axes: SupportsIndex) -> _ArraySelf: ...
    def argpartition(self, kth: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ..., kind: _PartitionKind = ..., order: Union[None, str, Sequence[str]] = ...) -> ndarray[Any, _dtype[intp]]: ...
    def diagonal(self, offset: SupportsIndex = ..., axis1: SupportsIndex = ..., axis2: SupportsIndex = ...) -> ndarray[Any, _DType_co]: ...
    @overload
    def dot(self, b: _ScalarLike_co, out: None = ...) -> ndarray: ...
    @overload
    def dot(self, b: ArrayLike, out: None = ...) -> Any: ...
    @overload
    def dot(self, b: ArrayLike, out: _NdArraySubClass) -> _NdArraySubClass: ...
    def nonzero(self) -> Tuple[ndarray[Any, _dtype[intp]], ...]: ...
    def partition(self, kth: _ArrayLikeInt_co, axis: SupportsIndex = ..., kind: _PartitionKind = ..., order: Union[None, str, Sequence[str]] = ...) -> None: ...
    def put(self, ind: _ArrayLikeInt_co, v: ArrayLike, mode: _ModeKind = ...) -> None: ...
    @overload
    def searchsorted(self, v: _ScalarLike_co, side: _SortSide = ..., sorter: Optional[_ArrayLikeInt_co] = ...) -> intp: ...
    @overload
    def searchsorted(self, v: ArrayLike, side: _SortSide = ..., sorter: Optional[_ArrayLikeInt_co] = ...) -> ndarray[Any, _dtype[intp]]: ...
    def setfield(self, val: ArrayLike, dtype: DTypeLike, offset: SupportsIndex = ...) -> None: ...
    def sort(self, axis: SupportsIndex = ..., kind: Optional[_SortKind] = ..., order: Union[None, str, Sequence[str]] = ...) -> None: ...
    @overload
    def trace(self, offset: SupportsIndex = ..., axis1: SupportsIndex = ..., axis2: SupportsIndex = ..., dtype: DTypeLike = ..., out: None = ...) -> Any: ...
    @overload
    def trace(self, offset: SupportsIndex = ..., axis1: SupportsIndex = ..., axis2: SupportsIndex = ..., dtype: DTypeLike = ..., out: _NdArraySubClass = ...) -> _NdArraySubClass: ...
    @overload
    def take(self, indices: _IntLike_co, axis: Optional[SupportsIndex] = ..., out: None = ..., mode: _ModeKind = ...) -> _ScalarType: ...
    @overload
    def take(self, indices: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ..., out: None = ..., mode: _ModeKind = ...) -> ndarray[Any, _DType_co]: ...
    @overload
    def take(self, indices: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ..., out: _NdArraySubClass = ..., mode: _ModeKind = ...) -> _NdArraySubClass: ...
    def repeat(self, repeats: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ...) -> ndarray[Any, _DType_co]: ...
    def flatten(self, order: _OrderKACF = ...) -> ndarray[Any, _DType_co]: ...
    def ravel(self, order: _OrderKACF = ...) -> ndarray[Any, _DType_co]: ...
    @overload
    def reshape(self, __shape: _ShapeLike, *, order: _OrderACF = ...) -> ndarray[Any, _DType_co]: ...
    @overload
    def reshape(self, *shape: SupportsIndex, order: _OrderACF = ...) -> ndarray[Any, _DType_co]: ...
    @overload
    def astype(self, dtype: _DTypeLike[_ScalarType], order: _OrderKACF = ..., casting: _Casting = ..., subok: bool = ..., copy: bool = ...) -> NDArray[_ScalarType]: ...
    @overload
    def astype(self, dtype: DTypeLike, order: _OrderKACF = ..., casting: _Casting = ..., subok: bool = ..., copy: bool = ...) -> NDArray[Any]: ...
    @overload
    def view(self) -> _ArraySelf: ...
    @overload
    def view(self, type: Type[_NdArraySubClass]) -> _NdArraySubClass: ...
    @overload
    def view(self, dtype: _DTypeLike[_ScalarType]) -> NDArray[_ScalarType]: ...
    @overload
    def view(self, dtype: DTypeLike) -> NDArray[Any]: ...
    @overload
    def view(self, dtype: DTypeLike, type: Type[_NdArraySubClass]) -> _NdArraySubClass: ...
    @overload
    def getfield(self, dtype: _DTypeLike[_ScalarType], offset: SupportsIndex = ...) -> NDArray[_ScalarType]: ...
    @overload
    def getfield(self, dtype: DTypeLike, offset: SupportsIndex = ...) -> NDArray[Any]: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __index__(self) -> int: ...
    def __len__(self) -> int: ...
    def __setitem__(self, key, value) -> None: ...
    def __iter__(self) -> Any: ...
    def __contains__(self, key) -> bool: ...
    @overload
    def __lt__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __lt__(self, other: _ArrayLikeNumber_co) -> NDArray[bool_]: ...
    @overload
    def __lt__(self, other: _ArrayLikeTD64_co) -> NDArray[bool_]: ...
    @overload
    def __lt__(self, other: _ArrayLikeDT64_co) -> NDArray[bool_]: ...
    @overload
    def __lt__(self, other: Any) -> NDArray[bool_]: ...
    @overload
    def __lt__(self, other: _ArrayLikeObject_co) -> NDArray[bool_]: ...
    @overload
    def __lt__(self, other: _RecursiveSequence) -> NDArray[bool_]: ...
    @overload
    def __le__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __le__(self, other: _ArrayLikeNumber_co) -> NDArray[bool_]: ...
    @overload
    def __le__(self, other: _ArrayLikeTD64_co) -> NDArray[bool_]: ...
    @overload
    def __le__(self, other: _ArrayLikeDT64_co) -> NDArray[bool_]: ...
    @overload
    def __le__(self, other: Any) -> NDArray[bool_]: ...
    @overload
    def __le__(self, other: _ArrayLikeObject_co) -> NDArray[bool_]: ...
    @overload
    def __le__(self, other: _RecursiveSequence) -> NDArray[bool_]: ...
    @overload
    def __gt__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __gt__(self, other: _ArrayLikeNumber_co) -> NDArray[bool_]: ...
    @overload
    def __gt__(self, other: _ArrayLikeTD64_co) -> NDArray[bool_]: ...
    @overload
    def __gt__(self, other: _ArrayLikeDT64_co) -> NDArray[bool_]: ...
    @overload
    def __gt__(self, other: Any) -> NDArray[bool_]: ...
    @overload
    def __gt__(self, other: _ArrayLikeObject_co) -> NDArray[bool_]: ...
    @overload
    def __gt__(self, other: _RecursiveSequence) -> NDArray[bool_]: ...
    @overload
    def __ge__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ge__(self, other: _ArrayLikeNumber_co) -> NDArray[bool_]: ...
    @overload
    def __ge__(self, other: _ArrayLikeTD64_co) -> NDArray[bool_]: ...
    @overload
    def __ge__(self, other: _ArrayLikeDT64_co) -> NDArray[bool_]: ...
    @overload
    def __ge__(self, other: Any) -> NDArray[bool_]: ...
    @overload
    def __ge__(self, other: _ArrayLikeObject_co) -> NDArray[bool_]: ...
    @overload
    def __ge__(self, other: _RecursiveSequence) -> NDArray[bool_]: ...
    @overload
    def __abs__(self) -> NDArray[bool_]: ...
    @overload
    def __abs__(self) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __abs__(self) -> NDArray[_NumberType]: ...
    @overload
    def __abs__(self) -> NDArray[timedelta64]: ...
    @overload
    def __abs__(self) -> Any: ...
    @overload
    def __invert__(self) -> NDArray[bool_]: ...
    @overload
    def __invert__(self) -> NDArray[_IntType]: ...
    @overload
    def __invert__(self) -> Any: ...
    @overload
    def __pos__(self) -> NDArray[_NumberType]: ...
    @overload
    def __pos__(self) -> NDArray[timedelta64]: ...
    @overload
    def __pos__(self) -> Any: ...
    @overload
    def __neg__(self) -> NDArray[_NumberType]: ...
    @overload
    def __neg__(self) -> NDArray[timedelta64]: ...
    @overload
    def __neg__(self) -> Any: ...
    @overload
    def __matmul__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __matmul__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __matmul__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __matmul__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __matmul__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __matmul__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __matmul__(self, other: Any) -> Any: ...
    @overload
    def __matmul__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __matmul__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rmatmul__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rmatmul__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __rmatmul__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rmatmul__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rmatmul__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rmatmul__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __rmatmul__(self, other: Any) -> Any: ...
    @overload
    def __rmatmul__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rmatmul__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __mod__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __mod__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __mod__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __mod__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __mod__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __mod__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[timedelta64]: ...
    @overload
    def __mod__(self, other: Any) -> Any: ...
    @overload
    def __mod__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __mod__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rmod__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rmod__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __rmod__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rmod__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rmod__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rmod__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[timedelta64]: ...
    @overload
    def __rmod__(self, other: Any) -> Any: ...
    @overload
    def __rmod__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rmod__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __divmod__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __divmod__(self, other: _ArrayLikeBool_co) -> _2Tuple[NDArray[int8]]: ...
    @overload
    def __divmod__(self, other: _ArrayLikeUInt_co) -> _2Tuple[NDArray[unsignedinteger[Any]]]: ...
    @overload
    def __divmod__(self, other: _ArrayLikeInt_co) -> _2Tuple[NDArray[signedinteger[Any]]]: ...
    @overload
    def __divmod__(self, other: _ArrayLikeFloat_co) -> _2Tuple[NDArray[floating[Any]]]: ...
    @overload
    def __divmod__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> Tuple[NDArray[int64], NDArray[timedelta64]]: ...
    @overload
    def __divmod__(self, other: _RecursiveSequence) -> _2Tuple[Any]: ...
    @overload
    def __rdivmod__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rdivmod__(self, other: _ArrayLikeBool_co) -> _2Tuple[NDArray[int8]]: ...
    @overload
    def __rdivmod__(self, other: _ArrayLikeUInt_co) -> _2Tuple[NDArray[unsignedinteger[Any]]]: ...
    @overload
    def __rdivmod__(self, other: _ArrayLikeInt_co) -> _2Tuple[NDArray[signedinteger[Any]]]: ...
    @overload
    def __rdivmod__(self, other: _ArrayLikeFloat_co) -> _2Tuple[NDArray[floating[Any]]]: ...
    @overload
    def __rdivmod__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> Tuple[NDArray[int64], NDArray[timedelta64]]: ...
    @overload
    def __rdivmod__(self, other: _RecursiveSequence) -> _2Tuple[Any]: ...
    @overload
    def __add__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __add__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __add__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __add__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __add__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __add__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __add__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __add__(self, other: _ArrayLikeDT64_co) -> NDArray[datetime64]: ...
    @overload
    def __add__(self, other: _ArrayLikeTD64_co) -> NDArray[datetime64]: ...
    @overload
    def __add__(self, other: Any) -> Any: ...
    @overload
    def __add__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __add__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __radd__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __radd__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __radd__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __radd__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __radd__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __radd__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __radd__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __radd__(self, other: _ArrayLikeDT64_co) -> NDArray[datetime64]: ...
    @overload
    def __radd__(self, other: _ArrayLikeTD64_co) -> NDArray[datetime64]: ...
    @overload
    def __radd__(self, other: Any) -> Any: ...
    @overload
    def __radd__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __radd__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __sub__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __sub__(self, other: _ArrayLikeBool_co) -> NoReturn: ...
    @overload
    def __sub__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __sub__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __sub__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __sub__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __sub__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __sub__(self, other: _ArrayLikeTD64_co) -> NDArray[datetime64]: ...
    @overload
    def __sub__(self, other: _ArrayLikeDT64_co) -> NDArray[timedelta64]: ...
    @overload
    def __sub__(self, other: Any) -> Any: ...
    @overload
    def __sub__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __sub__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rsub__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rsub__(self, other: _ArrayLikeBool_co) -> NoReturn: ...
    @overload
    def __rsub__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rsub__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rsub__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rsub__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __rsub__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __rsub__(self, other: _ArrayLikeDT64_co) -> NDArray[datetime64]: ...
    @overload
    def __rsub__(self, other: _ArrayLikeDT64_co) -> NDArray[timedelta64]: ...
    @overload
    def __rsub__(self, other: Any) -> Any: ...
    @overload
    def __rsub__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rsub__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __mul__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __mul__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __mul__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __mul__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __mul__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __mul__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __mul__(self, other: _ArrayLikeFloat_co) -> NDArray[timedelta64]: ...
    @overload
    def __mul__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __mul__(self, other: Any) -> Any: ...
    @overload
    def __mul__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __mul__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rmul__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rmul__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __rmul__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rmul__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rmul__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rmul__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __rmul__(self, other: _ArrayLikeFloat_co) -> NDArray[timedelta64]: ...
    @overload
    def __rmul__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __rmul__(self, other: Any) -> Any: ...
    @overload
    def __rmul__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rmul__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __floordiv__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __floordiv__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[int64]: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeBool_co) -> NoReturn: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeFloat_co) -> NDArray[timedelta64]: ...
    @overload
    def __floordiv__(self, other: Any) -> Any: ...
    @overload
    def __floordiv__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __floordiv__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rfloordiv__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __rfloordiv__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[int64]: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeTD64_co) -> NoReturn: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __rfloordiv__(self, other: Any) -> Any: ...
    @overload
    def __rfloordiv__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rfloordiv__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __pow__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __pow__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __pow__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __pow__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __pow__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __pow__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __pow__(self, other: Any) -> Any: ...
    @overload
    def __pow__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __pow__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rpow__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rpow__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __rpow__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rpow__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rpow__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rpow__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __rpow__(self, other: Any) -> Any: ...
    @overload
    def __rpow__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rpow__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __truediv__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __truediv__(self, other: _ArrayInt_co) -> NDArray[float64]: ...
    @overload
    def __truediv__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __truediv__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __truediv__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[float64]: ...
    @overload
    def __truediv__(self, other: _ArrayLikeBool_co) -> NoReturn: ...
    @overload
    def __truediv__(self, other: _ArrayLikeFloat_co) -> NDArray[timedelta64]: ...
    @overload
    def __truediv__(self, other: Any) -> Any: ...
    @overload
    def __truediv__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __truediv__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rtruediv__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rtruediv__(self, other: _ArrayInt_co) -> NDArray[float64]: ...
    @overload
    def __rtruediv__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[Any]]: ...
    @overload
    def __rtruediv__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[Any, Any]]: ...
    @overload
    def __rtruediv__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[float64]: ...
    @overload
    def __rtruediv__(self, other: _ArrayLikeTD64_co) -> NoReturn: ...
    @overload
    def __rtruediv__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __rtruediv__(self, other: Any) -> Any: ...
    @overload
    def __rtruediv__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rtruediv__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __lshift__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __lshift__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __lshift__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __lshift__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __lshift__(self, other: Any) -> Any: ...
    @overload
    def __lshift__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __lshift__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rlshift__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rlshift__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __rlshift__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rlshift__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rlshift__(self, other: Any) -> Any: ...
    @overload
    def __rlshift__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rlshift__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rshift__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rshift__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __rshift__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rshift__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rshift__(self, other: Any) -> Any: ...
    @overload
    def __rshift__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rshift__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rrshift__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rrshift__(self, other: _ArrayLikeBool_co) -> NDArray[int8]: ...
    @overload
    def __rrshift__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rrshift__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rrshift__(self, other: Any) -> Any: ...
    @overload
    def __rrshift__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rrshift__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __and__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __and__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __and__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __and__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __and__(self, other: Any) -> Any: ...
    @overload
    def __and__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __and__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rand__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rand__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __rand__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rand__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rand__(self, other: Any) -> Any: ...
    @overload
    def __rand__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rand__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __xor__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __xor__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __xor__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __xor__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __xor__(self, other: Any) -> Any: ...
    @overload
    def __xor__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __xor__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __rxor__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __rxor__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __rxor__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __rxor__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __rxor__(self, other: Any) -> Any: ...
    @overload
    def __rxor__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __rxor__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __or__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __or__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __or__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __or__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __or__(self, other: Any) -> Any: ...
    @overload
    def __or__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __or__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __ror__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ror__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __ror__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[Any]]: ...
    @overload
    def __ror__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[Any]]: ...
    @overload
    def __ror__(self, other: Any) -> Any: ...
    @overload
    def __ror__(self, other: _ArrayLikeObject_co) -> Any: ...
    @overload
    def __ror__(self, other: _RecursiveSequence) -> Any: ...
    @overload
    def __iadd__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __iadd__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __iadd__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __iadd__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __iadd__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __iadd__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[_NBit1, _NBit1]]: ...
    @overload
    def __iadd__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __iadd__(self, other: _ArrayLikeTD64_co) -> NDArray[datetime64]: ...
    @overload
    def __iadd__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __iadd__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __isub__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __isub__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __isub__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __isub__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __isub__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[_NBit1, _NBit1]]: ...
    @overload
    def __isub__(self, other: _ArrayLikeTD64_co) -> NDArray[timedelta64]: ...
    @overload
    def __isub__(self, other: _ArrayLikeTD64_co) -> NDArray[datetime64]: ...
    @overload
    def __isub__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __isub__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __imul__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __imul__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __imul__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __imul__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __imul__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __imul__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[_NBit1, _NBit1]]: ...
    @overload
    def __imul__(self, other: _ArrayLikeFloat_co) -> NDArray[timedelta64]: ...
    @overload
    def __imul__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __imul__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __itruediv__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __itruediv__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __itruediv__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[_NBit1, _NBit1]]: ...
    @overload
    def __itruediv__(self, other: _ArrayLikeBool_co) -> NoReturn: ...
    @overload
    def __itruediv__(self, other: _ArrayLikeInt_co) -> NDArray[timedelta64]: ...
    @overload
    def __itruediv__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __itruediv__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __ifloordiv__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ifloordiv__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __ifloordiv__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __ifloordiv__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __ifloordiv__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[_NBit1, _NBit1]]: ...
    @overload
    def __ifloordiv__(self, other: _ArrayLikeBool_co) -> NoReturn: ...
    @overload
    def __ifloordiv__(self, other: _ArrayLikeInt_co) -> NDArray[timedelta64]: ...
    @overload
    def __ifloordiv__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __ifloordiv__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __ipow__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ipow__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __ipow__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __ipow__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __ipow__(self, other: _ArrayLikeComplex_co) -> NDArray[complexfloating[_NBit1, _NBit1]]: ...
    @overload
    def __ipow__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __ipow__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __imod__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __imod__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __imod__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __imod__(self, other: _ArrayLikeFloat_co) -> NDArray[floating[_NBit1]]: ...
    @overload
    def __imod__(self, other: _NestedSequence[_SupportsArray[_dtype[timedelta64]]]) -> NDArray[timedelta64]: ...
    @overload
    def __imod__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __imod__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __ilshift__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ilshift__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __ilshift__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __ilshift__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __ilshift__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __irshift__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __irshift__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __irshift__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __irshift__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __irshift__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __iand__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __iand__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __iand__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __iand__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __iand__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __iand__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __ixor__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ixor__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __ixor__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __ixor__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __ixor__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __ixor__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @overload
    def __ior__(self, other: _NestedSequence[Union[str, bytes]]) -> NoReturn: ...
    @overload
    def __ior__(self, other: _ArrayLikeBool_co) -> NDArray[bool_]: ...
    @overload
    def __ior__(self, other: _ArrayLikeUInt_co) -> NDArray[unsignedinteger[_NBit1]]: ...
    @overload
    def __ior__(self, other: _ArrayLikeInt_co) -> NDArray[signedinteger[_NBit1]]: ...
    @overload
    def __ior__(self, other: Any) -> NDArray[object_]: ...
    @overload
    def __ior__(self, other: _RecursiveSequence) -> NDArray[_ScalarType]: ...
    @property
    def dtype(self) -> _DType_co: ...

class generic(_ArrayOrScalarCommon, metaclass=abc.ABCMeta):
    @abstractmethod
    def __init__(self, *args: Any, **kwargs: Any): ...
    @overload
    def __array__(self, __dtype: None = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    @overload
    def __array__(self, __dtype: _DType) -> ndarray[Any, _DType]: ...
    @property
    def base(self) -> None: ...
    @property
    def ndim(self) -> L[0]: ...
    @property
    def size(self) -> L[1]: ...
    @property
    def shape(self) -> Tuple: ...
    @property
    def strides(self) -> Tuple: ...
    def byteswap(self, inplace: L[False] = ...) -> _ScalarType: ...
    @property
    def flat(self) -> flatiter[ndarray[Any, _dtype[_ScalarType]]]: ...
    @overload
    def astype(self, dtype: _DTypeLike[_ScalarType], order: _OrderKACF = ..., casting: _Casting = ..., subok: bool = ..., copy: bool = ...) -> _ScalarType: ...
    @overload
    def astype(self, dtype: DTypeLike, order: _OrderKACF = ..., casting: _Casting = ..., subok: bool = ..., copy: bool = ...) -> Any: ...
    @overload
    def view(self, type: Type[ndarray[Any, Any]] = ...) -> _ScalarType: ...
    @overload
    def view(self, dtype: _DTypeLike[_ScalarType], type: Type[ndarray[Any, Any]] = ...) -> _ScalarType: ...
    @overload
    def view(self, dtype: DTypeLike, type: Type[ndarray[Any, Any]] = ...) -> Any: ...
    @overload
    def getfield(self, dtype: _DTypeLike[_ScalarType], offset: SupportsIndex = ...) -> _ScalarType: ...
    @overload
    def getfield(self, dtype: DTypeLike, offset: SupportsIndex = ...) -> Any: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> Any: ...
    @overload
    def take(self, indices: _IntLike_co, axis: Optional[SupportsIndex] = ..., out: None = ..., mode: _ModeKind = ...) -> _ScalarType: ...
    @overload
    def take(self, indices: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ..., out: None = ..., mode: _ModeKind = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    @overload
    def take(self, indices: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ..., out: _NdArraySubClass = ..., mode: _ModeKind = ...) -> _NdArraySubClass: ...
    def repeat(self, repeats: _ArrayLikeInt_co, axis: Optional[SupportsIndex] = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    def flatten(self, order: _OrderKACF = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    def ravel(self, order: _OrderKACF = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    @overload
    def reshape(self, __shape: _ShapeLike, *, order: _OrderACF = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    @overload
    def reshape(self, *shape: SupportsIndex, order: _OrderACF = ...) -> ndarray[Any, _dtype[_ScalarType]]: ...
    def squeeze(self, axis: Union[L[0], Tuple] = ...) -> _ScalarType: ...
    def transpose(self, __axes: Tuple = ...) -> _ScalarType: ...
    @property
    def dtype(self) -> _dtype[_ScalarType]: ...

class number(generic, metaclass=abc.ABCMeta):
    @property
    def real(self) -> _ArraySelf: ...
    @property
    def imag(self) -> _ArraySelf: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __neg__(self) -> _ArraySelf: ...
    def __pos__(self) -> _ArraySelf: ...
    def __abs__(self) -> _ArraySelf: ...
    __add__: _NumberOp
    __radd__: _NumberOp
    __sub__: _NumberOp
    __rsub__: _NumberOp
    __mul__: _NumberOp
    __rmul__: _NumberOp
    __floordiv__: _NumberOp
    __rfloordiv__: _NumberOp
    __pow__: _NumberOp
    __rpow__: _NumberOp
    __truediv__: _NumberOp
    __rtruediv__: _NumberOp
    __lt__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
    __le__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
    __gt__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
    __ge__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]

class bool_(generic):
    def __init__(self, __value: object = ...) -> None: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> bool: ...
    def tolist(self) -> bool: ...
    @property
    def real(self) -> _ArraySelf: ...
    @property
    def imag(self) -> _ArraySelf: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __abs__(self) -> _ArraySelf: ...
    __add__: _BoolOp[bool_]
    __radd__: _BoolOp[bool_]
    __sub__: _BoolSub
    __rsub__: _BoolSub
    __mul__: _BoolOp[bool_]
    __rmul__: _BoolOp[bool_]
    __floordiv__: _BoolOp[int8]
    __rfloordiv__: _BoolOp[int8]
    __pow__: _BoolOp[int8]
    __rpow__: _BoolOp[int8]
    __truediv__: _BoolTrueDiv
    __rtruediv__: _BoolTrueDiv
    def __invert__(self) -> bool_: ...
    __lshift__: _BoolBitOp[int8]
    __rlshift__: _BoolBitOp[int8]
    __rshift__: _BoolBitOp[int8]
    __rrshift__: _BoolBitOp[int8]
    __and__: _BoolBitOp[bool_]
    __rand__: _BoolBitOp[bool_]
    __xor__: _BoolBitOp[bool_]
    __rxor__: _BoolBitOp[bool_]
    __or__: _BoolBitOp[bool_]
    __ror__: _BoolBitOp[bool_]
    __mod__: _BoolMod
    __rmod__: _BoolMod
    __divmod__: _BoolDivMod
    __rdivmod__: _BoolDivMod
    __lt__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
    __le__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
    __gt__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
    __ge__: _ComparisonOp[_NumberLike_co, _ArrayLikeNumber_co]
bool8 = bool_

class object_(generic):
    def __init__(self, __value: object = ...) -> None: ...
    @property
    def real(self) -> _ArraySelf: ...
    @property
    def imag(self) -> _ArraySelf: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
object0 = object_

class _DatetimeScalar:
    @property
    def day(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def year(self) -> int: ...

class datetime64(generic):
    @overload
    def __init__(self, __value: Union[None, datetime64, _CharLike_co, _DatetimeScalar] = ..., __format: Union[_CharLike_co, Tuple[_CharLike_co, _IntLike_co]] = ...) -> None: ...
    @overload
    def __init__(self, __value: int, __format: Union[_CharLike_co, Tuple[_CharLike_co, _IntLike_co]]) -> None: ...
    def __add__(self, other: _TD64Like_co) -> datetime64: ...
    def __radd__(self, other: _TD64Like_co) -> datetime64: ...
    @overload
    def __sub__(self, other: datetime64) -> timedelta64: ...
    @overload
    def __sub__(self, other: _TD64Like_co) -> datetime64: ...
    def __rsub__(self, other: datetime64) -> timedelta64: ...
    __lt__: _ComparisonOp[datetime64, _ArrayLikeDT64_co]
    __le__: _ComparisonOp[datetime64, _ArrayLikeDT64_co]
    __gt__: _ComparisonOp[datetime64, _ArrayLikeDT64_co]
    __ge__: _ComparisonOp[datetime64, _ArrayLikeDT64_co]

class integer(number[_NBit1], metaclass=abc.ABCMeta):
    @property
    def numerator(self) -> _ScalarType: ...
    @property
    def denominator(self) -> L[1]: ...
    @overload
    def __round__(self, ndigits: None = ...) -> int: ...
    @overload
    def __round__(self, ndigits: SupportsIndex) -> _ScalarType: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> int: ...
    def tolist(self) -> int: ...
    def __index__(self) -> int: ...
    __truediv__: _IntTrueDiv[_NBit1]
    __rtruediv__: _IntTrueDiv[_NBit1]
    def __mod__(self, value: _IntLike_co) -> integer: ...
    def __rmod__(self, value: _IntLike_co) -> integer: ...
    def __invert__(self) -> _IntType: ...
    def __lshift__(self, other: _IntLike_co) -> integer: ...
    def __rlshift__(self, other: _IntLike_co) -> integer: ...
    def __rshift__(self, other: _IntLike_co) -> integer: ...
    def __rrshift__(self, other: _IntLike_co) -> integer: ...
    def __and__(self, other: _IntLike_co) -> integer: ...
    def __rand__(self, other: _IntLike_co) -> integer: ...
    def __or__(self, other: _IntLike_co) -> integer: ...
    def __ror__(self, other: _IntLike_co) -> integer: ...
    def __xor__(self, other: _IntLike_co) -> integer: ...
    def __rxor__(self, other: _IntLike_co) -> integer: ...

class signedinteger(integer[_NBit1]):
    def __init__(self, __value: _IntValue = ...) -> None: ...
    __add__: _SignedIntOp[_NBit1]
    __radd__: _SignedIntOp[_NBit1]
    __sub__: _SignedIntOp[_NBit1]
    __rsub__: _SignedIntOp[_NBit1]
    __mul__: _SignedIntOp[_NBit1]
    __rmul__: _SignedIntOp[_NBit1]
    __floordiv__: _SignedIntOp[_NBit1]
    __rfloordiv__: _SignedIntOp[_NBit1]
    __pow__: _SignedIntOp[_NBit1]
    __rpow__: _SignedIntOp[_NBit1]
    __lshift__: _SignedIntBitOp[_NBit1]
    __rlshift__: _SignedIntBitOp[_NBit1]
    __rshift__: _SignedIntBitOp[_NBit1]
    __rrshift__: _SignedIntBitOp[_NBit1]
    __and__: _SignedIntBitOp[_NBit1]
    __rand__: _SignedIntBitOp[_NBit1]
    __xor__: _SignedIntBitOp[_NBit1]
    __rxor__: _SignedIntBitOp[_NBit1]
    __or__: _SignedIntBitOp[_NBit1]
    __ror__: _SignedIntBitOp[_NBit1]
    __mod__: _SignedIntMod[_NBit1]
    __rmod__: _SignedIntMod[_NBit1]
    __divmod__: _SignedIntDivMod[_NBit1]
    __rdivmod__: _SignedIntDivMod[_NBit1]

int8: Any
int16: Any
int32: Any
int64: Any
byte: Any
short: Any
intc: Any
intp: Any
int0: Any
int_: Any
longlong: Any

class timedelta64(generic):
    def __init__(self, __value: Union[None, int, _CharLike_co, dt.timedelta, timedelta64] = ..., __format: Union[_CharLike_co, Tuple[_CharLike_co, _IntLike_co]] = ...) -> None: ...
    @property
    def numerator(self) -> _ScalarType: ...
    @property
    def denominator(self) -> L[1]: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __neg__(self) -> _ArraySelf: ...
    def __pos__(self) -> _ArraySelf: ...
    def __abs__(self) -> _ArraySelf: ...
    def __add__(self, other: _TD64Like_co) -> timedelta64: ...
    def __radd__(self, other: _TD64Like_co) -> timedelta64: ...
    def __sub__(self, other: _TD64Like_co) -> timedelta64: ...
    def __rsub__(self, other: _TD64Like_co) -> timedelta64: ...
    def __mul__(self, other: _FloatLike_co) -> timedelta64: ...
    def __rmul__(self, other: _FloatLike_co) -> timedelta64: ...
    __truediv__: _TD64Div[float64]
    __floordiv__: _TD64Div[int64]
    def __rtruediv__(self, other: timedelta64) -> float64: ...
    def __rfloordiv__(self, other: timedelta64) -> int64: ...
    def __mod__(self, other: timedelta64) -> timedelta64: ...
    def __rmod__(self, other: timedelta64) -> timedelta64: ...
    def __divmod__(self, other: timedelta64) -> Tuple[int64, timedelta64]: ...
    def __rdivmod__(self, other: timedelta64) -> Tuple[int64, timedelta64]: ...
    __lt__: _ComparisonOp[_TD64Like_co, _ArrayLikeTD64_co]
    __le__: _ComparisonOp[_TD64Like_co, _ArrayLikeTD64_co]
    __gt__: _ComparisonOp[_TD64Like_co, _ArrayLikeTD64_co]
    __ge__: _ComparisonOp[_TD64Like_co, _ArrayLikeTD64_co]

class unsignedinteger(integer[_NBit1]):
    def __init__(self, __value: _IntValue = ...) -> None: ...
    __add__: _UnsignedIntOp[_NBit1]
    __radd__: _UnsignedIntOp[_NBit1]
    __sub__: _UnsignedIntOp[_NBit1]
    __rsub__: _UnsignedIntOp[_NBit1]
    __mul__: _UnsignedIntOp[_NBit1]
    __rmul__: _UnsignedIntOp[_NBit1]
    __floordiv__: _UnsignedIntOp[_NBit1]
    __rfloordiv__: _UnsignedIntOp[_NBit1]
    __pow__: _UnsignedIntOp[_NBit1]
    __rpow__: _UnsignedIntOp[_NBit1]
    __lshift__: _UnsignedIntBitOp[_NBit1]
    __rlshift__: _UnsignedIntBitOp[_NBit1]
    __rshift__: _UnsignedIntBitOp[_NBit1]
    __rrshift__: _UnsignedIntBitOp[_NBit1]
    __and__: _UnsignedIntBitOp[_NBit1]
    __rand__: _UnsignedIntBitOp[_NBit1]
    __xor__: _UnsignedIntBitOp[_NBit1]
    __rxor__: _UnsignedIntBitOp[_NBit1]
    __or__: _UnsignedIntBitOp[_NBit1]
    __ror__: _UnsignedIntBitOp[_NBit1]
    __mod__: _UnsignedIntMod[_NBit1]
    __rmod__: _UnsignedIntMod[_NBit1]
    __divmod__: _UnsignedIntDivMod[_NBit1]
    __rdivmod__: _UnsignedIntDivMod[_NBit1]

uint8: Any
uint16: Any
uint32: Any
uint64: Any
ubyte: Any
ushort: Any
uintc: Any
uintp: Any
uint0: Any
uint: Any
ulonglong: Any

class inexact(number[_NBit1], metaclass=abc.ABCMeta):
    def __getnewargs__(self) -> Tuple[float, ...]: ...

class floating(inexact[_NBit1]):
    def __init__(self, __value: _FloatValue = ...) -> None: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> float: ...
    def tolist(self) -> float: ...
    def is_integer(self) -> bool: ...
    def hex(self) -> str: ...
    @classmethod
    def fromhex(cls, __string: str) -> float64: ...
    def as_integer_ratio(self) -> Tuple[int, int]: ...
    def __trunc__(self) -> int: ...
    def __getnewargs__(self) -> Tuple[float]: ...
    def __getformat__(self, __typestr: L[double, float]) -> str: ...
    @overload
    def __round__(self, ndigits: None = ...) -> int: ...
    @overload
    def __round__(self, ndigits: SupportsIndex) -> _ScalarType: ...
    __add__: _FloatOp[_NBit1]
    __radd__: _FloatOp[_NBit1]
    __sub__: _FloatOp[_NBit1]
    __rsub__: _FloatOp[_NBit1]
    __mul__: _FloatOp[_NBit1]
    __rmul__: _FloatOp[_NBit1]
    __truediv__: _FloatOp[_NBit1]
    __rtruediv__: _FloatOp[_NBit1]
    __floordiv__: _FloatOp[_NBit1]
    __rfloordiv__: _FloatOp[_NBit1]
    __pow__: _FloatOp[_NBit1]
    __rpow__: _FloatOp[_NBit1]
    __mod__: _FloatMod[_NBit1]
    __rmod__: _FloatMod[_NBit1]
    __divmod__: _FloatDivMod[_NBit1]
    __rdivmod__: _FloatDivMod[_NBit1]

float16: Any
float32: Any
float64: Any
half: Any
single: Any
double: Any
float_: Any
longdouble: Any
longfloat: Any

class complexfloating(inexact[_NBit1]):
    def __init__(self, __value: _ComplexValue = ...) -> None: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> complex: ...
    def tolist(self) -> complex: ...
    @property
    def real(self) -> floating[_NBit1]: ...
    @property
    def imag(self) -> floating[_NBit2]: ...
    def __abs__(self) -> floating[_NBit1]: ...
    def __getnewargs__(self) -> Tuple[float, float]: ...
    __add__: _ComplexOp[_NBit1]
    __radd__: _ComplexOp[_NBit1]
    __sub__: _ComplexOp[_NBit1]
    __rsub__: _ComplexOp[_NBit1]
    __mul__: _ComplexOp[_NBit1]
    __rmul__: _ComplexOp[_NBit1]
    __truediv__: _ComplexOp[_NBit1]
    __rtruediv__: _ComplexOp[_NBit1]
    __floordiv__: _ComplexOp[_NBit1]
    __rfloordiv__: _ComplexOp[_NBit1]
    __pow__: _ComplexOp[_NBit1]
    __rpow__: _ComplexOp[_NBit1]

complex64: Any
complex128: Any
csingle: Any
singlecomplex: Any
cdouble: Any
complex_: Any
cfloat: Any
clongdouble: Any
clongfloat: Any
longcomplex: Any

class flexible(generic, metaclass=abc.ABCMeta): ...

class void(flexible):
    def __init__(self, __value: Union[_IntLike_co, bytes]) -> None: ...
    @property
    def real(self) -> _ArraySelf: ...
    @property
    def imag(self) -> _ArraySelf: ...
    def setfield(self, val: ArrayLike, dtype: DTypeLike, offset: int = ...) -> None: ...
    def __getitem__(self, key: SupportsIndex) -> Any: ...
    def __setitem__(self, key: SupportsIndex, value: ArrayLike) -> None: ...
void0 = void

class character(flexible, metaclass=abc.ABCMeta):
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

class bytes_(character, bytes):
    @overload
    def __init__(self, __value: object = ...) -> None: ...
    @overload
    def __init__(self, __value: str, encoding: str = ..., errors: str = ...) -> None: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> bytes: ...
    def tolist(self) -> bytes: ...
string_ = bytes_
bytes0 = bytes_

class str_(character, str):
    @overload
    def __init__(self, __value: object = ...) -> None: ...
    @overload
    def __init__(self, __value: bytes, encoding: str = ..., errors: str = ...) -> None: ...
    def item(self, __args: Union[L[0], Tuple, Tuple[L[0]]] = ...) -> str: ...
    def tolist(self) -> str: ...
unicode_ = str_
str0 = str_

def array(object: object, dtype: DTypeLike = ..., *, copy: bool = ..., order: _OrderKACF = ..., subok: bool = ..., ndmin: int = ..., like: ArrayLike = ...) -> ndarray: ...
def zeros(shape: _ShapeLike, dtype: DTypeLike = ..., order: _OrderCF = ..., *, like: ArrayLike = ...) -> ndarray: ...
def empty(shape: _ShapeLike, dtype: DTypeLike = ..., order: _OrderCF = ..., *, like: ArrayLike = ...) -> ndarray: ...

Inf: Final[float]
Infinity: Final[float]
NAN: Final[float]
NINF: Final[float]
NZERO: Final[float]
NaN: Final[float]
PINF: Final[float]
PZERO: Final[float]
e: Final[float]
euler_gamma: Final[float]
inf: Final[float]
infty: Final[float]
nan: Final[float]
pi: Final[float]
ALLOW_THREADS: Final[int]
BUFSIZE: Final[int]
CLIP: Final[int]
ERR_CALL: Final[int]
ERR_DEFAULT: Final[int]
ERR_IGNORE: Final[int]
ERR_LOG: Final[int]
ERR_PRINT: Final[int]
ERR_RAISE: Final[int]
ERR_WARN: Final[int]
FLOATING_POINT_SUPPORT: Final[int]
FPE_DIVIDEBYZERO: Final[int]
FPE_INVALID: Final[int]
FPE_OVERFLOW: Final[int]
FPE_UNDERFLOW: Final[int]
MAXDIMS: Final[int]
MAY_SHARE_BOUNDS: Final[int]
MAY_SHARE_EXACT: Final[int]
RAISE: Final[int]
SHIFT_DIVIDEBYZERO: Final[int]
SHIFT_INVALID: Final[int]
SHIFT_OVERFLOW: Final[int]
SHIFT_UNDERFLOW: Final[int]
UFUNC_BUFSIZE_DEFAULT: Final[int]
WRAP: Final[int]
tracemalloc_domain: Final[int]
little_endian: Final[bool]
True_: Final[bool_]
False_: Final[bool_]
UFUNC_PYVALS_NAME: Final[str]
newaxis: None

class ufunc:
    @property
    def __name__(self) -> str: ...
    @property
    def __doc__(self) -> str: ...
    __call__: Callable[..., Any]
    @property
    def nin(self) -> int: ...
    @property
    def nout(self) -> int: ...
    @property
    def nargs(self) -> int: ...
    @property
    def ntypes(self) -> int: ...
    @property
    def types(self) -> List[str]: ...
    @property
    def identity(self) -> Any: ...
    @property
    def signature(self) -> Optional[str]: ...
    reduce: Any
    accumulate: Any
    outer: Any
    at: Any

absolute: _UFunc_Nin1_Nout1[L[absolute], L[20], None]
add: _UFunc_Nin2_Nout1[L[add], L[22], L[0]]
arccos: _UFunc_Nin1_Nout1[L[arccos], L[8], None]
arccosh: _UFunc_Nin1_Nout1[L[arccosh], L[8], None]
arcsin: _UFunc_Nin1_Nout1[L[arcsin], L[8], None]
arcsinh: _UFunc_Nin1_Nout1[L[arcsinh], L[8], None]
arctan2: _UFunc_Nin2_Nout1[L[arctan2], L[5], None]
arctan: _UFunc_Nin1_Nout1[L[arctan], L[8], None]
arctanh: _UFunc_Nin1_Nout1[L[arctanh], L[8], None]
bitwise_and: _UFunc_Nin2_Nout1[L[bitwise_and], L[12], L[-1]]
bitwise_not: _UFunc_Nin1_Nout1[L[invert], L[12], None]
bitwise_or: _UFunc_Nin2_Nout1[L[bitwise_or], L[12], L[0]]
bitwise_xor: _UFunc_Nin2_Nout1[L[bitwise_xor], L[12], L[0]]
cbrt: _UFunc_Nin1_Nout1[L[cbrt], L[5], None]
ceil: _UFunc_Nin1_Nout1[L[ceil], L[7], None]
conj: _UFunc_Nin1_Nout1[L[conjugate], L[18], None]
conjugate: _UFunc_Nin1_Nout1[L[conjugate], L[18], None]
copysign: _UFunc_Nin2_Nout1[L[copysign], L[4], None]
cos: _UFunc_Nin1_Nout1[L[cos], L[9], None]
cosh: _UFunc_Nin1_Nout1[L[cosh], L[8], None]
deg2rad: _UFunc_Nin1_Nout1[L[deg2rad], L[5], None]
degrees: _UFunc_Nin1_Nout1[L[degrees], L[5], None]
divide: _UFunc_Nin2_Nout1[L[true_divide], L[11], None]
divmod: _UFunc_Nin2_Nout2[L[divmod], L[15], None]
equal: _UFunc_Nin2_Nout1[L[equal], L[23], None]
exp2: _UFunc_Nin1_Nout1[L[exp2], L[8], None]
exp: _UFunc_Nin1_Nout1[L[exp], L[10], None]
expm1: _UFunc_Nin1_Nout1[L[expm1], L[8], None]
fabs: _UFunc_Nin1_Nout1[L[fabs], L[5], None]
float_power: _UFunc_Nin2_Nout1[L[float_power], L[4], None]
floor: _UFunc_Nin1_Nout1[L[floor], L[7], None]
floor_divide: _UFunc_Nin2_Nout1[L[floor_divide], L[21], None]
fmax: _UFunc_Nin2_Nout1[L[fmax], L[21], None]
fmin: _UFunc_Nin2_Nout1[L[fmin], L[21], None]
fmod: _UFunc_Nin2_Nout1[L[fmod], L[15], None]
frexp: _UFunc_Nin1_Nout2[L[frexp], L[4], None]
gcd: _UFunc_Nin2_Nout1[L[gcd], L[11], L[0]]
greater: _UFunc_Nin2_Nout1[L[greater], L[23], None]
greater_equal: _UFunc_Nin2_Nout1[L[greater_equal], L[23], None]
heaviside: _UFunc_Nin2_Nout1[L[heaviside], L[4], None]
hypot: _UFunc_Nin2_Nout1[L[hypot], L[5], L[0]]
invert: _UFunc_Nin1_Nout1[L[invert], L[12], None]
isfinite: _UFunc_Nin1_Nout1[L[isfinite], L[20], None]
isinf: _UFunc_Nin1_Nout1[L[isinf], L[20], None]
isnan: _UFunc_Nin1_Nout1[L[isnan], L[20], None]
isnat: _UFunc_Nin1_Nout1[L[isnat], L[2], None]
lcm: _UFunc_Nin2_Nout1[L[lcm], L[11], None]
ldexp: _UFunc_Nin2_Nout1[L[ldexp], L[8], None]
left_shift: _UFunc_Nin2_Nout1[L[left_shift], L[11], None]
less: _UFunc_Nin2_Nout1[L[less], L[23], None]
less_equal: _UFunc_Nin2_Nout1[L[less_equal], L[23], None]
log10: _UFunc_Nin1_Nout1[L[log10], L[8], None]
log1p: _UFunc_Nin1_Nout1[L[log1p], L[8], None]
log2: _UFunc_Nin1_Nout1[L[log2], L[8], None]
log: _UFunc_Nin1_Nout1[L[log], L[10], None]
logaddexp2: _UFunc_Nin2_Nout1[L[logaddexp2], L[4], float]
logaddexp: _UFunc_Nin2_Nout1[L[logaddexp], L[4], float]
logical_and: _UFunc_Nin2_Nout1[L[logical_and], L[20], L[True]]
logical_not: _UFunc_Nin1_Nout1[L[logical_not], L[20], None]
logical_or: _UFunc_Nin2_Nout1[L[logical_or], L[20], L[False]]
logical_xor: _UFunc_Nin2_Nout1[L[logical_xor], L[19], L[False]]
matmul: _GUFunc_Nin2_Nout1[L[matmul], L[19], None]
maximum: _UFunc_Nin2_Nout1[L[maximum], L[21], None]
minimum: _UFunc_Nin2_Nout1[L[minimum], L[21], None]
mod: _UFunc_Nin2_Nout1[L[remainder], L[16], None]
modf: _UFunc_Nin1_Nout2[L[modf], L[4], None]
multiply: _UFunc_Nin2_Nout1[L[multiply], L[23], L[1]]
negative: _UFunc_Nin1_Nout1[L[negative], L[19], None]
nextafter: _UFunc_Nin2_Nout1[L[nextafter], L[4], None]
not_equal: _UFunc_Nin2_Nout1[L[not_equal], L[23], None]
positive: _UFunc_Nin1_Nout1[L[positive], L[19], None]
power: _UFunc_Nin2_Nout1[L[power], L[18], None]
rad2deg: _UFunc_Nin1_Nout1[L[rad2deg], L[5], None]
radians: _UFunc_Nin1_Nout1[L[radians], L[5], None]
reciprocal: _UFunc_Nin1_Nout1[L[reciprocal], L[18], None]
remainder: _UFunc_Nin2_Nout1[L[remainder], L[16], None]
right_shift: _UFunc_Nin2_Nout1[L[right_shift], L[11], None]
rint: _UFunc_Nin1_Nout1[L[rint], L[10], None]
sign: _UFunc_Nin1_Nout1[L[sign], L[19], None]
signbit: _UFunc_Nin1_Nout1[L[signbit], L[4], None]
sin: _UFunc_Nin1_Nout1[L[sin], L[9], None]
sinh: _UFunc_Nin1_Nout1[L[sinh], L[8], None]
spacing: _UFunc_Nin1_Nout1[L[spacing], L[4], None]
sqrt: _UFunc_Nin1_Nout1[L[sqrt], L[10], None]
square: _UFunc_Nin1_Nout1[L[square], L[18], None]
subtract: _UFunc_Nin2_Nout1[L[subtract], L[21], None]
tan: _UFunc_Nin1_Nout1[L[tan], L[8], None]
tanh: _UFunc_Nin1_Nout1[L[tanh], L[8], None]
true_divide: _UFunc_Nin2_Nout1[L[true_divide], L[11], None]
trunc: _UFunc_Nin1_Nout1[L[trunc], L[7], None]
abs = absolute

class ModuleDeprecationWarning(DeprecationWarning): ...
class VisibleDeprecationWarning(UserWarning): ...
class ComplexWarning(RuntimeWarning): ...
class RankWarning(UserWarning): ...
class TooHardError(RuntimeError): ...

class AxisError(ValueError, IndexError):
    def __init__(self, axis: int, ndim: Optional[int] = ..., msg_prefix: Optional[str] = ...) -> None: ...

class errstate(ContextDecorator):
    call: _CallType
    kwargs: _ErrDictOptional
    def __init__(self, *, call: _CallType = ..., all: Optional[_ErrKind] = ..., divide: Optional[_ErrKind] = ..., over: Optional[_ErrKind] = ..., under: Optional[_ErrKind] = ..., invalid: Optional[_ErrKind] = ...) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, __exc_type: Optional[Type[BaseException]], __exc_value: Optional[BaseException], __traceback: Optional[TracebackType]) -> None: ...

class ndenumerate:
    iter: flatiter[NDArray[_ScalarType]]
    @overload
    def __new__(cls, arr: _NestedSequence[_SupportsArray[dtype[_ScalarType]]]) -> ndenumerate[_ScalarType]: ...
    @overload
    def __new__(cls, arr: _NestedSequence[str]) -> ndenumerate[str_]: ...
    @overload
    def __new__(cls, arr: _NestedSequence[bytes]) -> ndenumerate[bytes_]: ...
    @overload
    def __new__(cls, arr: _NestedSequence[bool]) -> ndenumerate[bool_]: ...
    @overload
    def __new__(cls, arr: _NestedSequence[int]) -> ndenumerate[int_]: ...
    @overload
    def __new__(cls, arr: _NestedSequence[float]) -> ndenumerate[float_]: ...
    @overload
    def __new__(cls, arr: _NestedSequence[complex]) -> ndenumerate[complex_]: ...
    @overload
    def __new__(cls, arr: _RecursiveSequence) -> ndenumerate[Any]: ...
    def __next__(self) -> Tuple[_Shape, _ScalarType]: ...
    def __iter__(self) -> _T: ...

class ndindex:
    def __init__(self, *shape: SupportsIndex) -> None: ...
    def __iter__(self) -> _T: ...
    def __next__(self) -> _Shape: ...

class DataSource:
    def __init__(self, destpath: Union[None, str, os.PathLike[str]] = ...) -> None: ...
    def __del__(self) -> None: ...
    def abspath(self, path: str) -> str: ...
    def exists(self, path: str) -> bool: ...
    def open(self, path: str, mode: str = ..., encoding: Optional[str] = ..., newline: Optional[str] = ...) -> IO[Any]: ...

class broadcast:
    def __new__(cls, *args: ArrayLike) -> broadcast: ...
    @property
    def index(self) -> int: ...
    @property
    def iters(self) -> Tuple[flatiter[Any], ...]: ...
    @property
    def nd(self) -> int: ...
    @property
    def ndim(self) -> int: ...
    @property
    def numiter(self) -> int: ...
    @property
    def shape(self) -> _Shape: ...
    @property
    def size(self) -> int: ...
    def __next__(self) -> Tuple[Any, ...]: ...
    def __iter__(self) -> _T: ...
    def reset(self) -> None: ...
