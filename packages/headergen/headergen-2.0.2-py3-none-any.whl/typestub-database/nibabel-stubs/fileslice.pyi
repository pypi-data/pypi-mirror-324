from _typeshed import Incomplete

SKIP_THRESH: Incomplete

class _NullLock:
    def __enter__(self) -> None: ...
    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_val: BaseException | None,
        exc_tb: types.TracebackType | None,
    ): ...

def is_fancy(sliceobj): ...
def canonical_slicers(sliceobj, shape, check_inds: bool = True): ...
def slice2outax(ndim, sliceobj): ...
def slice2len(slicer, in_len): ...
def fill_slicer(slicer, in_len): ...
def predict_shape(sliceobj, in_shape): ...
def threshold_heuristic(slicer, dim_len, stride, skip_thresh=...): ...
def optimize_slicer(slicer, dim_len, all_full, is_slowest, stride, heuristic=...): ...
def calc_slicedefs(sliceobj, in_shape, itemsize, offset, order, heuristic=...): ...
def optimize_read_slicers(sliceobj, in_shape, itemsize, heuristic): ...
def slicers2segments(read_slicers, in_shape, offset, itemsize): ...
def read_segments(fileobj, segments, n_bytes, lock: Incomplete | None = None): ...
def fileslice(
    fileobj,
    sliceobj,
    shape,
    dtype,
    offset: int = 0,
    order: str = "C",
    heuristic=...,
    lock: Incomplete | None = None,
): ...
def strided_scalar(shape, scalar: float = 0.0): ...
