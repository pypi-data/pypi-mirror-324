from tensorflow.python import tf2 as tf2
from tensorflow.python.distribute import distribution_strategy_context as distribution_strategy_context
from tensorflow.python.eager import context as context
from tensorflow.python.framework import dtypes as dtypes, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_util as tensor_util
from tensorflow.python.keras import backend as backend
from tensorflow.python.keras.utils import control_flow_util as control_flow_util, tf_inspect as tf_inspect, tf_utils as tf_utils
from tensorflow.python.ops import array_ops as array_ops
from tensorflow.python.ops.ragged import ragged_tensor as ragged_tensor
from tensorflow.python.util import keras_deps as keras_deps, nest as nest
from tensorflow.python.util.tf_export import keras_export as keras_export
from typing import Any

def create_mean_metric(value, name: Any | None = ...): ...
def make_variable(name, shape: Any | None = ..., dtype=..., initializer: Any | None = ..., trainable: Any | None = ..., caching_device: Any | None = ..., validate_shape: bool = ..., constraint: Any | None = ..., use_resource: Any | None = ..., collections: Any | None = ..., synchronization=..., aggregation=..., partitioner: Any | None = ...): ...
def collect_previous_mask(input_tensors): ...
def have_all_keras_metadata(tensors): ...
def generate_placeholders_from_shape(shape): ...
def create_keras_history(tensors): ...
def unnest_if_single_tensor(input_tensors): ...
def needs_keras_history(tensors, ignore_call_context: bool = ...): ...
def is_in_keras_graph(): ...
def is_in_eager_or_tf_function(): ...
def is_in_tf_function(): ...
def uses_keras_history(tensors): ...
def mark_checked(tensors) -> None: ...
def call_context(): ...

class CallContext:
    in_call: bool
    def __init__(self) -> None: ...
    def enter(self, layer, inputs, build_graph, training, saving: Any | None = ...): ...
    @property
    def layer(self): ...
    @property
    def inputs(self): ...
    @property
    def build_graph(self): ...
    @property
    def training(self): ...
    @property
    def saving(self): ...
    @property
    def frozen(self): ...
    @property
    def in_keras_graph(self): ...

class CallContextManager:
    def __init__(self, call_ctx, state) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *exc_info) -> None: ...

def training_arg_passed_to_call(argspec, args, kwargs): ...
def is_subclassed(layer): ...
def from_saved_model(layer): ...
def check_graph_consistency(tensor: Any | None = ..., method: str = ..., force_raise: bool = ...) -> None: ...
def mark_as_return(outputs, acd): ...

V2_DTYPE_BEHAVIOR: Any

def enable_v2_dtype_behavior() -> None: ...
def disable_v2_dtype_behavior() -> None: ...
def v2_dtype_behavior_enabled(): ...

class TrackableWeightHandler:
    def __init__(self, trackable): ...
    @property
    def num_tensors(self): ...
    def set_weights(self, weights) -> None: ...
    def get_tensors(self): ...

class StaticTableHandler(TrackableWeightHandler):
    def __init__(self, getter_lambda) -> None: ...

def no_ragged_support(inputs, layer_name) -> None: ...
def is_split_variable(v): ...
def has_weights(obj): ...

REVIVED_LOSS_PLACEHOLDER: str
