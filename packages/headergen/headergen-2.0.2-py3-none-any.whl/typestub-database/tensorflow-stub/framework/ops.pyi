import threading
from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2, function_pb2 as function_pb2, graph_pb2 as graph_pb2, node_def_pb2 as node_def_pb2, op_def_pb2 as op_def_pb2, versions_pb2 as versions_pb2
from tensorflow.core.protobuf import config_pb2 as config_pb2
from tensorflow.python import pywrap_tensorflow as pywrap_tensorflow, pywrap_tfe as pywrap_tfe, tf2 as tf2
from tensorflow.python.client import pywrap_tf_session as pywrap_tf_session
from tensorflow.python.eager import context as context, core as core, monitoring as monitoring, tape as tape
from tensorflow.python.framework import c_api_util as c_api_util, composite_tensor as composite_tensor, cpp_shape_inference_pb2 as cpp_shape_inference_pb2, dtypes as dtypes, errors as errors, indexed_slices as indexed_slices, registry as registry, tensor_conversion_registry as tensor_conversion_registry, tensor_shape as tensor_shape, traceable_stack as traceable_stack, versions as versions
from tensorflow.python.ops import control_flow_util as control_flow_util
from tensorflow.python.profiler import trace as trace
from tensorflow.python.types import core as core_tf_types, internal as internal
from tensorflow.python.util import compat as compat, decorator_utils as decorator_utils, deprecation as deprecation, dispatch as dispatch, function_utils as function_utils, lock_util as lock_util, memory as memory, object_identity as object_identity, tf_contextlib as tf_contextlib, tf_stack as tf_stack, traceback_utils as traceback_utils
from tensorflow.python.util.compat import collections_abc as collections_abc
from tensorflow.python.util.deprecation import deprecated_args as deprecated_args
from tensorflow.python.util.lazy_loader import LazyLoader as LazyLoader
from tensorflow.python.util.tf_export import kwarg_only as kwarg_only, tf_export as tf_export
from typing import Any

ag_ctx: Any

def tensor_id(tensor): ...

class _UserDeviceSpec:
    display_name: Any
    function: Any
    raw_string: Any
    is_null_merge: Any
    fast_string_merge: Any
    def __init__(self, device_name_or_function) -> None: ...
    def string_merge(self, node_def): ...

class NullContextmanager:
    def __init__(self, *args, **kwargs) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type_arg, value_arg, traceback_arg): ...

def is_dense_tensor_like(t): ...
def uid(): ...
def numpy_text(tensor, is_repr: bool = ...): ...
def value_text(tensor, is_repr: bool = ...): ...
def enable_tensor_equality() -> None: ...
def disable_tensor_equality() -> None: ...

class Tensor(internal.NativeObject, core_tf_types.Tensor):
    OVERLOADABLE_OPERATORS: Any
    def __init__(self, op, value_index, dtype) -> None: ...
    def __getattr__(self, name) -> None: ...
    @property
    def op(self): ...
    @property
    def dtype(self): ...
    @property
    def graph(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    @property
    def shape(self): ...
    def __iter__(self): ...
    def get_shape(self): ...
    def set_shape(self, shape) -> None: ...
    @property
    def value_index(self): ...
    def consumers(self): ...
    def __hash__(self): ...
    def __copy__(self): ...
    __array_priority__: int
    def __array__(self, dtype: Any | None = ...) -> None: ...
    def __len__(self) -> None: ...
    def __bool__(self) -> None: ...
    def __nonzero__(self) -> None: ...
    def eval(self, feed_dict: Any | None = ..., session: Any | None = ...): ...
    def experimental_ref(self): ...
    def ref(self): ...

class _EagerTensorBase(Tensor):
    def __complex__(self): ...
    def __int__(self): ...
    def __long__(self): ...
    def __float__(self): ...
    def __index__(self): ...
    def __bool__(self): ...
    __nonzero__: Any
    def __format__(self, format_spec): ...
    def __reduce__(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo): ...
    def __len__(self): ...
    def __array__(self, dtype: Any | None = ...): ...
    @property
    def dtype(self): ...
    def numpy(self): ...
    @property
    def backing_device(self) -> None: ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    @property
    def ndim(self): ...
    def cpu(self): ...
    def gpu(self, gpu_index: int = ...): ...
    def set_shape(self, shape) -> None: ...
    @property
    def op(self) -> None: ...
    @property
    def graph(self) -> None: ...
    @property
    def name(self) -> None: ...
    @property
    def value_index(self) -> None: ...
    def consumers(self) -> None: ...
    def eval(self, feed_dict: Any | None = ..., session: Any | None = ...) -> None: ...

EagerTensor: Any

def convert_to_tensor_v1_with_dispatch(value, dtype: Any | None = ..., name: Any | None = ..., preferred_dtype: Any | None = ..., dtype_hint: Any | None = ...): ...
def convert_to_tensor_v1(value, dtype: Any | None = ..., name: Any | None = ..., preferred_dtype: Any | None = ..., dtype_hint: Any | None = ...): ...
def convert_to_tensor_v2_with_dispatch(value, dtype: Any | None = ..., dtype_hint: Any | None = ..., name: Any | None = ...): ...
def convert_to_tensor_v2(value, dtype: Any | None = ..., dtype_hint: Any | None = ..., name: Any | None = ...): ...
def pack_eager_tensors(tensors, ctx: Any | None = ...): ...
def convert_to_tensor(value, dtype: Any | None = ..., name: Any | None = ..., as_ref: bool = ..., preferred_dtype: Any | None = ..., dtype_hint: Any | None = ..., ctx: Any | None = ..., accepted_result_types=...): ...
internal_convert_to_tensor = convert_to_tensor

def internal_convert_n_to_tensor(values, dtype: Any | None = ..., name: Any | None = ..., as_ref: bool = ..., preferred_dtype: Any | None = ..., ctx: Any | None = ...): ...
def convert_n_to_tensor(values, dtype: Any | None = ..., name: Any | None = ..., preferred_dtype: Any | None = ...): ...
def convert_to_tensor_or_composite(value, dtype: Any | None = ..., name: Any | None = ...): ...
def internal_convert_to_tensor_or_composite(value, dtype: Any | None = ..., name: Any | None = ..., as_ref: bool = ...): ...
def internal_convert_n_to_tensor_or_composite(values, dtype: Any | None = ..., name: Any | None = ..., as_ref: bool = ...): ...
def convert_n_to_tensor_or_composite(values, dtype: Any | None = ..., name: Any | None = ...): ...

class Operation:
    def __init__(self, node_def, g, inputs: Any | None = ..., output_types: Any | None = ..., control_inputs: Any | None = ..., input_types: Any | None = ..., original_op: Any | None = ..., op_def: Any | None = ...) -> None: ...
    def colocation_groups(self): ...
    def values(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    def __tf_tensor__(self, dtype: Any | None = ..., name: Any | None = ...) -> None: ...
    @property
    def outputs(self): ...
    @property
    def inputs(self): ...
    @property
    def control_inputs(self): ...
    @property
    def type(self): ...
    @property
    def graph(self): ...
    @property
    def node_def(self): ...
    @property
    def op_def(self): ...
    @property
    def traceback(self): ...
    def get_attr(self, name): ...
    def run(self, feed_dict: Any | None = ..., session: Any | None = ...) -> None: ...

gradient_registry: Any

class RegisterGradient:
    def __init__(self, op_type) -> None: ...
    def __call__(self, f): ...

def no_gradient(op_type) -> None: ...
NoGradient = no_gradient
NotDifferentiable = no_gradient

def get_gradient_function(op): ...
def set_shape_and_handle_data_for_outputs(_) -> None: ...

class OpStats:
    def __init__(self, statistic_type, value: Any | None = ...) -> None: ...
    @property
    def statistic_type(self): ...
    @statistic_type.setter
    def statistic_type(self, statistic_type) -> None: ...
    @property
    def value(self): ...
    @value.setter
    def value(self, value) -> None: ...
    def __iadd__(self, other): ...

class RegisterStatistics:
    def __init__(self, op_type, statistic_type) -> None: ...
    def __call__(self, f): ...

def get_stats_for_node_def(graph, node, statistic_type): ...
def name_from_scope_name(name): ...
def resource_creator_scope(resource_type, resource_creator) -> None: ...

class Graph:
    def __init__(self) -> None: ...
    @property
    def version(self): ...
    @property
    def graph_def_versions(self): ...
    @property
    def seed(self): ...
    @seed.setter
    def seed(self, seed) -> None: ...
    @property
    def finalized(self): ...
    def finalize(self) -> None: ...
    def as_graph_def(self, from_version: Any | None = ..., add_shapes: bool = ...): ...
    @property
    def building_function(self): ...
    def create_op(self, op_type, inputs, dtypes: Any | None = ..., input_types: Any | None = ..., name: Any | None = ..., attrs: Any | None = ..., op_def: Any | None = ..., compute_shapes: bool = ..., compute_device: bool = ...): ...
    def as_graph_element(self, obj, allow_tensor: bool = ..., allow_operation: bool = ...): ...
    def get_operations(self): ...
    def get_operation_by_name(self, name): ...
    def get_tensor_by_name(self, name): ...
    def as_default(self): ...
    @property
    def collections(self): ...
    def add_to_collection(self, name, value) -> None: ...
    def add_to_collections(self, names, value) -> None: ...
    def get_collection_ref(self, name): ...
    def get_collection(self, name, scope: Any | None = ...): ...
    def get_all_collection_keys(self): ...
    def clear_collection(self, name) -> None: ...
    def name_scope(self, name) -> None: ...
    def unique_name(self, name, mark_as_used: bool = ...): ...
    def get_name_scope(self): ...
    def colocate_with(self, op, ignore_existing: bool = ...) -> None: ...
    def device(self, device_name_or_function) -> None: ...
    def container(self, container_name) -> None: ...
    class _ControlDependenciesController:
        def __init__(self, graph, control_inputs) -> None: ...
        def __enter__(self) -> None: ...
        def __exit__(self, unused_type, unused_value, unused_traceback) -> None: ...
        @property
        def control_inputs(self): ...
        def add_op(self, op) -> None: ...
        def op_in_group(self, op): ...
    def control_dependencies(self, control_inputs): ...
    def gradient_override_map(self, op_type_map) -> None: ...
    def prevent_feeding(self, tensor) -> None: ...
    def is_feedable(self, tensor): ...
    def prevent_fetching(self, op) -> None: ...
    def is_fetchable(self, tensor_or_op): ...
    def switch_to_thread_local(self) -> None: ...

def device(device_name_or_function): ...
def device_v2(device_name): ...
def container(container_name): ...
def colocate_with(op, ignore_existing: bool = ...): ...
def control_dependencies(control_inputs): ...

class _DefaultStack(threading.local):
    stack: Any
    def __init__(self) -> None: ...
    def get_default(self): ...
    def reset(self) -> None: ...
    def is_cleared(self): ...
    @property
    def enforce_nesting(self): ...
    @enforce_nesting.setter
    def enforce_nesting(self, value) -> None: ...
    def get_controller(self, default) -> None: ...

def default_session(session): ...
def get_default_session(): ...

class _DefaultGraphStack(_DefaultStack):
    def __init__(self) -> None: ...
    def get_default(self): ...
    def reset(self) -> None: ...
    def get_controller(self, default) -> None: ...

def init_scope() -> None: ...
def executing_eagerly_outside_functions(): ...
def inside_function(): ...
def enable_eager_execution(config: Any | None = ..., device_policy: Any | None = ..., execution_mode: Any | None = ...): ...
def disable_eager_execution() -> None: ...
def enable_eager_execution_internal(config: Any | None = ..., device_policy: Any | None = ..., execution_mode: Any | None = ..., server_def: Any | None = ...) -> None: ...
def eager_run(main: Any | None = ..., argv: Any | None = ...) -> None: ...
def reset_default_graph() -> None: ...
def get_default_graph(): ...
def has_default_graph(): ...
def get_name_scope(): ...

class GraphKeys:
    GLOBAL_VARIABLES: str
    LOCAL_VARIABLES: str
    METRIC_VARIABLES: str
    MODEL_VARIABLES: str
    TRAINABLE_VARIABLES: str
    SUMMARIES: str
    QUEUE_RUNNERS: str
    TABLE_INITIALIZERS: str
    ASSET_FILEPATHS: str
    MOVING_AVERAGE_VARIABLES: str
    REGULARIZATION_LOSSES: str
    CONCATENATED_VARIABLES: str
    SAVERS: str
    WEIGHTS: str
    BIASES: str
    ACTIVATIONS: str
    UPDATE_OPS: str
    LOSSES: str
    SAVEABLE_OBJECTS: str
    RESOURCES: str
    LOCAL_RESOURCES: str
    TRAINABLE_RESOURCE_VARIABLES: str
    INIT_OP: str
    LOCAL_INIT_OP: str
    READY_OP: str
    READY_FOR_LOCAL_INIT_OP: str
    SUMMARY_OP: str
    GLOBAL_STEP: str
    EVAL_STEP: str
    TRAIN_OP: str
    COND_CONTEXT: str
    WHILE_CONTEXT: str
    def VARIABLES(cls): ...

def dismantle_graph(graph) -> None: ...
def add_to_collection(name, value) -> None: ...
def add_to_collections(names, value) -> None: ...
def get_collection_ref(key): ...
def get_collection(key, scope: Any | None = ...): ...
def get_all_collection_keys(): ...
def name_scope(name, default_name: Any | None = ..., values: Any | None = ..., skip_on_eager: bool = ...): ...

class internal_name_scope_v1:
    @property
    def name(self): ...
    def __init__(self, name, default_name: Any | None = ..., values: Any | None = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *exc_info) -> None: ...

class name_scope_v1:
    @property
    def name(self): ...
    def __init__(self, name, default_name: Any | None = ..., values: Any | None = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *exc_info): ...

def get_current_name_scope(): ...

class name_scope_v2:
    def __init__(self, name) -> None: ...
    @property
    def name(self): ...
    def __enter__(self): ...
    def __exit__(self, type_arg, value_arg, traceback_arg): ...

def strip_name_scope(name, export_scope): ...
def prepend_name_scope(name, import_scope): ...
def op_scope(values, name, default_name: Any | None = ...) -> None: ...
def register_proto_function(collection_name, proto_type: Any | None = ..., to_proto: Any | None = ..., from_proto: Any | None = ...) -> None: ...
def get_collection_proto_type(collection_name): ...
def get_to_proto_function(collection_name): ...
def get_from_proto_function(collection_name): ...

IndexedSlices: Any
IndexedSlicesValue: Any
convert_to_tensor_or_indexed_slices: Any
convert_n_to_tensor_or_indexed_slices: Any
internal_convert_to_tensor_or_indexed_slices: Any
internal_convert_n_to_tensor_or_indexed_slices: Any
register_tensor_conversion_function: Any

def to_raw_op(f): ...
def raise_from_not_ok_status(e, name) -> None: ...
def add_exit_callback_to_default_func_graph(fn) -> None: ...
def enable_numpy_style_type_promotion() -> None: ...
def enable_numpy_style_slicing() -> None: ...

class _TensorIterator:
    def __init__(self, tensor, dim0) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    next: Any

def set_int_list_attr(op, attr_name, ints) -> None: ...
def get_resource_handle_data(graph_op): ...
