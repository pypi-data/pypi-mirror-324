from tensorflow.python.data.ops import dataset_ops as dataset_ops
from tensorflow.python.eager import context as context
from tensorflow.python.framework import combinations as combinations, dtypes as dtypes, errors as errors, ops as ops, sparse_tensor as sparse_tensor
from tensorflow.python.ops import lookup_ops as lookup_ops, variables as variables
from tensorflow.python.ops.ragged import ragged_tensor_value as ragged_tensor_value
from tensorflow.python.platform import gfile as gfile, test as test
from tensorflow.python.training import checkpoint_management as checkpoint_management
from tensorflow.python.util import nest as nest
from typing import Any

def remove_variants(get_next_op): ...
def default_test_combinations(): ...

class CheckpointTestBase(test.TestCase):
    def tearDown(self) -> None: ...
    def verify_unused_iterator(self, ds_fn, num_outputs, sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_fully_used_iterator(self, ds_fn, num_outputs, sparse_tensors: bool = ...) -> None: ...
    def verify_exhausted_iterator(self, ds_fn, num_outputs, sparse_tensors: bool = ...) -> None: ...
    def verify_multiple_breaks(self, ds_fn, num_outputs, num_breaks: int = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_reset_restored_iterator(self, ds_fn, num_outputs, break_point: Any | None = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_error_on_save(self, ds_fn, num_outputs, error, break_point: Any | None = ..., sparse_tensors: bool = ...) -> None: ...
    def verify_run_with_breaks(self, ds_fn, break_points, num_outputs, sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def gen_outputs(self, ds_fn, break_points, num_outputs, ckpt_saved: bool = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ..., save_checkpoint_at_end: bool = ...): ...
    def match(self, expected, actual) -> None: ...
    def does_not_match(self, expected, actual) -> None: ...
    def gen_break_points(self, num_outputs, num_samples: int = ...): ...
