from tensorflow.compiler.tf2xla.python import xla as xla
from tensorflow.core.framework import full_type_pb2 as full_type_pb2
from tensorflow.python.eager import context as context, def_function as def_function, execute as execute
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, func_graph as func_graph, ops as ops, smart_cond as smart_cond, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_spec as tensor_spec, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, data_flow_ops as data_flow_ops, gen_array_ops as gen_array_ops, gen_dataset_ops as gen_dataset_ops, gen_image_ops as gen_image_ops, gen_linalg_ops as gen_linalg_ops, gen_list_ops as gen_list_ops, gen_math_ops as gen_math_ops, gen_nn_ops as gen_nn_ops, gen_parsing_ops as gen_parsing_ops, gen_random_ops as gen_random_ops, gen_sparse_ops as gen_sparse_ops, gen_spectral_ops as gen_spectral_ops, handle_data_util as handle_data_util, linalg_ops as linalg_ops, list_ops as list_ops, manip_ops as manip_ops, map_fn as map_fn, math_ops as math_ops, nn_ops as nn_ops, parsing_ops as parsing_ops, resource_variable_ops as resource_variable_ops, sparse_ops as sparse_ops, special_math_ops as special_math_ops, tensor_array_ops as tensor_array_ops
from tensorflow.python.platform import flags as flags
from tensorflow.python.util import compat as compat, nest as nest, object_identity as object_identity
from typing import Any, NamedTuple

passthrough_stateful_ops: Any
force_stateful_ops: Any

class WhileOp:
    def __init__(self, exit_node, pfor_ops, fallback_to_while_loop, pfor_config) -> None: ...
    @property
    def inputs(self): ...
    @property
    def control_inputs(self): ...
    @property
    def outputs(self): ...
    @property
    def name(self): ...
    @property
    def is_inside_loop(self): ...
    def op_is_inside_loop(self, op): ...
    @property
    def is_stateful(self): ...
    @property
    def pfor_converter(self): ...
    def __call__(self, pfor_input): ...

class ConversionNotImplementedError(Exception): ...

class _PforInput:
    pfor: Any
    def __init__(self, pfor, op, inputs) -> None: ...
    def stack_inputs(self, stack_indices: Any | None = ..., tile_variants: bool = ...) -> None: ...
    def expanddim_inputs_for_broadcast(self): ...
    @property
    def inputs(self): ...
    @property
    def num_inputs(self): ...
    def input(self, index): ...
    def stacked_input(self, index): ...
    def unstacked_input(self, index): ...
    @property
    def op(self): ...
    @property
    def op_type(self): ...
    def get_attr(self, attr): ...
    @property
    def outputs(self): ...
    def output(self, index): ...

class RegisterPFor:
    op_type: Any
    def __init__(self, op_type) -> None: ...
    def __call__(self, converter): ...

class RegisterPForWithArgs(RegisterPFor):
    def __init__(self, op_type, *args, **kw_args) -> None: ...
    def __call__(self, converter): ...

class WrappedTensor(NamedTuple):
    t: Any
    is_stacked: Any
    is_sparse_stacked: Any

def wrap(tensor, is_stacked: bool = ..., is_sparse_stacked: bool = ...): ...

class PForConfig:
    def __init__(self) -> None: ...
    def reduce(self, fn, *args): ...
    def reduce_concat(self, x): ...
    def reduce_mean(self, x): ...
    def reduce_sum(self, x): ...

class PFor:
    all_indices: Any
    def __init__(self, loop_var, loop_len, pfor_ops, fallback_to_while_loop, all_indices: Any | None = ..., all_indices_partitioned: bool = ..., pfor_config: Any | None = ...) -> None: ...
    def op_is_inside_loop(self, op): ...
    def convert(self, y): ...
    @property
    def loop_len_vector(self): ...
    @property
    def loop_var(self): ...
    @property
    def pfor_ops(self): ...
    @property
    def pfor_config(self): ...
    @property
    def all_indices_partitioned(self): ...
    @property
    def fallback_to_while_loop(self): ...

class WhileV2:
    def __init__(self, pfor_input) -> None: ...
    def __call__(self): ...
