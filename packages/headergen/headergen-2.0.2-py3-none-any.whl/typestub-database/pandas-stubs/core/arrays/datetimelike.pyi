import numpy as np
from pandas._libs import algos as algos, lib as lib
from pandas._libs.tslibs import BaseOffset as BaseOffset, IncompatibleFrequency as IncompatibleFrequency, NaT as NaT, NaTType as NaTType, Period as Period, Resolution as Resolution, Tick as Tick, Timestamp as Timestamp, delta_to_nanoseconds as delta_to_nanoseconds, iNaT as iNaT, ints_to_pydatetime as ints_to_pydatetime, to_offset as to_offset
from pandas._libs.tslibs.fields import RoundTo as RoundTo, round_nsint64 as round_nsint64
from pandas._libs.tslibs.timestamps import integer_op_not_supported as integer_op_not_supported
from pandas._typing import ArrayLike as ArrayLike, DatetimeLikeScalar as DatetimeLikeScalar, Dtype as Dtype, DtypeObj as DtypeObj, NpDtype as NpDtype, PositionalIndexer2D as PositionalIndexer2D, PositionalIndexerTuple as PositionalIndexerTuple, ScalarIndexer as ScalarIndexer, SequenceIndexer as SequenceIndexer, npt as npt
from pandas.core import nanops as nanops, ops as ops
from pandas.core.algorithms import checked_add_with_arr as checked_add_with_arr, isin as isin, mode as mode, unique1d as unique1d
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays import DatetimeArray as DatetimeArray, TimedeltaArray as TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray, ravel_compat as ravel_compat
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.common import is_all_strings as is_all_strings, is_categorical_dtype as is_categorical_dtype, is_datetime64_any_dtype as is_datetime64_any_dtype, is_datetime64_dtype as is_datetime64_dtype, is_datetime64tz_dtype as is_datetime64tz_dtype, is_datetime_or_timedelta_dtype as is_datetime_or_timedelta_dtype, is_dtype_equal as is_dtype_equal, is_float_dtype as is_float_dtype, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_period_dtype as is_period_dtype, is_string_dtype as is_string_dtype, is_timedelta64_dtype as is_timedelta64_dtype, is_unsigned_integer_dtype as is_unsigned_integer_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna
from pandas.core.indexers import check_array_indexer as check_array_indexer, check_setitem_lengths as check_setitem_lengths
from pandas.core.ops.common import unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.core.ops.invalid import invalid_comparison as invalid_comparison, make_invalid_op as make_invalid_op
from pandas.errors import AbstractMethodError as AbstractMethodError, NullFrequencyError as NullFrequencyError, PerformanceWarning as PerformanceWarning
from pandas.tseries import frequencies as frequencies
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Union, Any, Literal, Sequence, TypeVar, Union, overload

DTScalarOrNaT = Union[DatetimeLikeScalar, NaTType]
DatetimeLikeArrayT = TypeVar('DatetimeLikeArrayT', bound='DatetimeLikeArrayMixin')

class InvalidComparison(Exception): ...

class DatetimeLikeArrayMixin(OpsMixin, NDArrayBackedExtensionArray):
    def __init__(self, data, dtype: Union[Dtype, None] = ..., freq: Any | None = ..., copy: bool = ...) -> None: ...
    def __iter__(self): ...
    @property
    def asi8(self) -> npt.NDArray[np.int64]: ...
    def __array__(self, dtype: Union[NpDtype, None] = ...) -> np.ndarray: ...
    @overload
    def __getitem__(self, item: ScalarIndexer) -> DTScalarOrNaT: ...
    @overload
    def __getitem__(self, item: Union[SequenceIndexer, PositionalIndexerTuple]) -> DatetimeLikeArrayT: ...
    def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None: ...
    def astype(self, dtype, copy: bool = ...): ...
    @overload
    def view(self) -> DatetimeLikeArrayT: ...
    @overload
    def view(self, dtype: Union[Dtype, None] = ...) -> ArrayLike: ...
    def copy(self, order: str = ...) -> DatetimeLikeArrayT: ...
    def map(self, mapper): ...
    def isin(self, values) -> npt.NDArray[np.bool_]: ...
    def isna(self) -> npt.NDArray[np.bool_]: ...
    @property
    def freq(self): ...
    @freq.setter
    def freq(self, value) -> None: ...
    @property
    def freqstr(self) -> Union[str, None]: ...
    @property
    def inferred_freq(self) -> Union[str, None]: ...
    @property
    def resolution(self) -> str: ...
    __pow__: Any
    __rpow__: Any
    __mul__: Any
    __rmul__: Any
    __truediv__: Any
    __rtruediv__: Any
    __floordiv__: Any
    __rfloordiv__: Any
    __mod__: Any
    __rmod__: Any
    __divmod__: Any
    __rdivmod__: Any
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def min(self, *, axis: Union[int, None] = ..., skipna: bool = ..., **kwargs): ...
    def max(self, *, axis: Union[int, None] = ..., skipna: bool = ..., **kwargs): ...
    def mean(self, *, skipna: bool = ..., axis: Union[int, None] = ...): ...
    def median(self, *, axis: Union[int, None] = ..., skipna: bool = ..., **kwargs): ...

class DatelikeOps(DatetimeLikeArrayMixin):
    def strftime(self, date_format: str) -> npt.NDArray[np.object_]: ...
TimelikeOpsT = TypeVar('TimelikeOpsT', bound='TimelikeOps')

class TimelikeOps(DatetimeLikeArrayMixin):
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def round(self, freq, ambiguous: str = ..., nonexistent: str = ...): ...
    def floor(self, freq, ambiguous: str = ..., nonexistent: str = ...): ...
    def ceil(self, freq, ambiguous: str = ..., nonexistent: str = ...): ...
    def any(self, *, axis: Union[int, None] = ..., skipna: bool = ...): ...
    def all(self, *, axis: Union[int, None] = ..., skipna: bool = ...): ...
    def factorize(self, na_sentinel: int = ..., sort: bool = ...): ...

def validate_periods(periods): ...
def validate_inferred_freq(freq, inferred_freq, freq_infer): ...
def maybe_infer_freq(freq): ...
