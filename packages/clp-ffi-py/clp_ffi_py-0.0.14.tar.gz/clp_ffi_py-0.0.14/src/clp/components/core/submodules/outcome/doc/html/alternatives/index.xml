<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Review of Error Handling Frameworks on Outcome documentation</title>
    <link>https://ned14.github.io/outcome/alternatives/</link>
    <description>Recent content in Review of Error Handling Frameworks on Outcome documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 10 Jan 2022 14:29:13 +0000</lastBuildDate>
    
	<atom:link href="https://ned14.github.io/outcome/alternatives/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>std exception throws</title>
      <link>https://ned14.github.io/outcome/alternatives/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/exceptions/</guid>
      <description>(Note that we assume a table-based EH implementation here, a SJLJ EH implementaton would have even happy and sad path runtime overhead. Table-based EH implementations are almost universal on x64, ARM and AArch64 targets).
C++ exception throws came in the original C++ 98 standard &amp;ndash; at that time, not all the major compilers implemented them yet, and several of those who did did not have efficient implementations, plus in the original days some compiler vendors still patented things like EH implementation techniques to try and maintain a competitive advantage over rival compilers.</description>
    </item>
    
    <item>
      <title>std error codes</title>
      <link>https://ned14.github.io/outcome/alternatives/error_code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/error_code/</guid>
      <description>std::error_code came originally from boost::error_code which was designed around 2008 as part of implementing Filesystem and Networking. They are a simple trivially copyable type offering improved type safety and functionality over C enumerations. You can read more about how std::error_code works here. They were standardised in the C++ 11 standard, and have been available in Boost since 2008.
Pros:  Predictable runtime overhead on the happy path.
 Predictable runtime overhead on the sad path.</description>
    </item>
    
    <item>
      <title>std expected</title>
      <link>https://ned14.github.io/outcome/alternatives/expected/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/expected/</guid>
      <description>std::expected&amp;lt;T, E&amp;gt; came originally from an experimental monadic and generic programming library outside of Boost written by Boost and WG21 developers around 2013. Before Outcome v1, I deployed the then Expected into a large codebase and I was dismayed with the results, especially on build times. You can read here how those experiences led me to develop Outcome v1.
std::expected&amp;lt;T, E&amp;gt; is a constrained variant type with a strong preference for the successful type T which it models like a std::optional&amp;lt;T&amp;gt;.</description>
    </item>
    
    <item>
      <title>Outcome (proposed std result)</title>
      <link>https://ned14.github.io/outcome/alternatives/outcome/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/outcome/</guid>
      <description>Outcome (the library described by this documentation) originated in a negative reaction to then originally proposed std::expected&amp;lt;T, E&amp;gt;, though what got eventually standardised as std::expected&amp;lt;T, E&amp;gt; looks much more like Outcome&amp;rsquo;s result&amp;lt;T, E&amp;gt; than the original Expected. You can read here how those experiences led me to develop Outcome v1. Outcome comes in both standalone and Boost editions, and its current design was completed in 2018.
Outcome&amp;rsquo;s core is two workhorse types and a macro:</description>
    </item>
    
    <item>
      <title>LEAF</title>
      <link>https://ned14.github.io/outcome/alternatives/leaf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ned14.github.io/outcome/alternatives/leaf/</guid>
      <description>As much as Outcome originated in a negative reaction to the then originally proposed std::expected&amp;lt;T, E&amp;gt;, LEAF originated in a negative reaction to Outcome. Some of the perceived issues with Outcome were (LEAF&amp;rsquo;s own rendition of this can be viewed here):
 Outcome based code is visually cluttered, as both happy and sad paths appear in code.
 Outcome based code generates branchy code at runtime, which impacts low end CPUs and first time code execution.</description>
    </item>
    
  </channel>
</rss>