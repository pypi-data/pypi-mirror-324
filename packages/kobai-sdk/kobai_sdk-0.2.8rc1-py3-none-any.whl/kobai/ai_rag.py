from kobai import tenant_client

def generate_sentences(tc: tenant_client.TenantClient, replica_schema=None):
    if tc.spark_client is None:
        return None
    
    ss = tc.spark_client.spark_session

    print("Getting Tenant Config")
    tenant_json = tc.get_tenant_config()

    concepts = __get_concept_metadata(tenant_json, tc.schema, tc.model_id)

    print("Dropping and Recreating the RAG Table")
    ss.sql(__create_rag_table_sql(tc.schema, tc.model_id))

    print("Generating Extraction SQL")
    sql_statements = []
    sql_statements.extend(__generate_sentence_sql_concept_literals(concepts, tc.schema, tc.model_id))
    sql_statements.extend(__generate_sentence_sql_concept_relations(concepts, tc.schema, tc.model_id))

    print("Running the Extraction")
    for sql_statement in sql_statements:
        ss.sql(sql_statement)

    if replica_schema is not None:
        print("Replicating Schema")
        ss.sql(__create_rag_table_sql(replica_schema, tc.model_id))
        ss.sql(__replicate_to_catalog_sql(tc.schema, replica_schema, tc.model_id))

def __create_rag_table_sql(schema, model_id):
    return f"CREATE OR REPLACE TABLE {schema}.rag_{model_id} (id BIGINT GENERATED BY DEFAULT AS IDENTITY, content STRING, type string, concept_id string, vector ARRAY<FLOAT>) TBLPROPERTIES (delta.enableChangeDataFeed = true)"
    
def __replicate_to_catalog_sql(base_schema, target_schema, model_id):
    move_sql = f"INSERT INTO {target_schema}.rag_{model_id} (content, concept_id, type)"
    move_sql += f" SELECT content, concept_id, type FROM {base_schema}.rag_{model_id}"
    return move_sql

def __generate_sentence_sql_concept_literals(concepts, schema, model_id):
    statements = []
    for con in concepts:
        sql = f"'This is a {con['label']}. '"
        sql += " || 'It is identified by ' || split(cid._conceptid,'#')[1] || '. '"
            
        sql_from = f"{con['con_table_name']} cid"
        for prop in con["properties"]:

            sql_from += f" INNER JOIN {con['prop_table_name']} AS {prop['label']}"
            sql_from += f" ON cid._conceptid = {prop['label']}._conceptid"
            sql_from += f" AND {prop['label']}.type = 'l'"
            sql_from += f" AND {prop['label']}.name = '{prop['name']}'"
            
            sql += f" || 'The {prop['label']} is ' || any_value({prop['label']}.value) IGNORE NULLS || '. '"
            
            full_sql = f"INSERT INTO {schema}.rag_{model_id} (content, concept_id, type)"
            full_sql += f" SELECT {sql} content, cid._conceptid concept_id, 'c' type FROM {sql_from} GROUP BY cid._conceptid"
            
            statements.append(full_sql)
            #test_df = spark.sql(full_sql)
    return statements

def __generate_sentence_sql_concept_relations(concepts, schema, model_id):
    statements = []
    for con in concepts:
     
        sql_from = f"{con['prop_table_name']} "
        for rel in con["relations"]:

            sql = f"'The {con['label']} identified by ' || split(_conceptid,'#')[1]"
            sql += f" || ' has a relationship called {rel['label']} that connects it to one or more {rel['target_con_label']} identified by '"
            sql += " || concat_ws(', ', array_agg(split(value, '#')[1])) || '. '"

            
            full_sql = f"INSERT INTO {schema}.rag_{model_id} (content, concept_id, type)"
            full_sql += f" SELECT {sql} content, _conceptid concept_id, 'e' type FROM {sql_from} GROUP BY _conceptid"

            statements.append(full_sql)
    return statements

def __get_concept_metadata(tenant_json, schema, model_id):
    target_concept_labels = {}
    for d in tenant_json["domains"]:
        for c in d["concepts"]:
            target_concept_labels[c["uri"]] = d["name"] + " " + c["label"]

    concepts = []

    for d in tenant_json["domains"]:
        for c in d["concepts"]:
            con_props = []
            for col in c["properties"]:
                con_props.append({
                    #"col_name": d["name"] + "_" + c["label"] + "_" + col["label"],
                    "label": col["label"],
                    "name": f"{model_id}/{d['name']}/{c['label']}#{col['label']}"
                    })
            con_rels = []
            for rel in c["relations"]:
                con_rels.append({
                    "label": rel["label"],
                    "name": f"{model_id}/{d['name']}/{c['label']}#{rel['label']}",
                    "target_con_label": target_concept_labels[rel["relationTypeUri"]]
                })
            concepts.append({
                "label": d["name"] + " " + c["label"],
                #"id_column": d["name"] + "_" + c["label"],
                "relations": con_rels,
                "properties": con_props,
                #"table_name": "data_" + k.model_id + "_" + d["name"] + "_" + c["label"] + "_w",
                "prop_table_name": f"{schema}.data_{model_id}_{d['name']}_{c['label']}_np",
                "con_table_name": f"{schema}.data_{model_id}_{d['name']}_{c['label']}_c",
                })
    return concepts