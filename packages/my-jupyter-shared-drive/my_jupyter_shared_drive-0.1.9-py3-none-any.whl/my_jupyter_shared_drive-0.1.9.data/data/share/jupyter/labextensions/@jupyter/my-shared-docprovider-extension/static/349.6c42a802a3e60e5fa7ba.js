"use strict";(self.webpackChunk_jupyter_my_shared_docprovider_extension=self.webpackChunk_jupyter_my_shared_docprovider_extension||[]).push([[349],{349:(e,t,s)=>{s.r(t),s.d(t,{MyProvider:()=>a,MySharedDrive:()=>i});var r=s(602),o=s(421),n=s(262);class a{constructor(e){this._ready=new n.PromiseDelegate,this._isDisposed=!1,this._contentType=e.contentType,this._format=e.format,this._awareness=e.model.awareness,this._model=e.model;const t=e.user;t.ready.then((()=>{this._onUserChanged(t)})).catch((e=>console.error(e))),t.userChanged.connect(this._onUserChanged,this)}setSource(e){this._model.setSource(e),this._ready.resolve()}get isDisposed(){return this._isDisposed}get ready(){return this._ready.promise}get contentType(){return this._contentType}get format(){return this._format}dispose(){this.isDisposed||(this._isDisposed=!0,r.Signal.clearData(this))}_onUserChanged(e){this._awareness.setLocalStateField("user",e.identity)}}class i extends o.Drive{constructor(e,t){super({name:"RTC"}),this._onCreate=(e,t)=>{if("string"==typeof e.format)try{const s=new a({path:e.path,format:e.format,contentType:e.contentType,model:t,user:this._user,translator:this._trans});this._app.serviceManager.contents.get(e.path,{content:!0}).then((e=>{console.log("set model source:",e);const t="base64"===e.format?atob(e.content):e.content;s.setSource(t)}));const r=`${e.format}:${e.contentType}:${e.path}`;this._providers.set(r,s),t.changed.connect((async(s,r)=>{var o;if(!r.stateChange)return;const n=r.stateChange.filter((e=>"hash"===e.name));if(0===n.length)return;n.length>1&&console.error("Unexpected multiple changes to hash value in a single transaction");const a=n[0],i=null!==(o=t.state.path)&&void 0!==o?o:e.path,h=await this.get(i,{content:!1});this._ydriveFileChanged.emit({type:"save",newValue:{...h,hash:a.newValue},oldValue:{hash:a.oldValue}})})),t.disposed.connect((()=>{const e=this._providers.get(r);e&&(e.dispose(),this._providers.delete(r))}))}catch(t){console.error(`Failed to open connection for ${e.path}.\n:${t}`)}},this._ydriveFileChanged=new r.Signal(this),this._app=e,this._user=e.serviceManager.user,this._trans=t,this._providers=new Map,this.sharedModelFactory=new h(this._onCreate),super.fileChanged.connect(((e,t)=>{this._ydriveFileChanged.emit(t)}))}get providers(){return this._providers}dispose(){this.isDisposed||(this._providers.forEach((e=>e.dispose())),this._providers.clear(),super.dispose())}async get(e,t){if(t&&t.format&&t.type){const s=`${t.format}:${t.type}:${e}`,r=this._providers.get(s);if(r){const[s]=await Promise.all([await this._app.serviceManager.contents.get(e,{...t,content:!1}),r.ready]);return{...s,format:t.format}}}return await this._app.serviceManager.contents.get(e,t)}async listCheckpoints(e){return[]}async save(e,t={}){if(t.format&&t.type){const s=`${t.format}:${t.type}:${e}`;if(this._providers.get(s)){const s={type:t.type,format:t.format,content:!1};return this.get(e,s)}}return this._app.serviceManager.contents.save(e,t)}get fileChanged(){return this._ydriveFileChanged}}class h{constructor(e){this._onCreate=e,this.collaborative=!0,this.documentFactories=new Map}registerDocumentFactory(e,t){if(this.documentFactories.has(e))throw new Error(`The content type ${e} already exists`);this.documentFactories.set(e,t)}createNew(e){if("string"==typeof e.format){if(this.collaborative&&e.collaborative&&this.documentFactories.has(e.contentType)){const t=this.documentFactories.get(e.contentType)(e);return this._onCreate(e,t),t}}else console.warn(`Only defined format are supported; got ${e.format}.`)}}}}]);