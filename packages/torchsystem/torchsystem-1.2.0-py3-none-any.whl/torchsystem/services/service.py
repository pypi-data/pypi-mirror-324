from re import sub
from typing import Any
from collections.abc import Callable
from torchsystem.depends import inject, Provider
from torchsystem.depends import Depends as Depends

class Service:
    """
    A SERVICE is the technical authority for a business capability. And it is the exclusive
    owner of a certain subset of the business data.  It centralizes and organizes domain
    operations, enforces business rules, and coordinates workflows. 

    The `Service` serves as an entry point for the service layer and provides a simple way to
    build stateless logic for executing domain operations.

    Methods:
        register:
            Registers a handler for a specific command or query type. Handles nested or generic annotations.

        handler:
            Decorator for registering a function as a handler.

        handle:
            Executes the handler associated with a given action.

    Example:
        ```python	
        from torch import cuda
        from torchsystem import Depends
        from torchsystem.services import Service

        service = Service()

        def device() -> str:
            raise NotImplementedError('Override this function to return the device')

        @service.handler
        def train(model: Model, data: DataLoader, device: str = Depends(device)):
            # Your training logic here
            ...

        service.dependency_overrides[device] = lambda: 'cuda' if cuda.is_available() else 'cpu'
        ```
    """
    def __init__(
        self, 
        name: str = None,
        *,
        generator: Callable[[str], str] = lambda name: sub(r'_', '-', name),
        provider: Provider = None
    ):
        self.name = name
        self.handlers = dict[str, Callable[..., Any]]()
        self.generator = generator
        self.provider = provider or Provider()

    @property
    def dependency_overrides(self) -> dict:
        """
        Returns the dependency overrides for the service. This is useful for late binding,
        testing and changing the behavior of the service in runtime.

        Returns:
            dict: A dictionary of the dependency map.

        Example:
            ```python
            service = Service()
            ...

            service.dependency_overrides[device] = lambda: 'cuda' if cuda.is_available() else 'cpu'
            ```
        """
        return self.provider.dependency_overrides

    def handler(self, wrapped: Callable[..., Any]) -> Callable[..., Any]:
        """
        Decorator for registering a function as a handler in the service. The handler is
        registered with the name of the function as the key. The handler is also injected
        with the dependencies provided by the service.

        Args:
            wrapped (Callable[..., Any]): The function to be registered as a handler.

        Returns:
            Callable[..., Any]: The injected handler function.
        """
        injected = inject(self.provider)(wrapped)
        self.handlers[self.generator(wrapped.__name__)] = injected
        return injected
    
    def handle(self, action: str, *arguments: Any) -> Any:
        """
        Executes the handler associated with the given action. The action is the generated name 
        from the handler function to be executed. The name is generated by the `generator` function
        provided to the service, which defaults to transforming the function name from snake case
        to kebab case.

        Args:
            action (str): The action to execute the handler for.

        Raises:
            KeyError: If the handler for the action is not found.

        Returns:
            Any: Whatever the handler returns.

        Example:
            ```python
            service = Service()

            @service.handler
            def train(model: Model, data: DataLoader, device: str = Depends(device)):
                # Your training logic here
                ...

            model = Model()
            data = Data()

            service.handle('train', model, data) # train(model, data) will also work
                                                 # but this is usefull when building REST APIs
                                                 # with Command Query Segregation (CQS)
            ```
        """
        handler = self.handlers.get(action, None)
        if not handler:
            raise KeyError(f'Handler not found for action: {action}')
        return handler(*arguments)