"""Read X for llm context"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_read.ipynb.

# %% auto 0
__all__ = ['read_url', 'read_gist', 'read_gh_file', 'read_file', 'is_unicode', 'read_dir', 'read_pdf', 'read_yt_transcript',
           'read_google_sheet', 'gdoc_url_to_parseable', 'read_gdoc', 'gh_ssh_from_gh_url', 'get_default_branch',
           'get_git_repo', 'read_git_path', 'read_gh_repo']

# %% ../nbs/00_read.ipynb 5
import httpx 
import html2text
from fastcore.all import delegates, ifnone

import re, os, glob, string
import requests
import fnmatch, mimetypes

from PyPDF2 import PdfReader
from toolslm.download import html2md, read_html

# %% ../nbs/00_read.ipynb 8
def read_url(url, # url to read
             heavy=False, # Use contactless browser
             sel=None, # Css selector to pull content from
             **kwargs): 
    "Reads a url and converts to markdown"
    if heavy: 
        from playwrightnb import url2md
        url2md(url,sel=ifnone(sel,'body'), **kwargs)
    return read_html(url,**kwargs)

# %% ../nbs/00_read.ipynb 13
def read_gist(url):
    "Returns raw gist content, or None"
    pattern = r'https://gist\.github\.com/([^/]+)/([^/]+)'
    match = re.match(pattern, url)
    if match:
        user, gist_id = match.groups()
        raw_url = f'https://gist.githubusercontent.com/{user}/{gist_id}/raw'
        return httpx.get(raw_url).text
    else:
        return None

# %% ../nbs/00_read.ipynb 19
def read_gh_file(url):
    pattern = r'https://github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.+)'
    replacement = r'https://raw.githubusercontent.com/\1/\2/refs/heads/\3/\4'
    raw_url = re.sub(pattern, replacement, url)
    return httpx.get(raw_url).text

# %% ../nbs/00_read.ipynb 23
def read_file(path):
    return open(path,'r').read()

# %% ../nbs/00_read.ipynb 24
def is_unicode(filepath, sample_size=1024):
    try:
        with open(filepath, 'r') as file:
            sample = file.read(sample_size)
        return True
    except UnicodeDecodeError:
        return False

# %% ../nbs/00_read.ipynb 27
def read_dir(path, 
             exclude_non_unicode=True,
             included_patterns=["*"],
             excluded_patterns=[".git/**"],
             verbose=True,
             as_string=True):
    pattern = '**/*'
    result = {}
    for file_path in glob.glob(os.path.join(path, pattern), recursive=True):
        if any(fnmatch.fnmatch(file_path, pat) for pat in excluded_patterns):
            continue
        if not any(fnmatch.fnmatch(file_path, pat) for pat in included_patterns):
            continue
        if os.path.isfile(file_path):
            if exclude_non_unicode and not is_unicode(file_path):
                continue
            if verbose:
                print(f"Including {file_path}")
            with open(file_path, 'r', errors='ignore') as f:
                result[file_path] = f.read()
    if as_string:
        return '\n'.join([f"--- File: {file_path} ---\n{v}\n--- End of {file_path} ---" for file_path,v in result.items()])
    else:
        return result

# %% ../nbs/00_read.ipynb 30
def read_pdf(file_path: str) -> str:
    with open(file_path, 'rb') as file:
        reader = PdfReader(file)
        return ' '.join(page.extract_text() for page in reader.pages)

# %% ../nbs/00_read.ipynb 33
def read_yt_transcript(yt_url):
    from pytube import YouTube
    from youtube_transcript_api import YouTubeTranscriptApi
    try:
        yt = YouTube(yt_url)
        video_id = yt.video_id
    except Exception as e:
        print(f"An error occurred parsing yt urul: {e}")
        return None
    transcript = YouTubeTranscriptApi.get_transcript(video_id)
    return ' '.join(entry['text'] for entry in transcript) 

# %% ../nbs/00_read.ipynb 36
def read_google_sheet(orig_url):
    sheet_id = orig_url.split('/d/')[1].split('/')[0]
    csv_url = f'https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&id={sheet_id}&gid=0'
    res = requests.get(url=csv_url)
    return res.content

# %% ../nbs/00_read.ipynb 39
def gdoc_url_to_parseable(url):
    pattern = r'(https://docs\.google\.com/document/d/[^/]+)/edit'
    replacement = r'\1/export?format=html'
    return re.sub(pattern, replacement, url)

# %% ../nbs/00_read.ipynb 41
def read_gdoc(url):
    import html2text
    doc_url = url
    doc_id = doc_url.split('/d/')[1].split('/')[0]
    export_url = f'https://docs.google.com/document/d/{doc_id}/export?format=html'
    html_doc_content = requests.get(export_url).text
    doc_content = html2text.html2text(html_doc_content)
    return doc_content

# %% ../nbs/00_read.ipynb 45
import tempfile, subprocess, os, re, shutil
from pathlib import Path

# %% ../nbs/00_read.ipynb 46
def gh_ssh_from_gh_url(gh_repo_address):
    "Given a GH URL or SSH remote address, returns a GH URL or None"
    pattern = r'https://github\.com/([^/]+)/([^/]+)(?:/.*)?'
    if gh_repo_address.startswith("git@github.com:"):
        return gh_repo_address
    elif match := re.match(pattern, gh_repo_address):
        user, repo = match.groups()
        return f'git@github.com:{user}/{repo}.git'
    else:
        # Not a GitHub URL or a GitHub SSH remote address
        return None

def get_default_branch(repo_path):
    "master or main"
    try:
        result = subprocess.run(['git', 'symbolic-ref', 'refs/remotes/origin/HEAD'], 
                                cwd=repo_path, capture_output=True, text=True, check=True)
        return result.stdout.strip().split('/')[-1]
    except subprocess.CalledProcessError:
        return 'main'  # Default to 'main' if we can't determine the branch

def get_git_repo(gh_ssh):
    "Fetchs from a GH SSH address, returns a path"
    repo_name = gh_ssh.split('/')[-1].replace('.git', '')
    cache_dir = Path(os.environ.get('XDG_CACHE_HOME', Path.home() / '.cache')) / 'contextkit_git_clones'
    cache_dir.mkdir(parents=True, exist_ok=True)
    repo_dir = cache_dir / repo_name

    if repo_dir.exists():
        print("Repo already cached. Updating.")
        try:
            subprocess.run(['git', 'fetch'], cwd=repo_dir, check=True, capture_output=True)
            default_branch = get_default_branch(repo_dir)
            subprocess.run(['git', 'reset', '--hard', f'origin/{default_branch}'], 
                           cwd=repo_dir, check=True, capture_output=True)
            return str(repo_dir)
        except subprocess.CalledProcessError:
            shutil.rmtree(repo_dir)  # Remove the cached directory if update fails

    with tempfile.TemporaryDirectory() as temp_dir:
        try:
            print("Cloning repo.")
            subprocess.run(['git', 'clone', gh_ssh], cwd=temp_dir, check=True, capture_output=False)
            cloned_dir = Path(temp_dir) / repo_name
            shutil.move(str(cloned_dir), str(repo_dir))
            return str(repo_dir)
        except subprocess.CalledProcessError as e:
            print(f"Error cloning repo from cwd {temp_dir} with error {e}")
            return None

def read_git_path(path):
    # TODO: ?enhance to read repos more specifically than directories
    return read_dir(path)

# %% ../nbs/00_read.ipynb 47
def read_gh_repo(path_or_url):
    "Repo contents from path, GH URL, or GH SSH address"
    gh_ssh = gh_ssh_from_gh_url(path_or_url)
    print('a')
    print(path_or_url)
    print('b')
    print(get_git_repo(gh_ssh))
    path = path_or_url if not gh_ssh else get_git_repo(gh_ssh)
    return read_git_path(path)
