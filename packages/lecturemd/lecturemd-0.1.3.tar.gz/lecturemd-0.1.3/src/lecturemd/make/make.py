import shutil
import subprocess
import argparse
import sys
from typing import List, Optional
import yaml
from pathlib import Path
import pygmentation.pygmentation as pyg
import datetime
import re

from enum import Enum
import platform
import time

from rich.progress import Progress, TimeElapsedColumn, TextColumn, BarColumn


def format_elapsed_time(t_ns: float) -> str:
    """Format a time in nanoseconds to a human-readable string.

    Parameters
    ----------
    t_ns : float
        The time in nanoseconds to format.

    Returns
    -------
    str
        The formatted time string.
    """    

    timestring = None
    unit = None
    if t_ns < 1e3:
        timestring = f"{t_ns:#.3g}"
        unit = "ns"
    elif t_ns < 1e6:
        timestring = f"{t_ns / 1e3:#.3g}"
        unit = "\xb5s"
    elif t_ns < 1e9:
        timestring = f"{t_ns / 1e6:#.3g}"
        unit = "ms"
    elif t_ns < 60e9:
        timestring = f"{t_ns / 1e9:#.3g}"
        unit = "s"
    elif t_ns < 60e9 * 60:
        m = int(t_ns / 60e9)
        s = int((t_ns - m * 60e9) / 1e9)
        return f"{m}m {s:0>2d}s"
    else:
        h = int(t_ns / 3600e9)
        m = int((t_ns - h * 3600e9) / 60e9)
        s = int((t_ns - h * 3600e9 - m * 60e9) / 1e9)
        return f"{h}h {m:0>2d}m {s:0>2d}s"

    if timestring.endswith("."):
        timestring = timestring[:-1]
    return timestring + " " + unit

from ..platform import Platform, get_platform


operating_system = get_platform()
if operating_system == Platform.UNKNOWN:
    print(
        "Warning: Unsupported or unknown operating system. This can cause unexpected results or unhelpful errors."
    )


def is_installed(program: str) -> bool:
    """Check if a program is installed and available in the PATH.

    Parameters
    ----------
    program : str
        The name of the program to check.

    Returns
    -------
    bool
        True if the program is installed and available, False otherwise.
    """    
    return shutil.which(program) is not None


# If we're on windows, we need to escape backslashes in paths
def escape_path(path: str) -> str:
    """Escape backslashes in a path if the operating system is Windows.

    Parameters
    ----------
    path : str
        The path to escape.

    Returns
    -------
    str
        The escaped path.
    """    
    if operating_system == Platform.WINDOWS:
        return path.replace("\\", "\\\\")
    return path


base_dir = Path(".").resolve()


crossref_metadata = """# pandoc-crossref configs
figPrefix:
  - "figure"
  - "figures"
tblPrefix:
  - "table"
  - "tables"
eqnPrefix:
  - "equation"
  - "equations"
eqnPrefixTemplate: '$$p$$&nbsp;($$i$$)'
equationNumberTeX: '\\\\tag'
eqnIndexTemplate: '$$i$$'

linkReferences: true

subfigureChildTemplate: '<span class="subfigure-name">($$i$$)&nbsp;</span> &nbsp;$$t$$'
subfigureTemplate: '<span class="figure-name">$$figureTitle$$ $$i$$$$titleDelim$$</span> $$t$$'
figureTemplate: '<span class="figure-name">$$figureTitle$$ $$i$$$$titleDelim$$</span> $$t$$'

cref: true
"""


replacements = {
    "latex": {
        "all": [
            # Remove extra spaces before punctuation
            (r"(\\\)|\})\s+([\.,\?])", r"\1\2"),
            # Remove extra spaces after an open bracket
            (r"(\(|\{)\s+", r"\1"),
            # remove par breaks at start and end of environments and macros
            (r"\\begin{(.*?)}\s*", r"\\begin{\1}"),
            (r"^\s*\\end{(.*?)}", r"\\end{\1}"),
            (r"\{\s+\n\n\s*", r"{ "),
            (r"\{\n\n\s*", r"{"),
            (r"\s*\n\n\s+\}", r" }"),
            (r"\s*\n\n\s*\}", r"}"),
            # Change the odd figure format from pandoc-crossref
            (
                r"\\begin\{pandoccrossrefsubfigures\}",
                r"\\begin{figure}[ht!]" + "\n\\\\centering",
            ),
            (r"\\end\{pandoccrossrefsubfigures\}", r"\\end{figure}"),
            # add keepaspectratio to the figures generated by pandoc-crossref
            (
                r"\\includegraphics\[(.*?)\]\{(.*?)\}",
                r"\\includegraphics[\1,keepaspectratio]{\2}",
            ),
        ],
        "notes": [],
        "slides": [
            # we should always have \begin{example}\begin{frame}...\end{frame}\end{example}, not \begin{frame}\begin{example}...\end{example}\end{frame}
            (r"\\begin{frame}\s*\\begin{(example|aside)}(\[.*?\])?", r"\\begin{\1}\2\n\\begin{frame}"),
            (r"\\end{(example|aside)}\s*\\end{frame}", r"\\end{frame}\n\\end{\1}"),
            # We should also have \end{frame}\examplesolution, not \examplesolution\end{frame}
            (r"\\examplesolution(\w*)?\s*\\end{frame}", r"\\end{frame}\n\\examplesolution\1"),
            # If an \item is a display equation, remove the bullet point
            (r"\\item\s*(?=(\\begin{equation}|\{?\\\[))", r"\\item[]"),
            # Remove the automatically added frametitles
            (r"\\begin{frame}((\[.*?\])?){(.*?)}", r"\\begin{frame}\1"),
            # add a \pause to the start of each frame
            (r"\\begin{frame}((\[.*?\])?)", r"\\begin{frame}\1\n\t\\pause\n\t"),
            # Remove `fragile` frame options
            (r"\\begin{frame}\[fragile\]", r"\\begin{frame}"),
        ],
    },
    "html": {
        "all": [
            # Remove extra spaces before punctuation
            (r"([>\)])\s+([^\w<\(])", r"\1\2"),
            # Remove extra spacing around math
            (r"(\W)\s+\\\(", r"\1\\("),
            (r"\\\)\s+([^\w<])", r"\\)\1"),
            # Remove extra spaces between number and punctuation
            (r"(\d)\s+([\.,\?])", r"\1\2"),
            # Remove extra space after open parenthesis
            (r"\(\s+<", r"(<"),
            # Remove colgroup from tables
            (r"<colgroup>.*?</colgroup>", "", re.DOTALL),
        ],
        "notes": [],
        "slides": [],
        "chunked": [],
    },
}


def apply_replacements(content: str, replacements: List) -> str:
    for replacement in replacements:
        content = re.sub(replacement[0], replacement[1], content, **({} if len(replacement) == 2 else {"flags": replacement[2]}))
    return content


def convert_tables(file_content: str) -> str:
    # identify the longtable environments output by pandoc and convert them into a `nicetable` environment. Might use tabularray instead at some point.
    matches = re.finditer(r"\\begin\{longtable\}\[(?P<options>.*?)\]\{(?P<column_spec>.*?)\}\n(?P<contents>.*?)\\end\{longtable\}", file_content, re.DOTALL)
    matches = list(matches)
    if len(matches) == 0:
        return file_content
    
    for match in matches:
        column_spec = match.group("column_spec")
        contents = match.group("contents")

        # remove any non-alpha characters from the column spec
        column_spec = re.sub(r"[^a-zA-Z]", "", column_spec)
        contents = re.sub(r"\\toprule\\noalign{}\s*", "", contents)
        contents = re.sub(r"\\midrule\\noalign{}\s*", "", contents)
        contents = re.sub(r"\\bottomrule\\noalign{}\s*", "", contents)
        contents = re.sub(r"\\endfirsthead\s*", "", contents)
        contents = re.sub(r"\\endhead\s*", "", contents)
        contents = re.sub(r"\\endfoot\s*", "", contents)
        contents = re.sub(r"\\endlastfoot\s*", "", contents)
        contents = contents.rstrip().rstrip("\\\\") # nicetable expects there to be no trailing \\ on the last line
        column_spec = "|" + "|".join(list(column_spec)) + "|"
        nicetable = f"\\begin{{nicetable}}{{{column_spec}}}\n{contents}\\end{{nicetable}}"
        file_content = file_content.replace(match.group(0), nicetable)

    return file_content


def add_figure_cards(file_content: str) -> str:
    # search for any figures, and convert `includgraphics` to `includegraphicscard` within those figures
    matches = re.finditer(r"\\begin\{figure\}.*?\\end\{figure\}", file_content, re.DOTALL)
    pattern = r"\\includegraphics(\[.*?\])?\{(.*?)\}"
    replacement = r"\\includegraphicscard\1{\2}{padding = 2mm}"
    for figure in matches:
        file_content = file_content.replace(figure.group(0), re.sub(pattern, replacement, figure.group(0)))
    return file_content

def check_filter_executable(filter_file: Path):
    # if we're on linux, check if the filter has execute permissions
    if sys.platform == "linux":
        if not filter_file.is_file():
            raise FileNotFoundError("Filter file not found.")
        if not filter_file.stat().st_mode & 0o111:
            filter_file.chmod(0o755)

def parse_args():
    # python3 make.py --keep-temp|-k --log-level=debug|info|warning|error|critical web|pdf [notes|slides|chunked]
    parser = argparse.ArgumentParser(description="Build a lecturemd project")
    parser.add_argument(
        "--keep-temp",
        "-k",
        action="store_true",
        help="Keep temporary files after building.",
    )
    parser.add_argument(
        "--log-level",
        choices=["debug", "info", "warning", "error", "critical"],
        default="debug",
        help="Set the log level.",
    )
    parser.add_argument("output", choices=["web", "pdf", "all"], help="Output format.")
    parser.add_argument(
        "format",
        choices=["notes", "slides", "chunked"],
        nargs="?",
        help="Output type. If unspecified, all are built. `chunked` is only available for web output.",
    )
    args = parser.parse_args()
    if args.output == "pdf" and args.format == "chunked":
        parser.error("Chunked output is only available for web output.")
    return args


def read_settings(base_dir: Path) -> dict:
    """Read the settings file from `.lecturemd/lecturemd.yaml`.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.

    Returns
    -------
    dict
        The settings read from the file.

    Raises
    ------
    FileNotFoundError
        If the settings file is not found.
    FileNotFoundError
        If the settings file is not a file.
    """    
    settings_path = base_dir / ".lecturemd/lecturemd.yaml"
    if not settings_path.exists():
        raise FileNotFoundError("Settings file not found")
    if not settings_path.is_file():
        raise FileNotFoundError("Settings file is not a file")
    with open(settings_path, "r") as f:
        settings = yaml.safe_load(f)
    if settings["general"]["date"] == "today":
        settings["general"]["date"] = datetime.date.today().isoformat()
    return settings


def create_build_dir(build_dir: Path) -> None:
    """Create the build directory if it does not exist.

    Parameters
    ----------
    build_dir : Path
        The build directory to create.

    Raises
    ------
    FileExistsError
        If the build directory already exists but is not a directory.
    """    
    if not build_dir.exists():
        build_dir.mkdir()
        return
    if not build_dir.is_dir():
        raise FileExistsError(
            f'Build directory "{build_dir}" exists but is not a directory'
        )


def copy_figures(base_dir: Path, build_dir: Path) -> None:
    """Copy the figures directory from the base directory to the build directory.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    build_dir : Path
        The build directory into which the figures should be copied.

    Raises
    ------
    FileNotFoundError
        If the figures directory exists but is not a directory.
    """    
    figures_dir = base_dir / "figures"
    if not figures_dir.exists():
        return
    if not figures_dir.is_dir():
        raise FileNotFoundError(
            f'Figures directory "{figures_dir}" exists but is not a directory'
        )
    target_figures_dir = build_dir / "figures"
    shutil.copytree(figures_dir, target_figures_dir, dirs_exist_ok=True)


def convert_file(source: Path, extension: str, dest: Optional[Path] = None) -> Path:
    """Convert a file to a different format. Usually, this will be converting a .pdf file into a format more suitable for web output.

    Parameters
    ----------
    source : Path
        The source file to convert.
    extension : str
        The extension to convert the file to.
    dest : Optional[Path] = None
        The destination file to save the converted file to. If not specified, the destination file will be the source file with the new extension.

    Returns
    -------
    Path
        The path to the converted file.

    Raises
    ------
    FileNotFoundError
        If the conversion program is not installed.
    Exception
        If the operating system could not be determined.
    """    
    if not extension.startswith("."):
        extension = "." + extension
    if dest is None:
        dest = source.with_suffix(extension)
    if extension == ".svg":
        if is_installed("pdf2svg"):
            subprocess.run(["pdf2svg", source, dest])
            return dest
        if is_installed("inkscape"):
            subprocess.run(
                ["inkscape", source, "--export-type=svg", "--export-filename=" + str(dest)]
            )
            return dest
        raise FileNotFoundError(
            "Both pdf2svg and inkscape are not installed. Unable to convert file for web output."
        )

    if operating_system in [Platform.LINUX, Platform.MAC]:
        if not is_installed("convert"):
            raise FileNotFoundError(
                "ImageMagick is not installed. Unable to convert file for web output."
            )
        subprocess.run(["convert", "-density", "300", "-quality", "100", source, dest])
        return dest
    if operating_system == Platform.WINDOWS:
        if not is_installed("magick"):
            raise FileNotFoundError(
                "ImageMagick is not installed. Unable to convert file for web output."
            )
        subprocess.run(["magick", "-density", "300", "-quality", "100", source, dest])
        return dest
    raise Exception(
        "Unsupported or unknown operating system. Unable to convert file for web output."
    )


def convert_figures(build_dir: Path, extension: str) -> None:
    """Convert all .pdf files in the figures directory to a different format.

    Parameters
    ----------
    build_dir : Path
        The build directory containing the figures directory.
    extension : str
        The extension to convert the files to.
    """    
    if not extension.startswith("."):
        extension = "." + extension
    figures_dir = build_dir / "figures"
    for figure in figures_dir.iterdir():
        if not figure.is_file():
            continue
        if not figure.suffix == ".pdf":
            continue
        convert_file(figure, extension)


def copy_logo(build_dir: Path, logo: dict, extension: str) -> dict:
    """Copy the logo files to the build directory and convert them to a different format if necessary.

    Parameters
    ----------
    build_dir : Path
        The build directory to copy the logo files to.
    logo : dict
        The logo dictionary containing the paths to the main and footer logos.
    extension : str
        The extension to convert the files to.

    Returns
    -------
    dict
        The logo dictionary containing the paths to the copied and converted logo files.

    Raises
    ------
    FileExistsError
        If the logo directory exists but is not a directory.
    FileNotFoundError
        If the main or footer logo file is not found.
    """    
    if logo["main logo"] is None and logo["footer logo"] is None:
        return logo
    if not extension.startswith("."):
        extension = "." + extension
    logo_dir = build_dir / "figures" / "logo"
    if not logo_dir.exists():
        logo_dir.mkdir()
    if not logo_dir.is_dir():
        raise FileExistsError(
            f'Logo directory "{logo_dir}" exists but is not a directory'
        )
    logos = {}
    for logo_type in ["main logo", "footer logo"]:
        logo_file = logo[logo_type]
        if logo_file is None:
            logos[logo_type] = None
            continue
        logo_file = Path(logo_file)
        if not logo_file.exists():
            raise FileNotFoundError(f'Logo file "{logo_file}" not found')
        if not logo_file.is_file():
            raise FileNotFoundError(f'Logo file "{logo_file}" is not a file')
        # move the file to the logo directory
        new_logo_file = logo_dir / logo_file.name
        shutil.copy(logo_file, new_logo_file)
        logos[logo_type] = {"pdf": logo_dir / new_logo_file.name}
        # if it's a pdf, convert the file to the specified extension
        if logo_file.suffix == ".pdf":
            new_logo_file = convert_file(new_logo_file, extension)
            logos[logo_type]["web"] = "figures/logo/" + new_logo_file.name
        else:
            logos[logo_type]["web"] = "figures/logo/" + new_logo_file.name
    return logos


def copy_styles(base_dir: Path, styles_dir: Path) -> None:
    """Copy the styles directory from the base directory to the build directory.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    styles_dir : Path
        The build directory into which the styles should be copied.

    Raises
    ------
    FileExistsError
        If the styles directory exists but is not a directory.
    FileNotFoundError
        If the styles directory is not found.
    """    
    if not styles_dir.exists():
        styles_dir.mkdir()
    if not styles_dir.is_dir():
        raise FileExistsError(
            f'Styles directory "{styles_dir}" exists but is not a directory'
        )
    styles_src = base_dir / "styles"
    if not styles_src.exists():
        return
    if not styles_src.is_dir():
        raise FileNotFoundError(
            f'Styles directory "{styles_src}" exists but is not a directory'
        )
    # copy the entire directory
    shutil.copytree(styles_src, styles_dir, dirs_exist_ok=True)


def create_colour_scheme(styles_dir: Path, colour_scheme: str) -> None:
    """Use pygmentation to create the colour scheme files for the specified colour scheme and save it as a .css and .tex file.

    Parameters
    ----------
    styles_dir : Path
        The directory to save the colour scheme files to.
    colour_scheme : str
        The colour scheme to use.
    """    
    pyg.set_scheme(colour_scheme)
    scheme = pyg.get_scheme()

    with open(styles_dir / "colour_scheme.css", "w+") as f:
        f.write(scheme.to_css())

    with open(styles_dir / "colour_scheme.tex", "w+") as f:
        f.write(scheme.to_latex())


def sanitize_filename(filename: str) -> str:
    """Sanitize a filename by removing any characters that are not alphanumeric, _, or -.

    Parameters
    ----------
    filename : str
        The filename to sanitize.

    Returns
    -------
    str
        The sanitized filename.
    """    
    return "".join([c if c.isalnum() or c in ["_", "-"] else "_" for c in filename])


def resolve_filter_path(file_path: str, is_post_action: bool = False) -> str:
    """Resolve the path of a filter file. Files which start `$lecturemd` are resolved relative to the filter directory in the lecturemd package, not the current working directory.

    **Note:** pandoc-crossref is a special case. The filter path `$lecturemd/pandoc-crossref` will be resolved to the correct executable based on the operating system.

    Parameters
    ----------
    file_path : str
        The path of the filter file.
    is_post_action : bool = False
        If true, the file is assumed to be in `Path(__file__).parent/'post'` instead of `Path(__file__).parent/'filters'`.

    Returns
    -------
    str
        The resolved path of the filter file.

    Raises
    ------
    FileNotFoundError
        If the filter file is not found.
    FileNotFoundError
        If the filter file is not a file.
    """    
    if is_post_action:
        filter_dir = Path(__file__).parent / "post"
    else:
        filter_dir = Path(__file__).parent / "filters"
    if file_path == "$lecturemd/pandoc-crossref":
        if operating_system == Platform.WINDOWS:
            return str(filter_dir / "pandoc-crossref.exe")
        if operating_system == Platform.MAC:
            return str(filter_dir / "pandoc-crossref-mac")
        if operating_system == Platform.LINUX:
            return str(filter_dir / "pandoc-crossref")
        raise FileNotFoundError("Unsupported or unknown operating system - could not resolve pandoc-crossref path")
    if file_path.startswith("$lecturemd"):
        filter_file = filter_dir / file_path[len("$lecturemd/") :]
        filter_file = filter_file.resolve().absolute()
        if not filter_file.exists():
            if operating_system == Platform.WINDOWS:
                windows_filter_file = filter_file.with_suffix(".exe")
                if windows_filter_file.exists():
                    filter_file = windows_filter_file
                else:
                    raise FileNotFoundError(f'Filter file "{filter_file}" not found')
        if not filter_file.is_file():
            raise FileNotFoundError(f'Filter file "{filter_file}" is not a file')
        return str(filter_file)
    return file_path


def run_pandoc(input_file: str, defaults_file: Path, use_pyndoc: Optional[bool] = False, logging_level: str = "DEBUG") -> None:
    """Run pandoc (or pyndoc) to convert a file using the specified defaults file.

    Parameters
    ----------
    input_file : str
        The input file to convert.
    defaults_file : Path
        The path to the defaults file to use. This is passed as the `--defaults` argument to pandoc.
    use_pyndoc : Optional[bool], optional
        Whether to use pyndoc instead of pandoc, by default False

    Raises
    ------
    ValueError
        If pandoc fails to run.
    """    
    if use_pyndoc:
        executable = sys.executable
        if not executable:
            raise ValueError("Python executable not found")
        result = subprocess.run(
            [
                executable,
                "-m",
                "pyndoc",
                "--log-level",
                logging_level.lower(),
                "--preprocess",
                "--defaults",
                defaults_file,
                input_file,
            ],
            capture_output=True,
        )
    else:
        result = subprocess.run(
            ["pandoc", "--defaults", defaults_file, input_file], capture_output=True
        )
    if result.returncode != 0:
        print(result.stderr.decode("utf-8"))
        raise ValueError("Pandoc failed to run")


def run_latexmk(tex_file: Path, keep_tex_temp: bool = False) -> None:
    """Run latexmk to compile a .tex file.

    Parameters
    ----------
    tex_file : Path
        The .tex file to compile.

    Raises
    ------
    ValueError
        If latexmk fails to run.
    """    
    result = subprocess.run(
        [
            "latexmk", 
            "-pdf", 
            "-cd", 
            "-f", 
            "-interaction=nonstopmode", 
            "-halt-on-error", 
            # set max runs to 10
            '-e', 
            '$max_repeat=10',
            tex_file
        ],
        capture_output=True,
    )
    if result.returncode != 0:
        print(result.stderr.decode("utf-8"))
        raise ValueError("Latexmk failed to run")
    if not keep_tex_temp:
        # use latexmk -c to clean up
        subprocess.run(["latexmk", "-c", "-cd", tex_file], capture_output=True)
        # remove the tex file
        tex_file.unlink()


def gather_filters(filters_list: List) -> List:
    """Gather the filters from a list of filters and sort them by priority.

    Parameters
    ----------
    filters_list : List
        The list of filters to gather.

    Returns
    -------
    List
        The sorted list of filters.

    Raises
    ------
    ValueError
        If the filter dictionary has an invalid structure.
    """    
    filters = []
    for filter in filters_list:
        if isinstance(filter, dict):
            if len(filter) != 1:
                raise ValueError("Invalid filter dictionary")
            for key, value in filter.items():
                filters.append((key, value))
        else:
            filters.append((filter, 0))

    # sort the filters by priority
    filters.sort(key=lambda x: x[1])
    return [escape_path(resolve_filter_path(f[0])) for f in filters]


def write_crossref() -> Path:
    """Write the crossref metadata to a file.

    Returns
    -------
    Path
        The path to the crossref metadata file.
    """    
    crossref_file = base_dir / ".lecturemd" / "defaults" / "crossref.yaml"
    if not crossref_file.parent.exists():
        crossref_file.parent.mkdir(parents=True)
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)
    return crossref_file


class TimedPostProcessing:
    def __init__(self, progress: Progress, target: str):
        self.progress = progress
        self.target = target

    def __enter__(self):
        self.task_id = self.progress.add_task(f"Applying {self.target}", total=None)
        self.start_time = time.perf_counter_ns()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.end_time = time.perf_counter_ns()
        self.progress.start_task(self.task_id)
        self.progress.update(self.task_id, total=1, completed=1, visible=False)
        self.progress.console.print(
            f"\tApplied {self.target} in {format_elapsed_time(self.end_time - self.start_time)}"
        )


def build_pdf_notes(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict, progress: Progress, logging_level: str = "DEBUG", keep_tex_temp: bool = False
) -> None:
    """Build the PDF notes from the settings and logos.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    build_dir : Path
        The build directory to save the notes to.
    settings : dict
        The settings dictionary.
    logos : dict
        The logos dictionary.
    """    
    # Take the name from the subtitle if it exists, or the title if not. If neither exist, use "latex_notes.tex"
    if settings["general"]["subtitle"] is not None and settings["general"]["subtitle"] != "":
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_notes.tex"
        )
    elif settings["general"]["title"] is not None:
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_notes.tex"
        )
    else:
        tex_file = build_dir / "latex_notes.tex"
    
    pandoc_settings = {
        "writer": "latex",
        "standalone": True,
        "template": escape_path(str(base_dir / ".lecturemd/templates/latex_notes.tex")),
        "output-file": escape_path(str(tex_file)),
        "columns": 1000, # We want to prevent the default line wrapping in pandoc. This should be large enough to prevent wrapping.
        "default-image-extension": settings["latex"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
    }

    # Add the headers, in order
    header_includes = []
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["latex"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["latex"]["notes"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["general"]["maths preamble"]]
    )

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = escape_path(str(logos["main logo"]["pdf"]))
        if operating_system == Platform.WINDOWS:
            pandoc_settings["metadata"]["main-logo"] = pandoc_settings["metadata"]["main-logo"].replace("\\", "/").replace("//", "/")
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = escape_path(str(logos["footer logo"]["pdf"]))
        if operating_system == Platform.WINDOWS:
            pandoc_settings["metadata"]["footer-logo"] = pandoc_settings["metadata"]["footer-logo"].replace("\\", "/").replace("//", "/")

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["latex"]["filters"]
        + settings["latex"]["notes"]["filters"]
    )

    for filter in pandoc_settings["filters"]:
        check_filter_executable(Path(filter))

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [escape_path(str(crossref_file))]

    defaults_file = base_dir / ".lecturemd" / "defaults" / "pdf_notes.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
        logging_level
    )

    with open(tex_file, "r") as f:
        content = f.read()

    # The default output from pandoc (and especially pandoc-crossref) has a few issues, so we correct them in post before running latexmk (This is why we don't directly call pandoc with pdf output).

    content = apply_replacements(content, replacements["latex"]["all"] + replacements["latex"]["notes"])

    # content = convert_tables(content)
    content = add_figure_cards(content)

    with open(tex_file, "w+") as f:
        f.write(content)


    # collect all post-action scripts
    scripts = settings["latex"]["notes"].get("post", []) + settings["latex"].get("post", []) + settings["general"].get("post", [])
    scripts = [{script: 0} if isinstance(script, str) else script for script in scripts]
    scripts.sort(key=lambda x: list(x.values())[0])
    scripts = [tuple(script.keys())[0] for script in scripts]
    # run each post-processing script in order, passing the tex file as the first argument
    for script in scripts:
        script_path = resolve_filter_path(script, True)
        with TimedPostProcessing(progress, script):
            result = subprocess.run([script_path, tex_file], capture_output=True)
            if result.returncode != 0:
                print(result.stderr.decode("utf-8"))
                raise ValueError(f"Post-processing script {script} failed to run")

    run_latexmk(tex_file, keep_tex_temp)


def build_pdf_slides(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict, progress: Progress, logging_level: str = "DEBUG", keep_tex_temp: bool = False
) -> None:
    """Build the PDF slides from the settings and logos.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    build_dir : Path
        The build directory to save the slides to.
    settings : dict
        The settings dictionary.
    logos : dict
        The logos dictionary.
    """    
    if settings["general"]["subtitle"] is not None and settings["general"]["subtitle"] != "":
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_slides.tex"
        )
    elif settings["general"]["title"] is not None:
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_slides.tex"
        )
    else:
        tex_file = build_dir / "latex_slides.tex"
    pandoc_settings = {
        "writer": "beamer",
        "standalone": True,
        "template": escape_path(str(base_dir / ".lecturemd/templates/latex_slides.tex")),
        "output-file": escape_path(str(tex_file)),
        "columns": 1000,
        "default-image-extension": settings["latex"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "slide-level": 4,
        "incremental": True,
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [escape_path(str(crossref_file))]

    header_includes = []
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["latex"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["latex"]["slides"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["general"]["maths preamble"]]
    )

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = escape_path(str(logos["main logo"]["pdf"]))
        if operating_system == Platform.WINDOWS:
            pandoc_settings["metadata"]["main-logo"] = pandoc_settings["metadata"]["main-logo"].replace("\\", "/")
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = escape_path(str(logos["footer logo"]["pdf"]))
        if operating_system == Platform.WINDOWS:
            pandoc_settings["metadata"]["footer-logo"] = pandoc_settings["metadata"]["footer-logo"].replace("\\", "/")

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["latex"]["filters"]
        + settings["latex"]["slides"]["filters"]
    )

    for filter in pandoc_settings["filters"]:
        check_filter_executable(Path(filter))

    defaults_file = base_dir / ".lecturemd" / "defaults" / "pdf_slides.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
        logging_level
    )

    with open(tex_file, "r") as f:
        content = f.read()

    content = apply_replacements(content, replacements["latex"]["all"] + replacements["latex"]["slides"])

    content = convert_tables(content)
    content = add_figure_cards(content)

    with open(tex_file, "w+") as f:
        f.write(content)

    # collect all post-action scripts
    scripts = settings["latex"]["slides"].get("post", []) + settings["latex"].get("post", []) + settings["general"].get("post", [])
    scripts = [{script: 0} if isinstance(script, str) else script for script in scripts]
    scripts.sort(key=lambda x: list(x.values())[0])
    scripts = [tuple(script.keys())[0] for script in scripts]
    # run each post-processing script in order, passing the tex file as the first argument
    for script in scripts:
        script_path = resolve_filter_path(script, True)
        with TimedPostProcessing(progress, script):
            result = subprocess.run([script_path, tex_file], capture_output=True)
            if result.returncode != 0:
                print(result.stderr.decode("utf-8"))
                raise ValueError(f"Post-processing script {script} failed to run")

    run_latexmk(tex_file, keep_tex_temp)

    if not keep_tex_temp:
        # remove .nav, .snm, .vrb files
        for file in build_dir.glob("*.nav"):
            file.unlink()
        for file in build_dir.glob("*.snm"):
            file.unlink()
        for file in build_dir.glob("*.vrb"):
            file.unlink()


def build_web_notes(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict, progress: Progress, logging_level: str = "DEBUG"
) -> None:
    """Build the web notes from the settings and logos.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    build_dir : Path
        The build directory to save the notes to.
    settings : dict
        The settings dictionary.
    logos : dict
        The logos dictionary.
    """    
    if settings["general"]["subtitle"] is not None and settings["general"]["subtitle"] != "":
        html_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_notes.html"
        )
    elif settings["general"]["title"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_notes.html"
        )
    else:
        html_file = build_dir / "html_notes.html"

    pandoc_settings = {
        "writer": "html",
        "standalone": True,
        "template": escape_path(str(base_dir / ".lecturemd/templates/html_notes.html")),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": escape_path(str(html_file)),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
            "maths-preambles": settings["general"]["maths preamble"],
        },
        "toc": True,
        "toc-depth": 4,
        "css": settings["html"]["styles"] + settings["html"]["notes"]["styles"],
        "reference-location": "section",
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [escape_path(str(crossref_file))]

    header_includes = []
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["html"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["html"]["notes"]["preamble"]]
    )
   
    
    # We're not using --include-in-header for the maths preambles so that we're
    # able to separate them and force them into math mode for mathjax, and also
    # hide them while they're loading. This means that we need to add their
    # *content* to the metadata instead of the file path, and that any newlines
    # will be removed by pandoc. We'll split them into separate lines in the
    # template. This leads to somewhat ridiculous looking defaults files, but it
    # seems to be the only way to handle this.
    maths_preambles = []
    for fname in settings["general"]["maths preamble"]:
        with open(base_dir / fname, "r") as f:
            content = f.read()
        maths_preambles.extend(content.split("\n")) # use a new list element for each line so that pandoc doesn't gobble newlines

    pandoc_settings["metadata"]["maths-preambles"] = maths_preambles

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = escape_path(str(logos["main logo"]["web"]))
        if operating_system == Platform.WINDOWS:
            pandoc_settings["metadata"]["main-logo"] = pandoc_settings["metadata"]["main-logo"].replace("\\", "/").replace("//", "/")
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = escape_path(str(logos["footer logo"]["web"]))
        if operating_system == Platform.WINDOWS:
            pandoc_settings["metadata"]["footer-logo"] = pandoc_settings["metadata"]["footer-logo"].replace("\\", "/").replace("//", "/")

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["html"]["filters"]
        + settings["html"]["notes"]["filters"]
    )

    for filter in pandoc_settings["filters"]:
        check_filter_executable(Path(filter))

    defaults_file = base_dir / ".lecturemd" / "defaults" / "web_notes.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
        logging_level
    )

    with open(html_file, "r") as f:
        content = f.read()

    content = apply_replacements(content, replacements["html"]["all"] + replacements["html"]["notes"])

    with open(html_file, "w+") as f:
        f.write(content)

    # collect all post-action scripts
    scripts = settings["html"]["notes"].get("post", []) + settings["html"].get("post", []) + settings["general"].get("post", [])
    scripts = [{script: 0} if isinstance(script, str) else script for script in scripts]
    scripts.sort(key=lambda x: list(x.values())[0])
    scripts = [tuple(script.keys())[0] for script in scripts]
    # run each post-processing script in order, passing the tex file as the first argument
    for script in scripts:
        script_path = resolve_filter_path(script, True)
        with TimedPostProcessing(progress, script):
            result = subprocess.run([script_path, html_file], capture_output=True)
            if result.returncode != 0:
                print(result.stderr.decode("utf-8"))
                raise ValueError(f"Post-processing script {script} failed to run")



def build_web_slides(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict, progress: Progress, logging_level: str = "DEBUG"
) -> None:
    """Build the web slides from the settings and logos.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    build_dir : Path
        The build directory to save the slides to.
    settings : dict
        The settings dictionary.
    logos : dict
        The logos dictionary.
    """    
    if settings["general"]["subtitle"] is not None and settings["general"]["subtitle"] != "":
        html_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_slides.html"
        )
    elif settings["general"]["title"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_slides.html"
        )
    else:
        html_file = build_dir / "web_slides.html"

    pandoc_settings = {
        "writer": "revealjs",
        "standalone": True,
        "template": escape_path(str(base_dir / ".lecturemd/templates/html_slides.html")),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": escape_path(str(html_file)),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
            "disableLayout": False,
            "width": 1080,
        },
        "slide-level": 3,
        "incremental": True,
        "css": settings["html"]["styles"] + settings["html"]["slides"]["styles"],
        "reference-location": "section",
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [escape_path(str(crossref_file))]

    header_includes = []
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["html"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["html"]["slides"]["preamble"]]
    )
   
    
    # We're not using --include-in-header for the maths preambles so that we're
    # able to separate them and force them into math mode for mathjax, and also
    # hide them while they're loading. This means that we need to add their
    # *content* to the metadata instead of the file path, and that any newlines
    # will be removed by pandoc. We'll split them into separate lines in the
    # template. This leads to somewhat ridiculous looking defaults files, but it
    # seems to be the only way to handle this.
    maths_preambles = []
    for fname in settings["general"]["maths preamble"]:
        with open(base_dir / fname, "r") as f:
            content = f.read()
        maths_preambles.extend(content.split("\n")) # use a new list element for each line so that pandoc doesn't gobble newlines

    pandoc_settings["metadata"]["maths-preambles"] = maths_preambles

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = escape_path(str(logos["main logo"]["web"]))
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = escape_path(str(logos["footer logo"]["web"]))

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["html"]["filters"]
        + settings["html"]["slides"]["filters"]
    )

    for filter in pandoc_settings["filters"]:
        check_filter_executable(Path(filter))

    defaults_file = base_dir / ".lecturemd" / "defaults" / "web_slides.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
        logging_level
    )

    with open(html_file, "r") as f:
        content = f.read()

    content = apply_replacements(content, replacements["html"]["all"] + replacements["html"]["slides"])

    with open(html_file, "w+") as f:
        f.write(content)


    # collect all post-action scripts
    scripts = settings["html"]["slides"].get("post", []) + settings["html"].get("post", []) + settings["general"].get("post", [])
    scripts = [{script: 0} if isinstance(script, str) else script for script in scripts]
    scripts.sort(key=lambda x: list(x.values())[0])
    scripts = [tuple(script.keys())[0] for script in scripts]
    # run each post-processing script in order, passing the tex file as the first argument
    for script in scripts:
        script_path = resolve_filter_path(script, True)
        with TimedPostProcessing(progress, script):
            result = subprocess.run([script_path, html_file], capture_output=True)
            if result.returncode != 0:
                print(result.stderr.decode("utf-8"))
                raise ValueError(f"Post-processing script {script} failed to run")


def build_web_chunked(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict, progress: Progress, logging_level: str = "DEBUG"
) -> None:
    """Build the web chunked output from the settings and logos.

    Parameters
    ----------
    base_dir : Path
        The base directory of the project.
    build_dir : Path
        The build directory to save the chunked output to.
    settings : dict
        The settings dictionary.
    logos : dict
        The logos dictionary.
    """    
    if settings["general"]["subtitle"] is not None and settings["general"]["subtitle"] != "":
        html_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_chunked"
        )
    elif settings["general"]["title"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_chunked"
        )
    else:
        html_file = build_dir / "web_chunked"

    # if the directory already exists, pandoc will throw an error. We need to remove it (recursively)
    if html_file.exists():
        if html_file.is_dir():
            shutil.rmtree(html_file)
        else:
            html_file.unlink()

    pandoc_settings = {
        "writer": "chunkedhtml",
        "standalone": True,
        "template": escape_path(str(base_dir / ".lecturemd/templates/html_chunked.html")),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": escape_path(str(html_file)),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "resource-path": ["build"],
        "split-level": 3,
        "toc": True,
        "css": settings["html"]["styles"] + settings["html"]["notes"]["styles"],
        "reference-location": "section",
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [escape_path(str(crossref_file))]

    header_includes = []
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["html"]["preamble"]]
    )
    header_includes.extend(
        [escape_path(str(base_dir / fname)) for fname in settings["html"]["notes"]["preamble"]]
    )
   
    
    # We're not using --include-in-header for the maths preambles so that we're
    # able to separate them and force them into math mode for mathjax, and also
    # hide them while they're loading. This means that we need to add their
    # *content* to the metadata instead of the file path, and that any newlines
    # will be removed by pandoc. We'll split them into separate lines in the
    # template. This leads to somewhat ridiculous looking defaults files, but it
    # seems to be the only way to handle this.
    maths_preambles = []
    for fname in settings["general"]["maths preamble"]:
        with open(base_dir / fname, "r") as f:
            content = f.read()
        maths_preambles.extend(content.split("\n")) # use a new list element for each line so that pandoc doesn't gobble newlines

    pandoc_settings["metadata"]["maths-preambles"] = maths_preambles

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = escape_path(str(logos["main logo"]["web"]))
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = escape_path(str(logos["footer logo"]["web"]))

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["html"]["filters"]
        + settings["html"]["notes"]["filters"]
    )

    for filter in pandoc_settings["filters"]:
        check_filter_executable(Path(filter))

    defaults_file = base_dir / ".lecturemd" / "defaults" / "web_chunked.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
        logging_level
    )

    # copy the `build/styles` directory into the html_file directory
    shutil.copytree(
        base_dir / "build" / "styles", html_file / "styles", dirs_exist_ok=True
    )

    # # same with the figures logo directory
    logo_source_dir = base_dir / "build" / "figures" / "logo"
    if logo_source_dir.exists():
        shutil.copytree(logo_source_dir, html_file / "figures/logo", dirs_exist_ok=True)

    files = [f for f in html_file.iterdir() if f.is_file() and f.suffix == ".html"]

    for file in files:
        with open(file, "r") as f:
            content = f.read()

        content = apply_replacements(content, replacements["html"]["all"] + replacements["html"]["chunked"])

        with open(file, "w+") as f:
            f.write(content)

    # collect all post-action scripts
    scripts = settings["html"]["notes"].get("post", []) + settings["html"].get("post", []) + settings["general"].get("post", [])
    scripts = [{script: 0} if isinstance(script, str) else script for script in scripts]
    scripts.sort(key=lambda x: list(x.values())[0])
    scripts = [tuple(script.keys())[0] for script in scripts]

    for script in scripts:
        script_path = resolve_filter_path(script, True)
        with TimedPostProcessing(progress, script):
            for file in files:
                result = subprocess.run([script_path, file], capture_output=True)
                if result.returncode != 0:
                    print(result.stderr.decode("utf-8"))
                    raise ValueError(f"Post-processing script {script} failed to run on file {file}")



class TimedBuild:
    def __init__(self, progress: Progress, target: str):
        self.progress = progress
        self.target = target

    def __enter__(self):
        self.task_id = self.progress.add_task(f"Building {self.target}", total=None)
        self.start_time = time.perf_counter_ns()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.end_time = time.perf_counter_ns()
        self.progress.start_task(self.task_id)
        self.progress.update(self.task_id, total=1, completed=1, visible=False)
        self.progress.console.print(
            f"Built {self.target} in {format_elapsed_time(self.end_time - self.start_time)}"
        )


def main(
    build_dir: Path,
    output: str,
    format: str | None,
    keep_temp: bool = False,
    logging_level: str = "debug",
    keep_tex_temp: bool = False,
):
    build_dir: Path = base_dir / "build"
    styles_dir = build_dir / "styles"
    settings: dict = read_settings(base_dir)
    create_build_dir(build_dir)
    copy_figures(base_dir, build_dir)
    if output in ["web", "all"]:
        convert_figures(build_dir, settings["html"]["figure extension"])
    logos = copy_logo(
        build_dir, settings["general"]["logo"], settings["html"]["figure extension"]
    )
    copy_styles(base_dir, styles_dir)
    create_colour_scheme(styles_dir, settings["general"]["colour scheme"])
    with Progress(
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TimeElapsedColumn(),
    ) as progress:
        if output in ["pdf", "all"]:
            if format is None or format == "notes":
                with TimedBuild(progress, "PDF notes"):
                    build_pdf_notes(base_dir, build_dir, settings, logos, progress, logging_level, keep_tex_temp)
            if format is None or format == "slides":
                with TimedBuild(progress, "PDF slides"):
                    build_pdf_slides(base_dir, build_dir, settings, logos, progress, logging_level, keep_tex_temp)
        if output in ["web", "all"]:
            if format is None or format == "notes":
                with TimedBuild(progress, "Web notes"):
                    build_web_notes(base_dir, build_dir, settings, logos, progress, logging_level)
            if format is None or format == "slides":
                with TimedBuild(progress, "Web slides"):
                    build_web_slides(base_dir, build_dir, settings, logos, progress, logging_level)
            if format is None or format == "chunked":
                with TimedBuild(progress, "Web chunked notes"):
                    build_web_chunked(base_dir, build_dir, settings, logos, progress, logging_level)
    # remove any log files we generated. filter.log, pyndoc.*.log
    if not keep_temp:
        for file in base_dir.glob("filter.log"):
            file.unlink()
        for file in base_dir.glob("pyndoc.*.log"):
            file.unlink()
        for file in base_dir.glob("pyndoc.log"):
            file.unlink()


if __name__ == "__main__":
    args = parse_args()
    main(args.output, args.format, args.logging_level)
