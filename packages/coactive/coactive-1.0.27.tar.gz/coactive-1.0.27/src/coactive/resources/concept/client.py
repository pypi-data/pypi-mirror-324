# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.not_found_error import NotFoundError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.candidates_to_label import CandidatesToLabel
from ...types.concept import Concept
from ...types.concept_label_enum import ConceptLabelEnum
from ...types.concept_label_request import ConceptLabelRequest
from ...types.concept_prediction_response import ConceptPredictionResponse
from ...types.error_response import ErrorResponse
from ...types.http_validation_error import HttpValidationError
from ...types.paged_concept_labels import PagedConceptLabels
from ...types.paged_concepts import PagedConcepts

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ConceptClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        datasets: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
    ) -> PagedConcepts:
        """
        Get paginated concepts, optionally filtered by datasets

        Parameters:
            - datasets: typing.Optional[typing.Union[str, typing.List[str]]]. Datasets to use to filter concepts

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/concepts"),
            params=remove_none_from_dict({"datasets": datasets, "offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedConcepts, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        threshold: typing.Optional[float] = OMIT,
        regularization: typing.Optional[float] = OMIT,
        dataset_id: str,
    ) -> Concept:
        """
        Create a new concept

        Parameters:
            - name: str. The name of the concept, which will become available as the column name in SQL

            - description: typing.Optional[str]. A description for the concept

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - regularization: typing.Optional[float]. How strongly the model adapts to the training labels. Regularization strength. Lower value means the model fits more heavily to the training data

            - dataset_id: str. The id of the dataset
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.create(
            name="TheNorth",
            description="Screenshots and clips from Game of Thrones that take place in the North",
            threshold=0.8,
            regularization=0.0625,
            dataset_id="c40276f0-024b-4a3f-b3e6-dcf0d304843e",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "datasetId": dataset_id}
        if description is not OMIT:
            _request["description"] = description
        if threshold is not OMIT:
            _request["threshold"] = threshold
        if regularization is not OMIT:
            _request["regularization"] = regularization
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/concepts"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, concept_id: str) -> Concept:
        """
        Get concept

        Parameters:
            - concept_id: str. The unique identifier for the concept
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.get(
            concept_id="concept_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, concept_id: str) -> typing.Any:
        """
        Delete concept

        Parameters:
            - concept_id: str. The unique identifier for the concept
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.delete(
            concept_id="concept_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        concept_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        threshold: typing.Optional[float] = OMIT,
        regularization: typing.Optional[float] = OMIT,
    ) -> Concept:
        """
        Update concept

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - name: typing.Optional[str]. A replacement name for the concept

            - description: typing.Optional[str]. A replacement description for the concept

            - threshold: typing.Optional[float]. A replacement decision threshold for the concept

            - regularization: typing.Optional[float]. How strongly the model adapts to the training labels. Regularization strength. Lower value means the model fits more heavily to the training data
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.update(
            concept_id="concept_id",
            name="TheNorth",
            description="Screenshots and clips from Game of Thrones that take place in the North",
            threshold=0.8,
            regularization=0.0625,
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        if threshold is not OMIT:
            _request["threshold"] = threshold
        if regularization is not OMIT:
            _request["regularization"] = regularization
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_labels(
        self,
        concept_id: str,
        *,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        labels_to_include: typing.Optional[typing.Union[ConceptLabelEnum, typing.List[ConceptLabelEnum]]] = None,
    ) -> PagedConceptLabels:
        """
        Get all labels for a concept

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return

            - labels_to_include: typing.Optional[typing.Union[ConceptLabelEnum, typing.List[ConceptLabelEnum]]]. List of labels types to include, leave blank to return all
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.get_labels(
            concept_id="concept_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/labels"),
            params=remove_none_from_dict({"offset": offset, "limit": limit, "labels_to_include": labels_to_include}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedConceptLabels, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_labels(
        self,
        concept_id: str,
        *,
        labels: typing.List[ConceptLabelRequest],
        autosampled_num_negative_labels: typing.Optional[int] = OMIT,
    ) -> Concept:
        """
        Update labels for a concept. Label requests containing coactive image ids or image paths already in use will overwrite existing labels. Label requests with an empty label value will delete an existing label for that image/keyframe identifier.

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - labels: typing.List[ConceptLabelRequest]. Labels for the concept. A label with an empty label value will delete any existing labels associate with the provided image or keyframe

            - autosampled_num_negative_labels: typing.Optional[int]. The number of negative labels to add
        ---
        from coactive import ConceptLabelEnum, ConceptLabelRequest
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.update_labels(
            concept_id="concept_id",
            labels=[
                ConceptLabelRequest(
                    label=ConceptLabelEnum.POSITIVE,
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"labels": labels}
        if autosampled_num_negative_labels is not OMIT:
            _request["autosampledNumNegativeLabels"] = autosampled_num_negative_labels
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/labels"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_label_candidates(self, concept_id: str, *, limit: typing.Optional[int] = None) -> CandidatesToLabel:
        """
        Get images and keyframes to label in order to improve the concept

        Parameters:
            - concept_id: str. The concept id to get candidates to label

            - limit: typing.Optional[int]. Max number of items to return
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.get_label_candidates(
            concept_id="concept_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/candidates"),
            params=remove_none_from_dict({"limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CandidatesToLabel, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_concept_prediction(
        self,
        concept_id: str,
        *,
        threshold: typing.Optional[float] = None,
        confidence_level: typing.Optional[float] = None,
        estimation_fidelity: typing.Optional[int] = None,
    ) -> ConceptPredictionResponse:
        """
        Get concept's prediction estimation

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - confidence_level: typing.Optional[float]. A higher value results in wider confidence intervals, with more confidence of correctness. A lower value results in narrower confidence intervals, with less confidence of correctness

            - estimation_fidelity: typing.Optional[int]. A higher value makes estimation slower, but more accurate. A lower value makes estimation faster, but less accurate
        ---
        from coactive.client import Coactive

        client = Coactive(
            token="YOUR_TOKEN",
        )
        client.concept.get_concept_prediction(
            concept_id="concept_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/prediction_estimation"
            ),
            params=remove_none_from_dict(
                {
                    "threshold": threshold,
                    "confidence_level": confidence_level,
                    "estimation_fidelity": estimation_fidelity,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConceptPredictionResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncConceptClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        datasets: typing.Optional[typing.Union[str, typing.List[str]]] = None,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
    ) -> PagedConcepts:
        """
        Get paginated concepts, optionally filtered by datasets

        Parameters:
            - datasets: typing.Optional[typing.Union[str, typing.List[str]]]. Datasets to use to filter concepts

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/concepts"),
            params=remove_none_from_dict({"datasets": datasets, "offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedConcepts, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        threshold: typing.Optional[float] = OMIT,
        regularization: typing.Optional[float] = OMIT,
        dataset_id: str,
    ) -> Concept:
        """
        Create a new concept

        Parameters:
            - name: str. The name of the concept, which will become available as the column name in SQL

            - description: typing.Optional[str]. A description for the concept

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - regularization: typing.Optional[float]. How strongly the model adapts to the training labels. Regularization strength. Lower value means the model fits more heavily to the training data

            - dataset_id: str. The id of the dataset
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.create(
            name="TheNorth",
            description="Screenshots and clips from Game of Thrones that take place in the North",
            threshold=0.8,
            regularization=0.0625,
            dataset_id="c40276f0-024b-4a3f-b3e6-dcf0d304843e",
        )
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "datasetId": dataset_id}
        if description is not OMIT:
            _request["description"] = description
        if threshold is not OMIT:
            _request["threshold"] = threshold
        if regularization is not OMIT:
            _request["regularization"] = regularization
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v1/concepts"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, concept_id: str) -> Concept:
        """
        Get concept

        Parameters:
            - concept_id: str. The unique identifier for the concept
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.get(
            concept_id="concept_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, concept_id: str) -> typing.Any:
        """
        Delete concept

        Parameters:
            - concept_id: str. The unique identifier for the concept
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.delete(
            concept_id="concept_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        concept_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        threshold: typing.Optional[float] = OMIT,
        regularization: typing.Optional[float] = OMIT,
    ) -> Concept:
        """
        Update concept

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - name: typing.Optional[str]. A replacement name for the concept

            - description: typing.Optional[str]. A replacement description for the concept

            - threshold: typing.Optional[float]. A replacement decision threshold for the concept

            - regularization: typing.Optional[float]. How strongly the model adapts to the training labels. Regularization strength. Lower value means the model fits more heavily to the training data
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.update(
            concept_id="concept_id",
            name="TheNorth",
            description="Screenshots and clips from Game of Thrones that take place in the North",
            threshold=0.8,
            regularization=0.0625,
        )
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        if threshold is not OMIT:
            _request["threshold"] = threshold
        if regularization is not OMIT:
            _request["regularization"] = regularization
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_labels(
        self,
        concept_id: str,
        *,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        labels_to_include: typing.Optional[typing.Union[ConceptLabelEnum, typing.List[ConceptLabelEnum]]] = None,
    ) -> PagedConceptLabels:
        """
        Get all labels for a concept

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return

            - labels_to_include: typing.Optional[typing.Union[ConceptLabelEnum, typing.List[ConceptLabelEnum]]]. List of labels types to include, leave blank to return all
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.get_labels(
            concept_id="concept_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/labels"),
            params=remove_none_from_dict({"offset": offset, "limit": limit, "labels_to_include": labels_to_include}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedConceptLabels, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_labels(
        self,
        concept_id: str,
        *,
        labels: typing.List[ConceptLabelRequest],
        autosampled_num_negative_labels: typing.Optional[int] = OMIT,
    ) -> Concept:
        """
        Update labels for a concept. Label requests containing coactive image ids or image paths already in use will overwrite existing labels. Label requests with an empty label value will delete an existing label for that image/keyframe identifier.

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - labels: typing.List[ConceptLabelRequest]. Labels for the concept. A label with an empty label value will delete any existing labels associate with the provided image or keyframe

            - autosampled_num_negative_labels: typing.Optional[int]. The number of negative labels to add
        ---
        from coactive import ConceptLabelEnum, ConceptLabelRequest
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.update_labels(
            concept_id="concept_id",
            labels=[
                ConceptLabelRequest(
                    label=ConceptLabelEnum.POSITIVE,
                )
            ],
        )
        """
        _request: typing.Dict[str, typing.Any] = {"labels": labels}
        if autosampled_num_negative_labels is not OMIT:
            _request["autosampledNumNegativeLabels"] = autosampled_num_negative_labels
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/labels"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Concept, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_label_candidates(self, concept_id: str, *, limit: typing.Optional[int] = None) -> CandidatesToLabel:
        """
        Get images and keyframes to label in order to improve the concept

        Parameters:
            - concept_id: str. The concept id to get candidates to label

            - limit: typing.Optional[int]. Max number of items to return
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.get_label_candidates(
            concept_id="concept_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/candidates"),
            params=remove_none_from_dict({"limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CandidatesToLabel, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_concept_prediction(
        self,
        concept_id: str,
        *,
        threshold: typing.Optional[float] = None,
        confidence_level: typing.Optional[float] = None,
        estimation_fidelity: typing.Optional[int] = None,
    ) -> ConceptPredictionResponse:
        """
        Get concept's prediction estimation

        Parameters:
            - concept_id: str. The unique identifier for the concept

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - confidence_level: typing.Optional[float]. A higher value results in wider confidence intervals, with more confidence of correctness. A lower value results in narrower confidence intervals, with less confidence of correctness

            - estimation_fidelity: typing.Optional[int]. A higher value makes estimation slower, but more accurate. A lower value makes estimation faster, but less accurate
        ---
        from coactive.client import AsyncCoactive

        client = AsyncCoactive(
            token="YOUR_TOKEN",
        )
        await client.concept.get_concept_prediction(
            concept_id="concept_id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v1/concepts/{concept_id}/prediction_estimation"
            ),
            params=remove_none_from_dict(
                {
                    "threshold": threshold,
                    "confidence_level": confidence_level,
                    "estimation_fidelity": estimation_fidelity,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ConceptPredictionResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
