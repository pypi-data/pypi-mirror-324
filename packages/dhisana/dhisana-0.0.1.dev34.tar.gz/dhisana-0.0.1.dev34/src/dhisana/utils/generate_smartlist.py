import json
import logging
from typing import Any, Dict, List, Optional, Tuple
from uuid import UUID

from pydantic import BaseModel

# Example imports: adapt paths to your actual modules
from dhisana.schemas.sales import SmartList, SmartListLead
from dhisana.utils.generate_structured_output_internal import get_structured_output_internal
from dhisana.utils.generate_leads import generate_leads
from dhisana.utils.qualify_leads import qualify_leads

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TwoStepWorkflow(BaseModel):
    """
    Pydantic model representing the two-step workflow generated by the LLM:
      1) step_1_fetch_the_list
      2) step_2_qualify_the_leads
    """
    step_1_fetch_the_list: str
    step_2_qualify_the_leads: str


async def generate_workflow_steps(
    english_description: str,
    tool_config: Optional[List[Dict[str, Any]]] = None,
) -> Tuple[Dict[str, Any], str]:
    """
    Given user instructions, produce a JSON object with two fields:
      - step_1_fetch_the_list
      - step_2_qualify_the_leads

    Returns:
        A tuple:
         - A dictionary matching the TwoStepWorkflow model:
            {
                "step_1_fetch_the_list": "...",
                "step_2_qualify_the_leads": "...",
            }
         - A string representing status, "SUCCESS" or "ERROR".
    """

    user_prompt = f"""
    You are a helpful assistant. Please analyze the user's English description and produce a JSON object with 
    two fields: step_1_fetch_the_list, step_2_qualify_the_leads.

    The user wants a 2-step workflow:
      1) Step 1: Describe how to filter and fetch the list of leads required. What criteria is used to filter with lead, technographic or firmographic data?
      2) Step 2: Describe how the above leads will be qualified. What is the scoring criteria for the leads?
         
    Output MUST be valid JSON with exactly these 2 keys:
      "step_1_fetch_the_list"
      "step_2_qualify_the_leads"

    -- The user-provided description is below --
    {english_description}
    """

    # Use get_structured_output_internal to parse LLM output into TwoStepWorkflow
    response_obj, status = await get_structured_output_internal(
        user_prompt,
        TwoStepWorkflow,
        tool_config=tool_config
    )

    if status != "SUCCESS":
        return {"error": "Failed to generate two-step workflow."}, "ERROR"

    # Convert the Pydantic model to a dictionary
    return response_obj.model_dump(), status


async def generate_smartlist(
    request: SmartList,
    tool_config: Optional[List[Dict[str, Any]]] = None
) -> List[SmartListLead]:
    """
    1. Generates a 2-step workflow (fetch + qualify) from the user-provided SmartList instructions.
    2. Executes:
       - Step 1: Fetch leads (e.g., from Sales Navigator).
       - Step 2: Qualify leads.
    3. Returns a list of SmartListLead objects.
    """

    try:
        # Generate the 2-step instructions from user input
        two_step_response, status = await generate_workflow_steps(
            request.instructions or "",
            tool_config=tool_config
        )
        if status != "SUCCESS":
            logger.error("Failed to generate two-step workflow: %s", two_step_response.get("error"))
            return []

        # Extract the step instructions
        step_1_instructions = two_step_response.get("step_1_fetch_the_list", "")
        step_2_instructions = two_step_response.get("step_2_qualify_the_leads", "")

        # STEP 1: Fetch leads
        leads_list: List[Dict[str, Any]] = []
        logger.info("Using Sales Navigator flow for step 1. Instructions: %s", step_1_instructions)

        result_str = await generate_leads(
            user_query=step_1_instructions,
            request=request,
            tool_config=tool_config
        )
        # Parse JSON result
        try:
            result_json = json.loads(result_str)
        except json.JSONDecodeError as e:
            logger.exception("Failed to parse Step 1 JSON output.")
            return []

        step_1_status = result_json.get("status", "ERROR")
        if step_1_status != "SUCCESS":
            logger.error("Failed to fetch leads in step 1: %s", result_json.get("error"))
            return []

        leads_list = result_json.get("leads", [])
        logger.info("Step 1 completed with %d leads", len(leads_list))

        # STEP 2: Qualify leads
        if step_2_instructions:
            logger.info("Executing qualification step 2. Instructions: %s", step_2_instructions)
            try:
                result_str = await qualify_leads(
                    user_query=step_2_instructions,
                    input_leads_list=leads_list,
                    request=request,
                    tool_config=tool_config
                )
                result_json = json.loads(result_str)

                step_2_status = result_json.get("status", "ERROR")
                if step_2_status != "SUCCESS":
                    logger.error("Failed to qualify leads in step 2: %s", result_json.get("error"))
                    return []

                leads_list = result_json.get("qualified_leads", [])
                logger.info("Step 2 completed with %d leads after qualification", len(leads_list))
            except Exception as exc:
                logger.exception("Exception during Step 2 (smart list qualification).")
                return []
        else:
            logger.info("No instructions provided for step 2. Skipping qualification.")

        # Convert final list of dicts into SmartListLead objects
        smartlist_leads: List[SmartListLead] = []
        for lead_dict in leads_list:
            try:
                lead_obj = SmartListLead(**lead_dict)
                # Optionally set the lead's smart_list_id to match the request if needed
                if request.id:
                    lead_obj.smart_list_id = request.id
                    lead_obj.organization_id = request.organization_id
                    lead_obj.agent_instance_id = request.agent_instance_id
                    
                smartlist_leads.append(lead_obj)
            except Exception as parse_exc:
                logger.warning("Failed to parse lead dict into SmartListLead: %s", parse_exc)

        return smartlist_leads

    except Exception as e:
        logger.exception("Exception in generate_smartlist.")
        return []
