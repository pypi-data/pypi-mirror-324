# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class DeadLetterSink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterSink"]:
            return DeadLetterSink

        def build(self) -> "DeadLetterSink":
            return DeadLetterSink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["DeadLetterSink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterSink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterSink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterSink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterSink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Delivery(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Delivery"]:
            return Delivery

        def build(self) -> "Delivery":
            return Delivery(**self._attrs)

        def backoff_delay(self, value: Optional[str], /) -> Self:
            """
            BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
            """
            return self._set("backoff_delay", value)

        def backoff_policy(self, value: Optional[str], /) -> Self:
            """
            BackoffPolicy is the retry backoff policy (linear, exponential).
            """
            return self._set("backoff_policy", value)

        @overload
        def dead_letter_sink(
            self, value_or_callback: Optional[DeadLetterSink], /
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self,
            value_or_callback: Callable[
                [DeadLetterSink.Builder], DeadLetterSink.Builder | DeadLetterSink
            ],
            /,
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self, value_or_callback: Never = ...
        ) -> "DeadLetterSink.BuilderContext": ...

        def dead_letter_sink(self, value_or_callback=None, /):
            """
            DeadLetterSink is the sink receiving event that could not be sent to a destination.
            """
            if self._in_context and value_or_callback is None:
                context = DeadLetterSink.BuilderContext()
                context._parent_builder = self
                context._field_name = "dead_letter_sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeadLetterSink.builder())
                if isinstance(output, DeadLetterSink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dead_letter_sink", value)

        def retry(self, value: Optional[int], /) -> Self:
            """
            Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
            """
            return self._set("retry", value)

    class BuilderContext(BuilderContextBase["Delivery.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Delivery.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Delivery."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Delivery", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Delivery.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backoff_delay: Annotated[Optional[str], Field(alias="backoffDelay")] = None
    """
    BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
    """
    backoff_policy: Annotated[Optional[str], Field(alias="backoffPolicy")] = None
    """
    BackoffPolicy is the retry backoff policy (linear, exponential).
    """
    dead_letter_sink: Annotated[Optional[DeadLetterSink], Field(alias="deadLetterSink")] = None
    """
    DeadLetterSink is the sink receiving event that could not be sent to a destination.
    """
    retry: Optional[int] = None
    """
    Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
    """


class Filter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Filter"]:
            return Filter

        def build(self) -> "Filter":
            return Filter(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Filter.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Filter.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Filter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Filter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Filter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Filter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Filter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Reply(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Reply"]:
            return Reply

        def build(self) -> "Reply":
            return Reply(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Reply.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Reply.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Reply.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Reply.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Reply."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Reply", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Reply.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Subscriber(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subscriber"]:
            return Subscriber

        def build(self) -> "Subscriber":
            return Subscriber(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Subscriber.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Subscriber.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Subscriber.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subscriber.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subscriber."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subscriber", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subscriber.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Branch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Branch"]:
            return Branch

        def build(self) -> "Branch":
            return Branch(**self._attrs)

        @overload
        def delivery(self, value_or_callback: Optional[Delivery], /) -> "Branch.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "Branch.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

        @overload
        def filter(self, value_or_callback: Optional[Filter], /) -> "Branch.Builder": ...

        @overload
        def filter(
            self,
            value_or_callback: Callable[[Filter.Builder], Filter.Builder | Filter],
            /,
        ) -> "Branch.Builder": ...

        @overload
        def filter(self, value_or_callback: Never = ...) -> "Filter.BuilderContext": ...

        def filter(self, value_or_callback=None, /):
            """
            Filter is the expression guarding the branch
            """
            if self._in_context and value_or_callback is None:
                context = Filter.BuilderContext()
                context._parent_builder = self
                context._field_name = "filter"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.builder())
                if isinstance(output, Filter.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("filter", value)

        @overload
        def reply(self, value_or_callback: Optional[Reply], /) -> "Branch.Builder": ...

        @overload
        def reply(
            self, value_or_callback: Callable[[Reply.Builder], Reply.Builder | Reply], /
        ) -> "Branch.Builder": ...

        @overload
        def reply(self, value_or_callback: Never = ...) -> "Reply.BuilderContext": ...

        def reply(self, value_or_callback=None, /):
            """
            Reply is a Reference to where the result of Subscriber of this case gets sent to. If not specified, sent the result to the Parallel Reply
            """
            if self._in_context and value_or_callback is None:
                context = Reply.BuilderContext()
                context._parent_builder = self
                context._field_name = "reply"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Reply.builder())
                if isinstance(output, Reply.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("reply", value)

        @overload
        def subscriber(self, value_or_callback: Optional[Subscriber], /) -> "Branch.Builder": ...

        @overload
        def subscriber(
            self,
            value_or_callback: Callable[[Subscriber.Builder], Subscriber.Builder | Subscriber],
            /,
        ) -> "Branch.Builder": ...

        @overload
        def subscriber(self, value_or_callback: Never = ...) -> "Subscriber.BuilderContext": ...

        def subscriber(self, value_or_callback=None, /):
            """
            Subscriber receiving the event when the filter passes
            """
            if self._in_context and value_or_callback is None:
                context = Subscriber.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscriber"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subscriber.builder())
                if isinstance(output, Subscriber.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscriber", value)

    class BuilderContext(BuilderContextBase["Branch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Branch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Branch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Branch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Branch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    delivery: Optional[Delivery] = None
    """
    Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.
    """
    filter: Optional[Filter] = None
    """
    Filter is the expression guarding the branch
    """
    reply: Optional[Reply] = None
    """
    Reply is a Reference to where the result of Subscriber of this case gets sent to. If not specified, sent the result to the Parallel Reply
    """
    subscriber: Optional[Subscriber] = None
    """
    Subscriber receiving the event when the filter passes
    """


class ChannelTemplate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChannelTemplate"]:
            return ChannelTemplate

        def build(self) -> "ChannelTemplate":
            return ChannelTemplate(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def spec(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.
            """
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ChannelTemplate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChannelTemplate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChannelTemplate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChannelTemplate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChannelTemplate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    spec: Optional[Dict[str, Any]] = None
    """
    Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.
    """


class ParallelSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ParallelSpec"]:
            return ParallelSpec

        def build(self) -> "ParallelSpec":
            return ParallelSpec(**self._attrs)

        @overload
        def branches(self, value_or_callback: List[Branch], /) -> "ParallelSpec.Builder": ...

        @overload
        def branches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Branch, Branch.Builder]],
                GenericListBuilder[Branch, Branch.Builder] | List[Branch],
            ],
            /,
        ) -> "ParallelSpec.Builder": ...

        @overload
        def branches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Branch.Builder]: ...

        def branches(self, value_or_callback=None, /):
            """
            Branches is the list of Filter/Subscribers pairs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Branch.Builder]()
                context._parent_builder = self
                context._field_name = "branches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Branch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("branches", value)

        @overload
        def channel_template(
            self, value_or_callback: Optional[ChannelTemplate], /
        ) -> "ParallelSpec.Builder": ...

        @overload
        def channel_template(
            self,
            value_or_callback: Callable[
                [ChannelTemplate.Builder], ChannelTemplate.Builder | ChannelTemplate
            ],
            /,
        ) -> "ParallelSpec.Builder": ...

        @overload
        def channel_template(
            self, value_or_callback: Never = ...
        ) -> "ChannelTemplate.BuilderContext": ...

        def channel_template(self, value_or_callback=None, /):
            """
            ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).
            """
            if self._in_context and value_or_callback is None:
                context = ChannelTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChannelTemplate.builder())
                if isinstance(output, ChannelTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel_template", value)

        @overload
        def reply(self, value_or_callback: Optional[Reply], /) -> "ParallelSpec.Builder": ...

        @overload
        def reply(
            self, value_or_callback: Callable[[Reply.Builder], Reply.Builder | Reply], /
        ) -> "ParallelSpec.Builder": ...

        @overload
        def reply(self, value_or_callback: Never = ...) -> "Reply.BuilderContext": ...

        def reply(self, value_or_callback=None, /):
            """
            Reply is a Reference to where the result of a case Subscriber gets sent to when the case does not have a Reply
            """
            if self._in_context and value_or_callback is None:
                context = Reply.BuilderContext()
                context._parent_builder = self
                context._field_name = "reply"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Reply.builder())
                if isinstance(output, Reply.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("reply", value)

    class BuilderContext(BuilderContextBase["ParallelSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ParallelSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ParallelSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ParallelSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ParallelSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branches: Optional[List[Branch]] = None
    """
    Branches is the list of Filter/Subscribers pairs.
    """
    channel_template: Annotated[Optional[ChannelTemplate], Field(alias="channelTemplate")] = None
    """
    ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).
    """
    reply: Optional[Reply] = None
    """
    Reply is a Reference to where the result of a case Subscriber gets sent to when the case does not have a Reply
    """


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    url: Optional[str] = None
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    audience: Optional[str] = None


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
            """
            return self._set("service_account_name", value)

        def service_account_names(self, value: Optional[List[str]], /) -> Self:
            """
            ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
            """
            return self._set("service_account_names", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
    """
    service_account_names: Annotated[Optional[List[str]], Field(alias="serviceAccountNames")] = None
    """
    ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
    """


class Channel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Channel"]:
            return Channel

        def build(self) -> "Channel":
            return Channel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
            """
            return self._set("field_path", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Channel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Channel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Channel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Channel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Channel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """


class Ready(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ready"]:
            return Ready

        def build(self) -> "Ready":
            return Ready(**self._attrs)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Ready.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ready.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ready."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ready", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ready.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: Optional[str] = None
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: Optional[str] = None
    """
    Type of condition.
    """


class FilterChannelStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FilterChannelStatus"]:
            return FilterChannelStatus

        def build(self) -> "FilterChannelStatus":
            return FilterChannelStatus(**self._attrs)

        @overload
        def channel(
            self, value_or_callback: Optional[Channel], /
        ) -> "FilterChannelStatus.Builder": ...

        @overload
        def channel(
            self,
            value_or_callback: Callable[[Channel.Builder], Channel.Builder | Channel],
            /,
        ) -> "FilterChannelStatus.Builder": ...

        @overload
        def channel(self, value_or_callback: Never = ...) -> "Channel.BuilderContext": ...

        def channel(self, value_or_callback=None, /):
            """
            Channel is the reference to the underlying channel.
            """
            if self._in_context and value_or_callback is None:
                context = Channel.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Channel.builder())
                if isinstance(output, Channel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel", value)

        @overload
        def ready(self, value_or_callback: Optional[Ready], /) -> "FilterChannelStatus.Builder": ...

        @overload
        def ready(
            self, value_or_callback: Callable[[Ready.Builder], Ready.Builder | Ready], /
        ) -> "FilterChannelStatus.Builder": ...

        @overload
        def ready(self, value_or_callback: Never = ...) -> "Ready.BuilderContext": ...

        def ready(self, value_or_callback=None, /):
            """
            ReadyCondition indicates whether the Channel is ready or not.
            """
            if self._in_context and value_or_callback is None:
                context = Ready.BuilderContext()
                context._parent_builder = self
                context._field_name = "ready"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ready.builder())
                if isinstance(output, Ready.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ready", value)

    class BuilderContext(BuilderContextBase["FilterChannelStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FilterChannelStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FilterChannelStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FilterChannelStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FilterChannelStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    channel: Optional[Channel] = None
    """
    Channel is the reference to the underlying channel.
    """
    ready: Optional[Ready] = None
    """
    ReadyCondition indicates whether the Channel is ready or not.
    """


class Subscription(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subscription"]:
            return Subscription

        def build(self) -> "Subscription":
            return Subscription(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
            """
            return self._set("field_path", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Subscription.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subscription.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subscription."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subscription", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subscription.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """


class FilterSubscriptionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FilterSubscriptionStatus"]:
            return FilterSubscriptionStatus

        def build(self) -> "FilterSubscriptionStatus":
            return FilterSubscriptionStatus(**self._attrs)

        @overload
        def ready(
            self, value_or_callback: Optional[Ready], /
        ) -> "FilterSubscriptionStatus.Builder": ...

        @overload
        def ready(
            self, value_or_callback: Callable[[Ready.Builder], Ready.Builder | Ready], /
        ) -> "FilterSubscriptionStatus.Builder": ...

        @overload
        def ready(self, value_or_callback: Never = ...) -> "Ready.BuilderContext": ...

        def ready(self, value_or_callback=None, /):
            """
            ReadyCondition indicates whether the Subscription is ready or not.
            """
            if self._in_context and value_or_callback is None:
                context = Ready.BuilderContext()
                context._parent_builder = self
                context._field_name = "ready"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ready.builder())
                if isinstance(output, Ready.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ready", value)

        @overload
        def subscription(
            self, value_or_callback: Optional[Subscription], /
        ) -> "FilterSubscriptionStatus.Builder": ...

        @overload
        def subscription(
            self,
            value_or_callback: Callable[
                [Subscription.Builder], Subscription.Builder | Subscription
            ],
            /,
        ) -> "FilterSubscriptionStatus.Builder": ...

        @overload
        def subscription(self, value_or_callback: Never = ...) -> "Subscription.BuilderContext": ...

        def subscription(self, value_or_callback=None, /):
            """
            Subscription is the reference to the underlying Subscription.
            """
            if self._in_context and value_or_callback is None:
                context = Subscription.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscription"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subscription.builder())
                if isinstance(output, Subscription.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscription", value)

    class BuilderContext(BuilderContextBase["FilterSubscriptionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FilterSubscriptionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FilterSubscriptionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FilterSubscriptionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FilterSubscriptionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ready: Optional[Ready] = None
    """
    ReadyCondition indicates whether the Subscription is ready or not.
    """
    subscription: Optional[Subscription] = None
    """
    Subscription is the reference to the underlying Subscription.
    """


class SubscriberSubscriptionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SubscriberSubscriptionStatus"]:
            return SubscriberSubscriptionStatus

        def build(self) -> "SubscriberSubscriptionStatus":
            return SubscriberSubscriptionStatus(**self._attrs)

        @overload
        def ready(
            self, value_or_callback: Optional[Ready], /
        ) -> "SubscriberSubscriptionStatus.Builder": ...

        @overload
        def ready(
            self, value_or_callback: Callable[[Ready.Builder], Ready.Builder | Ready], /
        ) -> "SubscriberSubscriptionStatus.Builder": ...

        @overload
        def ready(self, value_or_callback: Never = ...) -> "Ready.BuilderContext": ...

        def ready(self, value_or_callback=None, /):
            """
            ReadyCondition indicates whether the Subscription is ready or not.
            """
            if self._in_context and value_or_callback is None:
                context = Ready.BuilderContext()
                context._parent_builder = self
                context._field_name = "ready"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ready.builder())
                if isinstance(output, Ready.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ready", value)

        @overload
        def subscription(
            self, value_or_callback: Optional[Subscription], /
        ) -> "SubscriberSubscriptionStatus.Builder": ...

        @overload
        def subscription(
            self,
            value_or_callback: Callable[
                [Subscription.Builder], Subscription.Builder | Subscription
            ],
            /,
        ) -> "SubscriberSubscriptionStatus.Builder": ...

        @overload
        def subscription(self, value_or_callback: Never = ...) -> "Subscription.BuilderContext": ...

        def subscription(self, value_or_callback=None, /):
            """
            Subscription is the reference to the underlying Subscription.
            """
            if self._in_context and value_or_callback is None:
                context = Subscription.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscription"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subscription.builder())
                if isinstance(output, Subscription.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscription", value)

    class BuilderContext(BuilderContextBase["SubscriberSubscriptionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SubscriberSubscriptionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SubscriberSubscriptionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SubscriberSubscriptionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubscriberSubscriptionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ready: Optional[Ready] = None
    """
    ReadyCondition indicates whether the Subscription is ready or not.
    """
    subscription: Optional[Subscription] = None
    """
    Subscription is the reference to the underlying Subscription.
    """


class BranchStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BranchStatus"]:
            return BranchStatus

        def build(self) -> "BranchStatus":
            return BranchStatus(**self._attrs)

        @overload
        def filter_channel_status(
            self, value_or_callback: Optional[FilterChannelStatus], /
        ) -> "BranchStatus.Builder": ...

        @overload
        def filter_channel_status(
            self,
            value_or_callback: Callable[
                [FilterChannelStatus.Builder],
                FilterChannelStatus.Builder | FilterChannelStatus,
            ],
            /,
        ) -> "BranchStatus.Builder": ...

        @overload
        def filter_channel_status(
            self, value_or_callback: Never = ...
        ) -> "FilterChannelStatus.BuilderContext": ...

        def filter_channel_status(self, value_or_callback=None, /):
            """
            FilterChannelStatus corresponds to the filter channel status.
            """
            if self._in_context and value_or_callback is None:
                context = FilterChannelStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "filter_channel_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FilterChannelStatus.builder())
                if isinstance(output, FilterChannelStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("filter_channel_status", value)

        @overload
        def filter_subscription_status(
            self, value_or_callback: Optional[FilterSubscriptionStatus], /
        ) -> "BranchStatus.Builder": ...

        @overload
        def filter_subscription_status(
            self,
            value_or_callback: Callable[
                [FilterSubscriptionStatus.Builder],
                FilterSubscriptionStatus.Builder | FilterSubscriptionStatus,
            ],
            /,
        ) -> "BranchStatus.Builder": ...

        @overload
        def filter_subscription_status(
            self, value_or_callback: Never = ...
        ) -> "FilterSubscriptionStatus.BuilderContext": ...

        def filter_subscription_status(self, value_or_callback=None, /):
            """
            FilterSubscriptionStatus corresponds to the filter subscription status.
            """
            if self._in_context and value_or_callback is None:
                context = FilterSubscriptionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "filter_subscription_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FilterSubscriptionStatus.builder())
                if isinstance(output, FilterSubscriptionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("filter_subscription_status", value)

        @overload
        def subscriber_subscription_status(
            self, value_or_callback: Optional[SubscriberSubscriptionStatus], /
        ) -> "BranchStatus.Builder": ...

        @overload
        def subscriber_subscription_status(
            self,
            value_or_callback: Callable[
                [SubscriberSubscriptionStatus.Builder],
                SubscriberSubscriptionStatus.Builder | SubscriberSubscriptionStatus,
            ],
            /,
        ) -> "BranchStatus.Builder": ...

        @overload
        def subscriber_subscription_status(
            self, value_or_callback: Never = ...
        ) -> "SubscriberSubscriptionStatus.BuilderContext": ...

        def subscriber_subscription_status(self, value_or_callback=None, /):
            """
            SubscriptionStatus corresponds to the subscriber subscription status.
            """
            if self._in_context and value_or_callback is None:
                context = SubscriberSubscriptionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscriber_subscription_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SubscriberSubscriptionStatus.builder())
                if isinstance(output, SubscriberSubscriptionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscriber_subscription_status", value)

    class BuilderContext(BuilderContextBase["BranchStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BranchStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BranchStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BranchStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BranchStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    filter_channel_status: Annotated[
        Optional[FilterChannelStatus], Field(alias="filterChannelStatus")
    ] = None
    """
    FilterChannelStatus corresponds to the filter channel status.
    """
    filter_subscription_status: Annotated[
        Optional[FilterSubscriptionStatus], Field(alias="filterSubscriptionStatus")
    ] = None
    """
    FilterSubscriptionStatus corresponds to the filter subscription status.
    """
    subscriber_subscription_status: Annotated[
        Optional[SubscriberSubscriptionStatus],
        Field(alias="subscriberSubscriptionStatus"),
    ] = None
    """
    SubscriptionStatus corresponds to the subscriber subscription status.
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
            """
            return self._set("api_version", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the applied EventPolicy
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
    """
    name: Optional[str] = None
    """
    The name of the applied EventPolicy
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: Optional[str] = None
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: Optional[str] = None
    """
    Type of condition.
    """


class IngressChannelStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressChannelStatus"]:
            return IngressChannelStatus

        def build(self) -> "IngressChannelStatus":
            return IngressChannelStatus(**self._attrs)

        @overload
        def channel(
            self, value_or_callback: Optional[Channel], /
        ) -> "IngressChannelStatus.Builder": ...

        @overload
        def channel(
            self,
            value_or_callback: Callable[[Channel.Builder], Channel.Builder | Channel],
            /,
        ) -> "IngressChannelStatus.Builder": ...

        @overload
        def channel(self, value_or_callback: Never = ...) -> "Channel.BuilderContext": ...

        def channel(self, value_or_callback=None, /):
            """
            Channel is the reference to the underlying channel.
            """
            if self._in_context and value_or_callback is None:
                context = Channel.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Channel.builder())
                if isinstance(output, Channel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel", value)

        @overload
        def ready(
            self, value_or_callback: Optional[Ready], /
        ) -> "IngressChannelStatus.Builder": ...

        @overload
        def ready(
            self, value_or_callback: Callable[[Ready.Builder], Ready.Builder | Ready], /
        ) -> "IngressChannelStatus.Builder": ...

        @overload
        def ready(self, value_or_callback: Never = ...) -> "Ready.BuilderContext": ...

        def ready(self, value_or_callback=None, /):
            """
            ReadyCondition indicates whether the Channel is ready or not.
            """
            if self._in_context and value_or_callback is None:
                context = Ready.BuilderContext()
                context._parent_builder = self
                context._field_name = "ready"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ready.builder())
                if isinstance(output, Ready.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ready", value)

    class BuilderContext(BuilderContextBase["IngressChannelStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressChannelStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressChannelStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressChannelStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressChannelStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    channel: Optional[Channel] = None
    """
    Channel is the reference to the underlying channel.
    """
    ready: Optional[Ready] = None
    """
    ReadyCondition indicates whether the Channel is ready or not.
    """


class ParallelStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ParallelStatus"]:
            return ParallelStatus

        def build(self) -> "ParallelStatus":
            return ParallelStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "ParallelStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "ParallelStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Parallel is Addressable. It exposes the endpoint as an URI to get events delivered into the Parallel.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(self, value_or_callback: List[Address], /) -> "ParallelStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "ParallelStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            Parallel is Addressable. It exposes the endpoints as URIs to get events delivered into the Parallel.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "ParallelStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "ParallelStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def branch_statuses(
            self, value_or_callback: List[BranchStatus], /
        ) -> "ParallelStatus.Builder": ...

        @overload
        def branch_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[BranchStatus, BranchStatus.Builder]],
                GenericListBuilder[BranchStatus, BranchStatus.Builder] | List[BranchStatus],
            ],
            /,
        ) -> "ParallelStatus.Builder": ...

        @overload
        def branch_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[BranchStatus.Builder]: ...

        def branch_statuses(self, value_or_callback=None, /):
            """
            BranchStatuses is an array of corresponding to branch statuses. Matches the Spec.Branches array in the order.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[BranchStatus.Builder]()
                context._parent_builder = self
                context._field_name = "branch_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BranchStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("branch_statuses", value)

        @overload
        def policies(self, value_or_callback: List[Policy], /) -> "ParallelStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "ParallelStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "ParallelStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ParallelStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def ingress_channel_status(
            self, value_or_callback: Optional[IngressChannelStatus], /
        ) -> "ParallelStatus.Builder": ...

        @overload
        def ingress_channel_status(
            self,
            value_or_callback: Callable[
                [IngressChannelStatus.Builder],
                IngressChannelStatus.Builder | IngressChannelStatus,
            ],
            /,
        ) -> "ParallelStatus.Builder": ...

        @overload
        def ingress_channel_status(
            self, value_or_callback: Never = ...
        ) -> "IngressChannelStatus.BuilderContext": ...

        def ingress_channel_status(self, value_or_callback=None, /):
            """
            IngressChannelStatus corresponds to the ingress channel status.
            """
            if self._in_context and value_or_callback is None:
                context = IngressChannelStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "ingress_channel_status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IngressChannelStatus.builder())
                if isinstance(output, IngressChannelStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ingress_channel_status", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ParallelStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ParallelStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ParallelStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ParallelStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ParallelStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Parallel is Addressable. It exposes the endpoint as an URI to get events delivered into the Parallel.
    """
    addresses: Optional[List[Address]] = None
    """
    Parallel is Addressable. It exposes the endpoints as URIs to get events delivered into the Parallel.
    """
    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    branch_statuses: Annotated[Optional[List[BranchStatus]], Field(alias="branchStatuses")] = None
    """
    BranchStatuses is an array of corresponding to branch statuses. Matches the Spec.Branches array in the order.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    ingress_channel_status: Annotated[
        Optional[IngressChannelStatus], Field(alias="ingressChannelStatus")
    ] = None
    """
    IngressChannelStatus corresponds to the ingress channel status.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class ReplyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReplyModel"]:
            return ReplyModel

        def build(self) -> "ReplyModel":
            return ReplyModel(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "ReplyModel.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "ReplyModel.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the reply.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience of the reply. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["ReplyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReplyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReplyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReplyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReplyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the reply.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience of the reply. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Step(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Step"]:
            return Step

        def build(self) -> "Step":
            return Step(**self._attrs)

        @overload
        def delivery(self, value_or_callback: Optional[Delivery], /) -> "Step.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "Step.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Step.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Step.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the Addressable itself. If the target is an Addressable and specifies an Audience, the target's Audience takes precedence.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Step.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Step.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Step."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Step", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Step.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    delivery: Optional[Delivery] = None
    """
    Delivery is the delivery specification for events to the subscriber This includes things like retries, DLQ, etc.
    """
    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the Addressable itself. If the target is an Addressable and specifies an Audience, the target's Audience takes precedence.
    """


class SequenceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SequenceSpec"]:
            return SequenceSpec

        def build(self) -> "SequenceSpec":
            return SequenceSpec(**self._attrs)

        @overload
        def channel_template(
            self, value_or_callback: Optional[ChannelTemplate], /
        ) -> "SequenceSpec.Builder": ...

        @overload
        def channel_template(
            self,
            value_or_callback: Callable[
                [ChannelTemplate.Builder], ChannelTemplate.Builder | ChannelTemplate
            ],
            /,
        ) -> "SequenceSpec.Builder": ...

        @overload
        def channel_template(
            self, value_or_callback: Never = ...
        ) -> "ChannelTemplate.BuilderContext": ...

        def channel_template(self, value_or_callback=None, /):
            """
            ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).
            """
            if self._in_context and value_or_callback is None:
                context = ChannelTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChannelTemplate.builder())
                if isinstance(output, ChannelTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel_template", value)

        @overload
        def reply(self, value_or_callback: Optional[ReplyModel], /) -> "SequenceSpec.Builder": ...

        @overload
        def reply(
            self,
            value_or_callback: Callable[[ReplyModel.Builder], ReplyModel.Builder | ReplyModel],
            /,
        ) -> "SequenceSpec.Builder": ...

        @overload
        def reply(self, value_or_callback: Never = ...) -> "ReplyModel.BuilderContext": ...

        def reply(self, value_or_callback=None, /):
            """
            Reply is a Reference to where the result of the last Subscriber gets sent to.
            """
            if self._in_context and value_or_callback is None:
                context = ReplyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "reply"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReplyModel.builder())
                if isinstance(output, ReplyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("reply", value)

        @overload
        def steps(self, value_or_callback: List[Step], /) -> "SequenceSpec.Builder": ...

        @overload
        def steps(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Step, Step.Builder]],
                GenericListBuilder[Step, Step.Builder] | List[Step],
            ],
            /,
        ) -> "SequenceSpec.Builder": ...

        @overload
        def steps(self, value_or_callback: Never = ...) -> ListBuilderContext[Step.Builder]: ...

        def steps(self, value_or_callback=None, /):
            """
            Steps is the list of Destinations (processors / functions) that will be called in the order provided. Each step has its own delivery options
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Step.Builder]()
                context._parent_builder = self
                context._field_name = "steps"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Step.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("steps", value)

    class BuilderContext(BuilderContextBase["SequenceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SequenceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SequenceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SequenceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SequenceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    channel_template: Annotated[Optional[ChannelTemplate], Field(alias="channelTemplate")] = None
    """
    ChannelTemplate specifies which Channel CRD to use. If left unspecified, it is set to the default Channel CRD for the namespace (or cluster, in case there are no defaults for the namespace).
    """
    reply: Optional[ReplyModel] = None
    """
    Reply is a Reference to where the result of the last Subscriber gets sent to.
    """
    steps: Optional[List[Step]] = None
    """
    Steps is the list of Destinations (processors / functions) that will be called in the order provided. Each step has its own delivery options
    """


class ReadyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReadyModel"]:
            return ReadyModel

        def build(self) -> "ReadyModel":
            return ReadyModel(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ReadyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReadyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReadyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class ChannelStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChannelStatus"]:
            return ChannelStatus

        def build(self) -> "ChannelStatus":
            return ChannelStatus(**self._attrs)

        @overload
        def channel(self, value_or_callback: Optional[Channel], /) -> "ChannelStatus.Builder": ...

        @overload
        def channel(
            self,
            value_or_callback: Callable[[Channel.Builder], Channel.Builder | Channel],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def channel(self, value_or_callback: Never = ...) -> "Channel.BuilderContext": ...

        def channel(self, value_or_callback=None, /):
            """
            Channel is the reference to the underlying channel.
            """
            if self._in_context and value_or_callback is None:
                context = Channel.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Channel.builder())
                if isinstance(output, Channel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel", value)

        @overload
        def ready(self, value_or_callback: Optional[ReadyModel], /) -> "ChannelStatus.Builder": ...

        @overload
        def ready(
            self,
            value_or_callback: Callable[[ReadyModel.Builder], ReadyModel.Builder | ReadyModel],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def ready(self, value_or_callback: Never = ...) -> "ReadyModel.BuilderContext": ...

        def ready(self, value_or_callback=None, /):
            """
            ReadyCondition indicates whether the Channel is ready or not.
            """
            if self._in_context and value_or_callback is None:
                context = ReadyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ready"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadyModel.builder())
                if isinstance(output, ReadyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ready", value)

    class BuilderContext(BuilderContextBase["ChannelStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChannelStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChannelStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChannelStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChannelStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    channel: Optional[Channel] = None
    """
    Channel is the reference to the underlying channel.
    """
    ready: Optional[ReadyModel] = None
    """
    ReadyCondition indicates whether the Channel is ready or not.
    """


class ConditionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel"]:
            return ConditionModel

        def build(self) -> "ConditionModel":
            return ConditionModel(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class SubscriptionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SubscriptionStatus"]:
            return SubscriptionStatus

        def build(self) -> "SubscriptionStatus":
            return SubscriptionStatus(**self._attrs)

        @overload
        def ready(
            self, value_or_callback: Optional[ReadyModel], /
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def ready(
            self,
            value_or_callback: Callable[[ReadyModel.Builder], ReadyModel.Builder | ReadyModel],
            /,
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def ready(self, value_or_callback: Never = ...) -> "ReadyModel.BuilderContext": ...

        def ready(self, value_or_callback=None, /):
            """
            ReadyCondition indicates whether the Subscription is ready or not.
            """
            if self._in_context and value_or_callback is None:
                context = ReadyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ready"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadyModel.builder())
                if isinstance(output, ReadyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ready", value)

        @overload
        def subscription(
            self, value_or_callback: Optional[Subscription], /
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def subscription(
            self,
            value_or_callback: Callable[
                [Subscription.Builder], Subscription.Builder | Subscription
            ],
            /,
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def subscription(self, value_or_callback: Never = ...) -> "Subscription.BuilderContext": ...

        def subscription(self, value_or_callback=None, /):
            """
            Subscription is the reference to the underlying Subscription.
            """
            if self._in_context and value_or_callback is None:
                context = Subscription.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscription"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subscription.builder())
                if isinstance(output, Subscription.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscription", value)

    class BuilderContext(BuilderContextBase["SubscriptionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SubscriptionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SubscriptionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SubscriptionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubscriptionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ready: Optional[ReadyModel] = None
    """
    ReadyCondition indicates whether the Subscription is ready or not.
    """
    subscription: Optional[Subscription] = None
    """
    Subscription is the reference to the underlying Subscription.
    """


class SequenceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SequenceStatus"]:
            return SequenceStatus

        def build(self) -> "SequenceStatus":
            return SequenceStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "SequenceStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "SequenceStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Sequence is Addressable. It exposes the endpoint as an URI to get events delivered into the Sequence.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(self, value_or_callback: List[Address], /) -> "SequenceStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "SequenceStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            Sequence is Addressable. It exposes the endpoints as URIs to get events delivered into the Sequence.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "SequenceStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "SequenceStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def channel_statuses(
            self, value_or_callback: List[ChannelStatus], /
        ) -> "SequenceStatus.Builder": ...

        @overload
        def channel_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ChannelStatus, ChannelStatus.Builder]],
                GenericListBuilder[ChannelStatus, ChannelStatus.Builder] | List[ChannelStatus],
            ],
            /,
        ) -> "SequenceStatus.Builder": ...

        @overload
        def channel_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ChannelStatus.Builder]: ...

        def channel_statuses(self, value_or_callback=None, /):
            """
            ChannelStatuses is an array of corresponding Channel statuses. Matches the Spec.Steps array in the order.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ChannelStatus.Builder]()
                context._parent_builder = self
                context._field_name = "channel_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChannelStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel_statuses", value)

        @overload
        def policies(self, value_or_callback: List[Policy], /) -> "SequenceStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "SequenceStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel], /
        ) -> "SequenceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel, ConditionModel.Builder]],
                GenericListBuilder[ConditionModel, ConditionModel.Builder] | List[ConditionModel],
            ],
            /,
        ) -> "SequenceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def subscription_statuses(
            self, value_or_callback: List[SubscriptionStatus], /
        ) -> "SequenceStatus.Builder": ...

        @overload
        def subscription_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SubscriptionStatus, SubscriptionStatus.Builder]],
                GenericListBuilder[SubscriptionStatus, SubscriptionStatus.Builder]
                | List[SubscriptionStatus],
            ],
            /,
        ) -> "SequenceStatus.Builder": ...

        @overload
        def subscription_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SubscriptionStatus.Builder]: ...

        def subscription_statuses(self, value_or_callback=None, /):
            """
            SubscriptionStatuses is an array of corresponding Subscription statuses. Matches the Spec.Steps array in the order.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SubscriptionStatus.Builder]()
                context._parent_builder = self
                context._field_name = "subscription_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SubscriptionStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscription_statuses", value)

    class BuilderContext(BuilderContextBase["SequenceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SequenceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SequenceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SequenceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SequenceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Sequence is Addressable. It exposes the endpoint as an URI to get events delivered into the Sequence.
    """
    addresses: Optional[List[Address]] = None
    """
    Sequence is Addressable. It exposes the endpoints as URIs to get events delivered into the Sequence.
    """
    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    channel_statuses: Annotated[Optional[List[ChannelStatus]], Field(alias="channelStatuses")] = (
        None
    )
    """
    ChannelStatuses is an array of corresponding Channel statuses. Matches the Spec.Steps array in the order.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    conditions: Optional[List[ConditionModel]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    subscription_statuses: Annotated[
        Optional[List[SubscriptionStatus]], Field(alias="subscriptionStatuses")
    ] = None
    """
    SubscriptionStatuses is an array of corresponding Subscription statuses. Matches the Spec.Steps array in the order.
    """


class Parallel(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Parallel"]:
            return Parallel

        def build(self) -> "Parallel":
            return Parallel(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[ParallelSpec], /) -> "Parallel.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ParallelSpec.Builder], ParallelSpec.Builder | ParallelSpec
            ],
            /,
        ) -> "Parallel.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ParallelSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ParallelSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ParallelSpec.builder())
                if isinstance(output, ParallelSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ParallelStatus], /) -> "Parallel.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ParallelStatus.Builder], ParallelStatus.Builder | ParallelStatus
            ],
            /,
        ) -> "Parallel.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ParallelStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ParallelStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ParallelStatus.builder())
                if isinstance(output, ParallelStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["flows.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Parallel"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Parallel.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Parallel.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Parallel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Parallel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Parallel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Parallel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Parallel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[ParallelSpec] = None
    status: Optional[ParallelStatus] = None
    api_version: Annotated[Optional[Literal["flows.knative.dev/v1"]], Field(alias="apiVersion")] = (
        "flows.knative.dev/v1"
    )
    kind: Optional[Literal["Parallel"]] = "Parallel"
    metadata: Optional[apimachinery.ObjectMeta] = None


class Sequence(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sequence"]:
            return Sequence

        def build(self) -> "Sequence":
            return Sequence(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[SequenceSpec], /) -> "Sequence.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [SequenceSpec.Builder], SequenceSpec.Builder | SequenceSpec
            ],
            /,
        ) -> "Sequence.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SequenceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SequenceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SequenceSpec.builder())
                if isinstance(output, SequenceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[SequenceStatus], /) -> "Sequence.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SequenceStatus.Builder], SequenceStatus.Builder | SequenceStatus
            ],
            /,
        ) -> "Sequence.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "SequenceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SequenceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SequenceStatus.builder())
                if isinstance(output, SequenceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["flows.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Sequence"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Sequence.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Sequence.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Sequence.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sequence.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sequence."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sequence", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sequence.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[SequenceSpec] = None
    status: Optional[SequenceStatus] = None
    api_version: Annotated[Optional[Literal["flows.knative.dev/v1"]], Field(alias="apiVersion")] = (
        "flows.knative.dev/v1"
    )
    kind: Optional[Literal["Sequence"]] = "Sequence"
    metadata: Optional[apimachinery.ObjectMeta] = None
