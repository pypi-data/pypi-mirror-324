# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class CeOverrides(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeOverrides"]:
            return CeOverrides

        def build(self) -> "CeOverrides":
            return CeOverrides(**self._attrs)

        def extensions(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
            """
            return self._set("extensions", value)

    class BuilderContext(BuilderContextBase["CeOverrides.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeOverrides.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeOverrides."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeOverrides", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeOverrides.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extensions: Optional[Dict[str, str]] = None
    """
    Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class Sink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sink"]:
            return Sink

        def build(self) -> "Sink":
            return Sink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Sink.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Sink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Sink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class PingSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PingSourceSpec"]:
            return PingSourceSpec

        def build(self) -> "PingSourceSpec":
            return PingSourceSpec(**self._attrs)

        @overload
        def ce_overrides(
            self, value_or_callback: Optional[CeOverrides], /
        ) -> "PingSourceSpec.Builder": ...

        @overload
        def ce_overrides(
            self,
            value_or_callback: Callable[[CeOverrides.Builder], CeOverrides.Builder | CeOverrides],
            /,
        ) -> "PingSourceSpec.Builder": ...

        @overload
        def ce_overrides(self, value_or_callback: Never = ...) -> "CeOverrides.BuilderContext": ...

        def ce_overrides(self, value_or_callback=None, /):
            """
            CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
            """
            if self._in_context and value_or_callback is None:
                context = CeOverrides.BuilderContext()
                context._parent_builder = self
                context._field_name = "ce_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeOverrides.builder())
                if isinstance(output, CeOverrides.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_overrides", value)

        def content_type(self, value: Optional[str], /) -> Self:
            """
            ContentType is the media type of `data` or `dataBase64`. Default is empty.
            """
            return self._set("content_type", value)

        def data(self, value: Optional[str], /) -> Self:
            """
            Data is data used as the body of the event posted to the sink. Default is empty. Mutually exclusive with `dataBase64`.
            """
            return self._set("data", value)

        def data_base64(self, value: Optional[str], /) -> Self:
            """
            DataBase64 is the base64-encoded string of the actual event's body posted to the sink. Default is empty. Mutually exclusive with `data`.
            """
            return self._set("data_base64", value)

        def schedule(self, value: Optional[str], /) -> Self:
            """
            Schedule is the cron schedule. Defaults to `* * * * *`.
            """
            return self._set("schedule", value)

        @overload
        def sink(self, value_or_callback: Optional[Sink], /) -> "PingSourceSpec.Builder": ...

        @overload
        def sink(
            self, value_or_callback: Callable[[Sink.Builder], Sink.Builder | Sink], /
        ) -> "PingSourceSpec.Builder": ...

        @overload
        def sink(self, value_or_callback: Never = ...) -> "Sink.BuilderContext": ...

        def sink(self, value_or_callback=None, /):
            """
            Sink is a reference to an object that will resolve to a uri to use as the sink.
            """
            if self._in_context and value_or_callback is None:
                context = Sink.BuilderContext()
                context._parent_builder = self
                context._field_name = "sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sink.builder())
                if isinstance(output, Sink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sink", value)

        def timezone(self, value: Optional[str], /) -> Self:
            """
            Timezone modifies the actual time relative to the specified timezone. Defaults to the system time zone. More general information about time zones: https://www.iana.org/time-zones List of valid timezone values: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
            """
            return self._set("timezone", value)

    class BuilderContext(BuilderContextBase["PingSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PingSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PingSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ce_overrides: Annotated[Optional[CeOverrides], Field(alias="ceOverrides")] = None
    """
    CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
    """
    content_type: Annotated[Optional[str], Field(alias="contentType")] = None
    """
    ContentType is the media type of `data` or `dataBase64`. Default is empty.
    """
    data: Optional[str] = None
    """
    Data is data used as the body of the event posted to the sink. Default is empty. Mutually exclusive with `dataBase64`.
    """
    data_base64: Annotated[Optional[str], Field(alias="dataBase64")] = None
    """
    DataBase64 is the base64-encoded string of the actual event's body posted to the sink. Default is empty. Mutually exclusive with `data`.
    """
    schedule: Optional[str] = None
    """
    Schedule is the cron schedule. Defaults to `* * * * *`.
    """
    sink: Optional[Sink] = None
    """
    Sink is a reference to an object that will resolve to a uri to use as the sink.
    """
    timezone: Optional[str] = None
    """
    Timezone modifies the actual time relative to the specified timezone. Defaults to the system time zone. More general information about time zones: https://www.iana.org/time-zones List of valid timezone values: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
            """
            return self._set("service_account_name", value)

        def service_account_names(self, value: Optional[List[str]], /) -> Self:
            """
            ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
            """
            return self._set("service_account_names", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
    """
    service_account_names: Annotated[Optional[List[str]], Field(alias="serviceAccountNames")] = None
    """
    ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
    """


class CeAttribute(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeAttribute"]:
            return CeAttribute

        def build(self) -> "CeAttribute":
            return CeAttribute(**self._attrs)

        def source(self, value: Optional[str], /) -> Self:
            """
            Source is the CloudEvents source attribute.
            """
            return self._set("source", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type refers to the CloudEvent type attribute.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["CeAttribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeAttribute.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeAttribute."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeAttribute", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeAttribute.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    source: Optional[str] = None
    """
    Source is the CloudEvents source attribute.
    """
    type: Optional[str] = None
    """
    Type refers to the CloudEvent type attribute.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class PingSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PingSourceStatus"]:
            return PingSourceStatus

        def build(self) -> "PingSourceStatus":
            return PingSourceStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "PingSourceStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def ce_attributes(
            self, value_or_callback: List[CeAttribute], /
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CeAttribute, CeAttribute.Builder]],
                GenericListBuilder[CeAttribute, CeAttribute.Builder] | List[CeAttribute],
            ],
            /,
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CeAttribute.Builder]: ...

        def ce_attributes(self, value_or_callback=None, /):
            """
            CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CeAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "ce_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_attributes", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the "Generation" of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def sink_uri(self, value: Optional[str], /) -> Self:
            """
            SinkURI is the current active sink URI that has been configured for the Source.
            """
            return self._set("sink_uri", value)

        def sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("sink_ca_certs", value)

        def sink_audience(self, value: Optional[str], /) -> Self:
            """
            sinkAudience is the OIDC audience of the sink.
            """
            return self._set("sink_audience", value)

    class BuilderContext(BuilderContextBase["PingSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PingSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PingSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    ce_attributes: Annotated[Optional[List[CeAttribute]], Field(alias="ceAttributes")] = None
    """
    CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the "Generation" of the Service that was last processed by the controller.
    """
    sink_uri: Annotated[Optional[str], Field(alias="sinkUri")] = None
    """
    SinkURI is the current active sink URI that has been configured for the Source.
    """
    sink_ca_certs: Annotated[Optional[str], Field(alias="sinkCACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    sink_audience: Annotated[Optional[str], Field(alias="sinkAudience")] = None
    """
    sinkAudience is the OIDC audience of the sink.
    """


class PingSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PingSource"]:
            return PingSource

        def build(self) -> "PingSource":
            return PingSource(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[PingSourceSpec], /) -> "PingSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PingSourceSpec.Builder], PingSourceSpec.Builder | PingSourceSpec
            ],
            /,
        ) -> "PingSource.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PingSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PingSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PingSourceSpec.builder())
                if isinstance(output, PingSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PingSourceStatus], /
        ) -> "PingSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PingSourceStatus.Builder], PingSourceStatus.Builder | PingSourceStatus
            ],
            /,
        ) -> "PingSource.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "PingSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PingSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PingSourceStatus.builder())
                if isinstance(output, PingSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sources.knative.dev/v1beta2"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PingSource"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PingSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PingSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["PingSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PingSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PingSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[PingSourceSpec] = None
    status: Optional[PingSourceStatus] = None
    api_version: Annotated[
        Optional[Literal["sources.knative.dev/v1beta2"]], Field(alias="apiVersion")
    ] = "sources.knative.dev/v1beta2"
    kind: Optional[Literal["PingSource"]] = "PingSource"
    metadata: Optional[apimachinery.ObjectMeta] = None
