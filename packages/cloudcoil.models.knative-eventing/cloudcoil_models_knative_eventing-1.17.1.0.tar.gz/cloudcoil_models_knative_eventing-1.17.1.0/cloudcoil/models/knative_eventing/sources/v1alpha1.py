# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class CeOverrides(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeOverrides"]:
            return CeOverrides

        def build(self) -> "CeOverrides":
            return CeOverrides(**self._attrs)

        def extensions(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
            """
            return self._set("extensions", value)

    class BuilderContext(BuilderContextBase["CeOverrides.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeOverrides.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeOverrides."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeOverrides", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeOverrides.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extensions: Optional[Dict[str, Any]] = None
    """
    Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class Sink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sink"]:
            return Sink

        def build(self) -> "Sink":
            return Sink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Sink.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Sink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Sink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Timer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Timer"]:
            return Timer

        def build(self) -> "Timer":
            return Timer(**self._attrs)

        def period(self, value: Optional[int], /) -> Self:
            """
            The interval (in milliseconds) to wait between producing the next message.
            """
            return self._set("period", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            The message to generate.
            """
            return self._set("message", value)

        def content_type(self, value: Optional[str], /) -> Self:
            """
            The content type of the generated message.
            """
            return self._set("content_type", value)

        def repeat_count(self, value: Optional[int], /) -> Self:
            """
            Specifies a maximum limit of number of fires
            """
            return self._set("repeat_count", value)

    class BuilderContext(BuilderContextBase["Timer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Timer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Timer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Timer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Timer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    period: Annotated[Optional[int], Field(title="Period")] = 1000
    """
    The interval (in milliseconds) to wait between producing the next message.
    """
    message: Annotated[Optional[str], Field(examples=["hello world"], title="Message")] = None
    """
    The message to generate.
    """
    content_type: Annotated[Optional[str], Field(alias="contentType", title="Content Type")] = (
        "text/plain"
    )
    """
    The content type of the generated message.
    """
    repeat_count: Annotated[Optional[int], Field(alias="repeatCount", title="Repeat Count")] = None
    """
    Specifies a maximum limit of number of fires
    """


class S3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["S3"]:
            return S3

        def build(self) -> "S3":
            return S3(**self._attrs)

        def arn(self, value: Optional[str], /) -> Self:
            """
            The S3 Bucket name or Amazon Resource Name (ARN).
            """
            return self._set("arn", value)

        def delete_after_read(self, value: Optional[bool], /) -> Self:
            """
            Specifies to delete objects after consuming them.
            """
            return self._set("delete_after_read", value)

        def move_after_read(self, value: Optional[bool], /) -> Self:
            """
            Move objects from S3 bucket to a different bucket after they have been retrieved.
            """
            return self._set("move_after_read", value)

        def destination_bucket(self, value: Optional[str], /) -> Self:
            """
            Define the destination bucket where an object must be moved when moveAfterRead is set to true.
            """
            return self._set("destination_bucket", value)

        def destination_bucket_prefix(self, value: Optional[str], /) -> Self:
            """
            Define the destination bucket prefix to use when an object must be moved, and moveAfterRead is set to true.
            """
            return self._set("destination_bucket_prefix", value)

        def destination_bucket_suffix(self, value: Optional[str], /) -> Self:
            """
            Define the destination bucket suffix to use when an object must be moved, and moveAfterRead is set to true.
            """
            return self._set("destination_bucket_suffix", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region to access.
            """
            return self._set("region", value)

        def auto_create_bucket(self, value: Optional[bool], /) -> Self:
            """
            Specifies to automatically create the S3 bucket.
            """
            return self._set("auto_create_bucket", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            The AWS S3 bucket prefix to consider while searching.
            """
            return self._set("prefix", value)

        def ignore_body(self, value: Optional[bool], /) -> Self:
            """
            If true, the S3 Object body is ignored. Setting this to true overrides any behavior defined by the `includeBody` option. If false, the S3 object is put in the body.
            """
            return self._set("ignore_body", value)

        def uri_endpoint_override(self, value: Optional[str], /) -> Self:
            """
            The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
            """
            return self._set("uri_endpoint_override", value)

        def override_endpoint(self, value: Optional[bool], /) -> Self:
            """
            Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
            """
            return self._set("override_endpoint", value)

        def force_path_style(self, value: Optional[bool], /) -> Self:
            """
            Forces path style when accessing AWS S3 buckets.
            """
            return self._set("force_path_style", value)

        def delay(self, value: Optional[int], /) -> Self:
            """
            The number of milliseconds before the next poll of the selected bucket.
            """
            return self._set("delay", value)

        def max_messages_per_poll(self, value: Optional[int], /) -> Self:
            """
            Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.
            """
            return self._set("max_messages_per_poll", value)

    class BuilderContext(BuilderContextBase["S3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = S3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for S3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["S3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use S3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arn: Annotated[Optional[str], Field(title="Bucket Name")] = None
    """
    The S3 Bucket name or Amazon Resource Name (ARN).
    """
    delete_after_read: Annotated[
        Optional[bool], Field(alias="deleteAfterRead", title="Auto-delete Objects")
    ] = True
    """
    Specifies to delete objects after consuming them.
    """
    move_after_read: Annotated[
        Optional[bool], Field(alias="moveAfterRead", title="Move Objects After Delete")
    ] = False
    """
    Move objects from S3 bucket to a different bucket after they have been retrieved.
    """
    destination_bucket: Annotated[
        Optional[str], Field(alias="destinationBucket", title="Destination Bucket")
    ] = None
    """
    Define the destination bucket where an object must be moved when moveAfterRead is set to true.
    """
    destination_bucket_prefix: Annotated[
        Optional[str],
        Field(alias="destinationBucketPrefix", title="Destination Bucket Prefix"),
    ] = None
    """
    Define the destination bucket prefix to use when an object must be moved, and moveAfterRead is set to true.
    """
    destination_bucket_suffix: Annotated[
        Optional[str],
        Field(alias="destinationBucketSuffix", title="Destination Bucket Suffix"),
    ] = None
    """
    Define the destination bucket suffix to use when an object must be moved, and moveAfterRead is set to true.
    """
    region: Annotated[Optional[str], Field(title="AWS Region")] = None
    """
    The AWS region to access.
    """
    auto_create_bucket: Annotated[
        Optional[bool], Field(alias="autoCreateBucket", title="Autocreate Bucket")
    ] = False
    """
    Specifies to automatically create the S3 bucket.
    """
    prefix: Annotated[Optional[str], Field(examples=["folder/"], title="Prefix")] = None
    """
    The AWS S3 bucket prefix to consider while searching.
    """
    ignore_body: Annotated[Optional[bool], Field(alias="ignoreBody", title="Ignore Body")] = False
    """
    If true, the S3 Object body is ignored. Setting this to true overrides any behavior defined by the `includeBody` option. If false, the S3 object is put in the body.
    """
    uri_endpoint_override: Annotated[
        Optional[str],
        Field(alias="uriEndpointOverride", title="Overwrite Endpoint URI"),
    ] = None
    """
    The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
    """
    override_endpoint: Annotated[
        Optional[bool], Field(alias="overrideEndpoint", title="Endpoint Overwrite")
    ] = False
    """
    Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
    """
    force_path_style: Annotated[
        Optional[bool], Field(alias="forcePathStyle", title="Force Path Style")
    ] = False
    """
    Forces path style when accessing AWS S3 buckets.
    """
    delay: Annotated[Optional[int], Field(title="Delay")] = 500
    """
    The number of milliseconds before the next poll of the selected bucket.
    """
    max_messages_per_poll: Annotated[
        Optional[int], Field(alias="maxMessagesPerPoll", title="Max Messages Per Poll")
    ] = 10
    """
    Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.
    """


class Sqs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sqs"]:
            return Sqs

        def build(self) -> "Sqs":
            return Sqs(**self._attrs)

        def arn(self, value: Optional[str], /) -> Self:
            """
            The SQS Queue Name or ARN
            """
            return self._set("arn", value)

        def delete_after_read(self, value: Optional[bool], /) -> Self:
            """
            Delete messages after consuming them
            """
            return self._set("delete_after_read", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region to access.
            """
            return self._set("region", value)

        def auto_create_queue(self, value: Optional[bool], /) -> Self:
            """
            Setting the autocreation of the SQS queue.
            """
            return self._set("auto_create_queue", value)

        def host(self, value: Optional[str], /) -> Self:
            """
            The hostname of the Amazon AWS cloud.
            """
            return self._set("host", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The underlying protocol used to communicate with SQS
            """
            return self._set("protocol", value)

        def queue_url(self, value: Optional[str], /) -> Self:
            """
            The full SQS Queue URL (required if using KEDA)
            """
            return self._set("queue_url", value)

        def uri_endpoint_override(self, value: Optional[str], /) -> Self:
            """
            The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
            """
            return self._set("uri_endpoint_override", value)

        def override_endpoint(self, value: Optional[bool], /) -> Self:
            """
            Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
            """
            return self._set("override_endpoint", value)

        def delay(self, value: Optional[int], /) -> Self:
            """
            The number of milliseconds before the next poll of the selected stream
            """
            return self._set("delay", value)

        def greedy(self, value: Optional[bool], /) -> Self:
            """
            If greedy is enabled, then the polling will happen immediately again, if the previous run polled 1 or more messages.
            """
            return self._set("greedy", value)

        def max_messages_per_poll(self, value: Optional[int], /) -> Self:
            """
            The maximum number of messages to return. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values 1 to 10. Default 1.
            """
            return self._set("max_messages_per_poll", value)

        def wait_time_seconds(self, value: Optional[int], /) -> Self:
            """
            The duration (in seconds) for which the call waits for a message to arrive in the queue before returning. If a message is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call does not return a message list.
            """
            return self._set("wait_time_seconds", value)

        def visibility_timeout(self, value: Optional[int], /) -> Self:
            """
            The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
            """
            return self._set("visibility_timeout", value)

    class BuilderContext(BuilderContextBase["Sqs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sqs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sqs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sqs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sqs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arn: Annotated[Optional[str], Field(title="Queue Name")] = None
    """
    The SQS Queue Name or ARN
    """
    delete_after_read: Annotated[
        Optional[bool], Field(alias="deleteAfterRead", title="Auto-delete Messages")
    ] = True
    """
    Delete messages after consuming them
    """
    region: Annotated[Optional[str], Field(title="AWS Region")] = None
    """
    The AWS region to access.
    """
    auto_create_queue: Annotated[
        Optional[bool], Field(alias="autoCreateQueue", title="Autocreate Queue")
    ] = False
    """
    Setting the autocreation of the SQS queue.
    """
    host: Annotated[Optional[str], Field(title="AWS Host")] = "amazonaws.com"
    """
    The hostname of the Amazon AWS cloud.
    """
    protocol: Annotated[Optional[str], Field(examples=["http or https"], title="Protocol")] = (
        "https"
    )
    """
    The underlying protocol used to communicate with SQS
    """
    queue_url: Annotated[Optional[str], Field(alias="queueURL", title="Queue URL")] = None
    """
    The full SQS Queue URL (required if using KEDA)
    """
    uri_endpoint_override: Annotated[
        Optional[str],
        Field(alias="uriEndpointOverride", title="Overwrite Endpoint URI"),
    ] = None
    """
    The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
    """
    override_endpoint: Annotated[
        Optional[bool], Field(alias="overrideEndpoint", title="Endpoint Overwrite")
    ] = False
    """
    Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
    """
    delay: Annotated[Optional[int], Field(title="Delay")] = 500
    """
    The number of milliseconds before the next poll of the selected stream
    """
    greedy: Annotated[Optional[bool], Field(title="Greedy Scheduler")] = False
    """
    If greedy is enabled, then the polling will happen immediately again, if the previous run polled 1 or more messages.
    """
    max_messages_per_poll: Annotated[
        Optional[int], Field(alias="maxMessagesPerPoll", title="Max Messages Per Poll")
    ] = 1
    """
    The maximum number of messages to return. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values 1 to 10. Default 1.
    """
    wait_time_seconds: Annotated[
        Optional[int], Field(alias="waitTimeSeconds", title="Wait Time Seconds")
    ] = None
    """
    The duration (in seconds) for which the call waits for a message to arrive in the queue before returning. If a message is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call does not return a message list.
    """
    visibility_timeout: Annotated[
        Optional[int], Field(alias="visibilityTimeout", title="Visibility Timeout")
    ] = None
    """
    The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
    """


class DdbStreams(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DdbStreams"]:
            return DdbStreams

        def build(self) -> "DdbStreams":
            return DdbStreams(**self._attrs)

        def table(self, value: Optional[str], /) -> Self:
            """
            The name of the DynamoDB table.
            """
            return self._set("table", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region to access.
            """
            return self._set("region", value)

        def stream_iterator_type(self, value: Optional[str], /) -> Self:
            """
            Defines where in the DynamoDB stream to start getting records. There are two enums and the value can be one of FROM_LATEST and FROM_START. Note that using FROM_START can cause a significant delay before the stream has caught up to real-time.
            """
            return self._set("stream_iterator_type", value)

        def uri_endpoint_override(self, value: Optional[str], /) -> Self:
            """
            The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
            """
            return self._set("uri_endpoint_override", value)

        def override_endpoint(self, value: Optional[bool], /) -> Self:
            """
            Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
            """
            return self._set("override_endpoint", value)

        def delay(self, value: Optional[int], /) -> Self:
            """
            The number of milliseconds before the next poll from the database.
            """
            return self._set("delay", value)

    class BuilderContext(BuilderContextBase["DdbStreams.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DdbStreams.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DdbStreams."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DdbStreams", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DdbStreams.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    table: Annotated[Optional[str], Field(title="Table")] = None
    """
    The name of the DynamoDB table.
    """
    region: Annotated[Optional[str], Field(title="AWS Region")] = None
    """
    The AWS region to access.
    """
    stream_iterator_type: Annotated[
        Optional[str], Field(alias="streamIteratorType", title="Stream Iterator Type")
    ] = "FROM_LATEST"
    """
    Defines where in the DynamoDB stream to start getting records. There are two enums and the value can be one of FROM_LATEST and FROM_START. Note that using FROM_START can cause a significant delay before the stream has caught up to real-time.
    """
    uri_endpoint_override: Annotated[
        Optional[str],
        Field(alias="uriEndpointOverride", title="Overwrite Endpoint URI"),
    ] = None
    """
    The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
    """
    override_endpoint: Annotated[
        Optional[bool], Field(alias="overrideEndpoint", title="Endpoint Overwrite")
    ] = False
    """
    Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
    """
    delay: Annotated[Optional[int], Field(title="Delay")] = 500
    """
    The number of milliseconds before the next poll from the database.
    """


class RefModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RefModel"]:
            return RefModel

        def build(self) -> "RefModel":
            return RefModel(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Secret name
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["RefModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RefModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RefModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Secret name
    """


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[RefModel], /) -> "Secret.Builder": ...

        @overload
        def ref(
            self,
            value_or_callback: Callable[[RefModel.Builder], RefModel.Builder | RefModel],
            /,
        ) -> "Secret.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "RefModel.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Secret reference.
            """
            if self._in_context and value_or_callback is None:
                context = RefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RefModel.builder())
                if isinstance(output, RefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[RefModel] = None
    """
    Secret reference.
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Auth.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Auth.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Auth secret
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret: Optional[Secret] = None
    """
    Auth secret
    """


class Aws(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Aws"]:
            return Aws

        def build(self) -> "Aws":
            return Aws(**self._attrs)

        @overload
        def s3(self, value_or_callback: Optional[S3], /) -> "Aws.Builder": ...

        @overload
        def s3(
            self, value_or_callback: Callable[[S3.Builder], S3.Builder | S3], /
        ) -> "Aws.Builder": ...

        @overload
        def s3(self, value_or_callback: Never = ...) -> "S3.BuilderContext": ...

        def s3(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = S3.BuilderContext()
                context._parent_builder = self
                context._field_name = "s3"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(S3.builder())
                if isinstance(output, S3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("s3", value)

        @overload
        def sqs(self, value_or_callback: Optional[Sqs], /) -> "Aws.Builder": ...

        @overload
        def sqs(
            self, value_or_callback: Callable[[Sqs.Builder], Sqs.Builder | Sqs], /
        ) -> "Aws.Builder": ...

        @overload
        def sqs(self, value_or_callback: Never = ...) -> "Sqs.BuilderContext": ...

        def sqs(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Sqs.BuilderContext()
                context._parent_builder = self
                context._field_name = "sqs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sqs.builder())
                if isinstance(output, Sqs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sqs", value)

        @overload
        def ddb_streams(self, value_or_callback: Optional[DdbStreams], /) -> "Aws.Builder": ...

        @overload
        def ddb_streams(
            self,
            value_or_callback: Callable[[DdbStreams.Builder], DdbStreams.Builder | DdbStreams],
            /,
        ) -> "Aws.Builder": ...

        @overload
        def ddb_streams(self, value_or_callback: Never = ...) -> "DdbStreams.BuilderContext": ...

        def ddb_streams(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DdbStreams.BuilderContext()
                context._parent_builder = self
                context._field_name = "ddb_streams"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DdbStreams.builder())
                if isinstance(output, DdbStreams.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ddb_streams", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "Aws.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "Aws.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth configurations
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

    class BuilderContext(BuilderContextBase["Aws.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Aws.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Aws."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Aws", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Aws.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    s3: Optional[S3] = None
    sqs: Optional[Sqs] = None
    ddb_streams: Annotated[Optional[DdbStreams], Field(alias="ddbStreams")] = None
    auth: Optional[Auth] = None
    """
    Auth configurations
    """


class IntegrationSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IntegrationSourceSpec"]:
            return IntegrationSourceSpec

        def build(self) -> "IntegrationSourceSpec":
            return IntegrationSourceSpec(**self._attrs)

        @overload
        def ce_overrides(
            self, value_or_callback: Optional[CeOverrides], /
        ) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def ce_overrides(
            self,
            value_or_callback: Callable[[CeOverrides.Builder], CeOverrides.Builder | CeOverrides],
            /,
        ) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def ce_overrides(self, value_or_callback: Never = ...) -> "CeOverrides.BuilderContext": ...

        def ce_overrides(self, value_or_callback=None, /):
            """
            CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
            """
            if self._in_context and value_or_callback is None:
                context = CeOverrides.BuilderContext()
                context._parent_builder = self
                context._field_name = "ce_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeOverrides.builder())
                if isinstance(output, CeOverrides.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_overrides", value)

        @overload
        def sink(self, value_or_callback: Optional[Sink], /) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def sink(
            self, value_or_callback: Callable[[Sink.Builder], Sink.Builder | Sink], /
        ) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def sink(self, value_or_callback: Never = ...) -> "Sink.BuilderContext": ...

        def sink(self, value_or_callback=None, /):
            """
            Sink is a reference to an object that will resolve to a uri to use as the sink.
            """
            if self._in_context and value_or_callback is None:
                context = Sink.BuilderContext()
                context._parent_builder = self
                context._field_name = "sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sink.builder())
                if isinstance(output, Sink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sink", value)

        @overload
        def timer(
            self, value_or_callback: Optional[Timer], /
        ) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def timer(
            self, value_or_callback: Callable[[Timer.Builder], Timer.Builder | Timer], /
        ) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def timer(self, value_or_callback: Never = ...) -> "Timer.BuilderContext": ...

        def timer(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Timer.BuilderContext()
                context._parent_builder = self
                context._field_name = "timer"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Timer.builder())
                if isinstance(output, Timer.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("timer", value)

        @overload
        def aws(self, value_or_callback: Optional[Aws], /) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def aws(
            self, value_or_callback: Callable[[Aws.Builder], Aws.Builder | Aws], /
        ) -> "IntegrationSourceSpec.Builder": ...

        @overload
        def aws(self, value_or_callback: Never = ...) -> "Aws.BuilderContext": ...

        def aws(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Aws.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Aws.builder())
                if isinstance(output, Aws.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws", value)

    class BuilderContext(BuilderContextBase["IntegrationSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IntegrationSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IntegrationSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IntegrationSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IntegrationSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ce_overrides: Annotated[Optional[CeOverrides], Field(alias="ceOverrides")] = None
    """
    CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
    """
    sink: Optional[Sink] = None
    """
    Sink is a reference to an object that will resolve to a uri to use as the sink.
    """
    timer: Optional[Timer] = None
    aws: Optional[Aws] = None


class AuthModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuthModel"]:
            return AuthModel

        def build(self) -> "AuthModel":
            return AuthModel(**self._attrs)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
            """
            return self._set("service_account_name", value)

        def service_account_names(self, value: Optional[List[str]], /) -> Self:
            """
            ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
            """
            return self._set("service_account_names", value)

    class BuilderContext(BuilderContextBase["AuthModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuthModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuthModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuthModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuthModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
    """
    service_account_names: Annotated[Optional[List[str]], Field(alias="serviceAccountNames")] = None
    """
    ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
    """


class CeAttribute(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeAttribute"]:
            return CeAttribute

        def build(self) -> "CeAttribute":
            return CeAttribute(**self._attrs)

        def source(self, value: Optional[str], /) -> Self:
            """
            Source is the CloudEvents source attribute.
            """
            return self._set("source", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type refers to the CloudEvent type attribute.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["CeAttribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeAttribute.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeAttribute."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeAttribute", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeAttribute.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    source: Optional[str] = None
    """
    Source is the CloudEvents source attribute.
    """
    type: Optional[str] = None
    """
    Type refers to the CloudEvent type attribute.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class IntegrationSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IntegrationSourceStatus"]:
            return IntegrationSourceStatus

        def build(self) -> "IntegrationSourceStatus":
            return IntegrationSourceStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(
            self, value_or_callback: Optional[AuthModel], /
        ) -> "IntegrationSourceStatus.Builder": ...

        @overload
        def auth(
            self,
            value_or_callback: Callable[[AuthModel.Builder], AuthModel.Builder | AuthModel],
            /,
        ) -> "IntegrationSourceStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "AuthModel.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = AuthModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuthModel.builder())
                if isinstance(output, AuthModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def ce_attributes(
            self, value_or_callback: List[CeAttribute], /
        ) -> "IntegrationSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CeAttribute, CeAttribute.Builder]],
                GenericListBuilder[CeAttribute, CeAttribute.Builder] | List[CeAttribute],
            ],
            /,
        ) -> "IntegrationSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CeAttribute.Builder]: ...

        def ce_attributes(self, value_or_callback=None, /):
            """
            CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CeAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "ce_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_attributes", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "IntegrationSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "IntegrationSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def sink_uri(self, value: Optional[str], /) -> Self:
            """
            SinkURI is the current active sink URI that has been configured for the Source.
            """
            return self._set("sink_uri", value)

        def sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("sink_ca_certs", value)

        def sink_audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience of the sink.
            """
            return self._set("sink_audience", value)

    class BuilderContext(BuilderContextBase["IntegrationSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IntegrationSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IntegrationSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IntegrationSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IntegrationSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[AuthModel] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    ce_attributes: Annotated[Optional[List[CeAttribute]], Field(alias="ceAttributes")] = None
    """
    CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    sink_uri: Annotated[Optional[str], Field(alias="sinkUri")] = None
    """
    SinkURI is the current active sink URI that has been configured for the Source.
    """
    sink_ca_certs: Annotated[Optional[str], Field(alias="sinkCACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    sink_audience: Annotated[Optional[str], Field(alias="sinkAudience")] = None
    """
    Audience is the OIDC audience of the sink.
    """


class IntegrationSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IntegrationSource"]:
            return IntegrationSource

        def build(self) -> "IntegrationSource":
            return IntegrationSource(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[IntegrationSourceSpec], /
        ) -> "IntegrationSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [IntegrationSourceSpec.Builder],
                IntegrationSourceSpec.Builder | IntegrationSourceSpec,
            ],
            /,
        ) -> "IntegrationSource.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "IntegrationSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IntegrationSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IntegrationSourceSpec.builder())
                if isinstance(output, IntegrationSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[IntegrationSourceStatus], /
        ) -> "IntegrationSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [IntegrationSourceStatus.Builder],
                IntegrationSourceStatus.Builder | IntegrationSourceStatus,
            ],
            /,
        ) -> "IntegrationSource.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "IntegrationSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IntegrationSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IntegrationSourceStatus.builder())
                if isinstance(output, IntegrationSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sources.knative.dev/v1alpha1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IntegrationSource"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "IntegrationSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "IntegrationSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["IntegrationSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IntegrationSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IntegrationSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IntegrationSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IntegrationSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[IntegrationSourceSpec] = None
    status: Optional[IntegrationSourceStatus] = None
    api_version: Annotated[
        Optional[Literal["sources.knative.dev/v1alpha1"]], Field(alias="apiVersion")
    ] = "sources.knative.dev/v1alpha1"
    kind: Optional[Literal["IntegrationSource"]] = "IntegrationSource"
    metadata: Optional[apimachinery.ObjectMeta] = None
