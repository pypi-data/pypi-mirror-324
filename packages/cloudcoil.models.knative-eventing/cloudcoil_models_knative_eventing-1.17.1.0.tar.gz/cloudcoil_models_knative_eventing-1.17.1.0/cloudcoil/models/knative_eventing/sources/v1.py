# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class CeOverrides(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeOverrides"]:
            return CeOverrides

        def build(self) -> "CeOverrides":
            return CeOverrides(**self._attrs)

        def extensions(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
            """
            return self._set("extensions", value)

    class BuilderContext(BuilderContextBase["CeOverrides.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeOverrides.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeOverrides."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeOverrides", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeOverrides.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extensions: Optional[Dict[str, Any]] = None
    """
    Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
    """


class Owner(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Owner"]:
            return Owner

        def build(self) -> "Owner":
            return Owner(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion - the API version of the resource to watch.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

    class BuilderContext(BuilderContextBase["Owner.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Owner.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Owner."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Owner", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Owner.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion - the API version of the resource to watch.
    """
    kind: Optional[str] = None
    """
    Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: Optional[str], /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[str] = None
    """
    key is the label key that the selector applies to.
    """
    operator: Optional[str] = None
    """
    operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, Any]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion - the API version of the resource to watch.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "ResourceModel.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            LabelSelector filters this source to objects to those resources pass the label selector. More info: http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion - the API version of the resource to watch.
    """
    kind: Optional[str] = None
    """
    Kind of the resource to watch. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    selector: Optional[Selector] = None
    """
    LabelSelector filters this source to objects to those resources pass the label selector. More info: http://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class Sink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sink"]:
            return Sink

        def build(self) -> "Sink":
            return Sink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Sink.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Sink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Sink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, Any]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ApiServerSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiServerSourceSpec"]:
            return ApiServerSourceSpec

        def build(self) -> "ApiServerSourceSpec":
            return ApiServerSourceSpec(**self._attrs)

        @overload
        def ce_overrides(
            self, value_or_callback: Optional[CeOverrides], /
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def ce_overrides(
            self,
            value_or_callback: Callable[[CeOverrides.Builder], CeOverrides.Builder | CeOverrides],
            /,
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def ce_overrides(self, value_or_callback: Never = ...) -> "CeOverrides.BuilderContext": ...

        def ce_overrides(self, value_or_callback=None, /):
            """
            CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
            """
            if self._in_context and value_or_callback is None:
                context = CeOverrides.BuilderContext()
                context._parent_builder = self
                context._field_name = "ce_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeOverrides.builder())
                if isinstance(output, CeOverrides.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_overrides", value)

        def mode(self, value: Optional[str], /) -> Self:
            """
            EventMode controls the format of the event. `Reference` sends a dataref event type for the resource under watch. `Resource` send the full resource lifecycle event. Defaults to `Reference`
            """
            return self._set("mode", value)

        @overload
        def owner(self, value_or_callback: Optional[Owner], /) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def owner(
            self, value_or_callback: Callable[[Owner.Builder], Owner.Builder | Owner], /
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def owner(self, value_or_callback: Never = ...) -> "Owner.BuilderContext": ...

        def owner(self, value_or_callback=None, /):
            """
            ResourceOwner is an additional filter to only track resources that are owned by a specific resource type. If ResourceOwner matches Resources[n] then Resources[n] is allowed to pass the ResourceOwner filter.
            """
            if self._in_context and value_or_callback is None:
                context = Owner.BuilderContext()
                context._parent_builder = self
                context._field_name = "owner"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Owner.builder())
                if isinstance(output, Owner.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("owner", value)

        @overload
        def resources(
            self, value_or_callback: List[ResourceModel], /
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Resource are the resources this source will track and send related lifecycle events from the Kubernetes ApiServer, with an optional label selector to help filter.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run this source. Defaults to default if not set.
            """
            return self._set("service_account_name", value)

        @overload
        def sink(self, value_or_callback: Optional[Sink], /) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def sink(
            self, value_or_callback: Callable[[Sink.Builder], Sink.Builder | Sink], /
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def sink(self, value_or_callback: Never = ...) -> "Sink.BuilderContext": ...

        def sink(self, value_or_callback=None, /):
            """
            Sink is a reference to an object that will resolve to a uri to use as the sink.
            """
            if self._in_context and value_or_callback is None:
                context = Sink.BuilderContext()
                context._parent_builder = self
                context._field_name = "sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sink.builder())
                if isinstance(output, Sink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sink", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "ApiServerSourceSpec.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            NamespaceSelector is a label selector to capture the namespaces that should be watched by the source.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

    class BuilderContext(BuilderContextBase["ApiServerSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiServerSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiServerSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiServerSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiServerSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ce_overrides: Annotated[Optional[CeOverrides], Field(alias="ceOverrides")] = None
    """
    CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
    """
    mode: Optional[str] = None
    """
    EventMode controls the format of the event. `Reference` sends a dataref event type for the resource under watch. `Resource` send the full resource lifecycle event. Defaults to `Reference`
    """
    owner: Optional[Owner] = None
    """
    ResourceOwner is an additional filter to only track resources that are owned by a specific resource type. If ResourceOwner matches Resources[n] then Resources[n] is allowed to pass the ResourceOwner filter.
    """
    resources: List[ResourceModel]
    """
    Resource are the resources this source will track and send related lifecycle events from the Kubernetes ApiServer, with an optional label selector to help filter.
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run this source. Defaults to default if not set.
    """
    sink: Optional[Sink] = None
    """
    Sink is a reference to an object that will resolve to a uri to use as the sink.
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    NamespaceSelector is a label selector to capture the namespaces that should be watched by the source.
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
            """
            return self._set("service_account_name", value)

        def service_account_names(self, value: Optional[List[str]], /) -> Self:
            """
            ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
            """
            return self._set("service_account_names", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
    """
    service_account_names: Annotated[Optional[List[str]], Field(alias="serviceAccountNames")] = None
    """
    ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
    """


class CeAttribute(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeAttribute"]:
            return CeAttribute

        def build(self) -> "CeAttribute":
            return CeAttribute(**self._attrs)

        def source(self, value: Optional[str], /) -> Self:
            """
            Source is the CloudEvents source attribute.
            """
            return self._set("source", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type refers to the CloudEvent type attribute.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["CeAttribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeAttribute.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeAttribute."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeAttribute", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeAttribute.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    source: Optional[str] = None
    """
    Source is the CloudEvents source attribute.
    """
    type: Optional[str] = None
    """
    Type refers to the CloudEvent type attribute.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class ApiServerSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiServerSourceStatus"]:
            return ApiServerSourceStatus

        def build(self) -> "ApiServerSourceStatus":
            return ApiServerSourceStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "ApiServerSourceStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "ApiServerSourceStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def ce_attributes(
            self, value_or_callback: List[CeAttribute], /
        ) -> "ApiServerSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CeAttribute, CeAttribute.Builder]],
                GenericListBuilder[CeAttribute, CeAttribute.Builder] | List[CeAttribute],
            ],
            /,
        ) -> "ApiServerSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CeAttribute.Builder]: ...

        def ce_attributes(self, value_or_callback=None, /):
            """
            CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CeAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "ce_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_attributes", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ApiServerSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ApiServerSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def sink_uri(self, value: Optional[str], /) -> Self:
            """
            SinkURI is the current active sink URI that has been configured for the Source.
            """
            return self._set("sink_uri", value)

        def sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("sink_ca_certs", value)

        def sink_audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience of the sink. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the Addressable itself. If the target is an Addressable and specifies an Audience, the target's Audience takes precedence.
            """
            return self._set("sink_audience", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            Namespaces show the namespaces currently watched by the ApiServerSource
            """
            return self._set("namespaces", value)

    class BuilderContext(BuilderContextBase["ApiServerSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiServerSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiServerSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiServerSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiServerSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    ce_attributes: Annotated[Optional[List[CeAttribute]], Field(alias="ceAttributes")] = None
    """
    CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    sink_uri: Annotated[Optional[str], Field(alias="sinkUri")] = None
    """
    SinkURI is the current active sink URI that has been configured for the Source.
    """
    sink_ca_certs: Annotated[Optional[str], Field(alias="sinkCACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    sink_audience: Annotated[Optional[str], Field(alias="sinkAudience")] = None
    """
    Audience is the OIDC audience of the sink. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the Addressable itself. If the target is an Addressable and specifies an Audience, the target's Audience takes precedence.
    """
    namespaces: Optional[List[str]] = None
    """
    Namespaces show the namespaces currently watched by the ApiServerSource
    """


class ContainerSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ContainerSourceSpec"]:
            return ContainerSourceSpec

        def build(self) -> "ContainerSourceSpec":
            return ContainerSourceSpec(**self._attrs)

        @overload
        def ce_overrides(
            self, value_or_callback: Optional[CeOverrides], /
        ) -> "ContainerSourceSpec.Builder": ...

        @overload
        def ce_overrides(
            self,
            value_or_callback: Callable[[CeOverrides.Builder], CeOverrides.Builder | CeOverrides],
            /,
        ) -> "ContainerSourceSpec.Builder": ...

        @overload
        def ce_overrides(self, value_or_callback: Never = ...) -> "CeOverrides.BuilderContext": ...

        def ce_overrides(self, value_or_callback=None, /):
            """
            CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
            """
            if self._in_context and value_or_callback is None:
                context = CeOverrides.BuilderContext()
                context._parent_builder = self
                context._field_name = "ce_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeOverrides.builder())
                if isinstance(output, CeOverrides.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_overrides", value)

        @overload
        def sink(self, value_or_callback: Optional[Sink], /) -> "ContainerSourceSpec.Builder": ...

        @overload
        def sink(
            self, value_or_callback: Callable[[Sink.Builder], Sink.Builder | Sink], /
        ) -> "ContainerSourceSpec.Builder": ...

        @overload
        def sink(self, value_or_callback: Never = ...) -> "Sink.BuilderContext": ...

        def sink(self, value_or_callback=None, /):
            """
            Sink is a reference to an object that will resolve to a uri to use as the sink.
            """
            if self._in_context and value_or_callback is None:
                context = Sink.BuilderContext()
                context._parent_builder = self
                context._field_name = "sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sink.builder())
                if isinstance(output, Sink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sink", value)

        def template(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            A template in the shape of `Deployment.spec.template` to be used for this ContainerSource. More info: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
            """
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ContainerSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ContainerSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ContainerSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ContainerSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ContainerSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ce_overrides: Annotated[Optional[CeOverrides], Field(alias="ceOverrides")] = None
    """
    CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
    """
    sink: Optional[Sink] = None
    """
    Sink is a reference to an object that will resolve to a uri to use as the sink.
    """
    template: Optional[Dict[str, Any]] = None
    """
    A template in the shape of `Deployment.spec.template` to be used for this ContainerSource. More info: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
    """


class ContainerSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ContainerSourceStatus"]:
            return ContainerSourceStatus

        def build(self) -> "ContainerSourceStatus":
            return ContainerSourceStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "ContainerSourceStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "ContainerSourceStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def ce_attributes(
            self, value_or_callback: List[CeAttribute], /
        ) -> "ContainerSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CeAttribute, CeAttribute.Builder]],
                GenericListBuilder[CeAttribute, CeAttribute.Builder] | List[CeAttribute],
            ],
            /,
        ) -> "ContainerSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CeAttribute.Builder]: ...

        def ce_attributes(self, value_or_callback=None, /):
            """
            CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CeAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "ce_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_attributes", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ContainerSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ContainerSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def sink_uri(self, value: Optional[str], /) -> Self:
            """
            SinkURI is the current active sink URI that has been configured for the Source.
            """
            return self._set("sink_uri", value)

        def sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("sink_ca_certs", value)

        def sink_audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience of the sink.
            """
            return self._set("sink_audience", value)

    class BuilderContext(BuilderContextBase["ContainerSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ContainerSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ContainerSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ContainerSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ContainerSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    ce_attributes: Annotated[Optional[List[CeAttribute]], Field(alias="ceAttributes")] = None
    """
    CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    sink_uri: Annotated[Optional[str], Field(alias="sinkUri")] = None
    """
    SinkURI is the current active sink URI that has been configured for the Source.
    """
    sink_ca_certs: Annotated[Optional[str], Field(alias="sinkCACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    sink_audience: Annotated[Optional[str], Field(alias="sinkAudience")] = None
    """
    Audience is the OIDC audience of the sink.
    """


class CeOverridesModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeOverridesModel"]:
            return CeOverridesModel

        def build(self) -> "CeOverridesModel":
            return CeOverridesModel(**self._attrs)

        def extensions(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
            """
            return self._set("extensions", value)

    class BuilderContext(BuilderContextBase["CeOverridesModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeOverridesModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeOverridesModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeOverridesModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeOverridesModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extensions: Optional[Dict[str, str]] = None
    """
    Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
    """


class PingSourceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PingSourceSpec"]:
            return PingSourceSpec

        def build(self) -> "PingSourceSpec":
            return PingSourceSpec(**self._attrs)

        @overload
        def ce_overrides(
            self, value_or_callback: Optional[CeOverridesModel], /
        ) -> "PingSourceSpec.Builder": ...

        @overload
        def ce_overrides(
            self,
            value_or_callback: Callable[
                [CeOverridesModel.Builder], CeOverridesModel.Builder | CeOverridesModel
            ],
            /,
        ) -> "PingSourceSpec.Builder": ...

        @overload
        def ce_overrides(
            self, value_or_callback: Never = ...
        ) -> "CeOverridesModel.BuilderContext": ...

        def ce_overrides(self, value_or_callback=None, /):
            """
            CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
            """
            if self._in_context and value_or_callback is None:
                context = CeOverridesModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ce_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeOverridesModel.builder())
                if isinstance(output, CeOverridesModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_overrides", value)

        def content_type(self, value: Optional[str], /) -> Self:
            """
            ContentType is the media type of `data` or `dataBase64`. Default is empty.
            """
            return self._set("content_type", value)

        def data(self, value: Optional[str], /) -> Self:
            """
            Data is data used as the body of the event posted to the sink. Default is empty. Mutually exclusive with `dataBase64`.
            """
            return self._set("data", value)

        def data_base64(self, value: Optional[str], /) -> Self:
            """
            DataBase64 is the base64-encoded string of the actual event's body posted to the sink. Default is empty. Mutually exclusive with `data`.
            """
            return self._set("data_base64", value)

        def schedule(self, value: Optional[str], /) -> Self:
            """
            Schedule is the cron schedule. Defaults to `* * * * *`.
            """
            return self._set("schedule", value)

        @overload
        def sink(self, value_or_callback: Optional[Sink], /) -> "PingSourceSpec.Builder": ...

        @overload
        def sink(
            self, value_or_callback: Callable[[Sink.Builder], Sink.Builder | Sink], /
        ) -> "PingSourceSpec.Builder": ...

        @overload
        def sink(self, value_or_callback: Never = ...) -> "Sink.BuilderContext": ...

        def sink(self, value_or_callback=None, /):
            """
            Sink is a reference to an object that will resolve to a uri to use as the sink.
            """
            if self._in_context and value_or_callback is None:
                context = Sink.BuilderContext()
                context._parent_builder = self
                context._field_name = "sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sink.builder())
                if isinstance(output, Sink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sink", value)

        def timezone(self, value: Optional[str], /) -> Self:
            """
            Timezone modifies the actual time relative to the specified timezone. Defaults to the system time zone. More general information about time zones: https://www.iana.org/time-zones List of valid timezone values: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
            """
            return self._set("timezone", value)

    class BuilderContext(BuilderContextBase["PingSourceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingSourceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingSourceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PingSourceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PingSourceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ce_overrides: Annotated[Optional[CeOverridesModel], Field(alias="ceOverrides")] = None
    """
    CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
    """
    content_type: Annotated[Optional[str], Field(alias="contentType")] = None
    """
    ContentType is the media type of `data` or `dataBase64`. Default is empty.
    """
    data: Optional[str] = None
    """
    Data is data used as the body of the event posted to the sink. Default is empty. Mutually exclusive with `dataBase64`.
    """
    data_base64: Annotated[Optional[str], Field(alias="dataBase64")] = None
    """
    DataBase64 is the base64-encoded string of the actual event's body posted to the sink. Default is empty. Mutually exclusive with `data`.
    """
    schedule: Optional[str] = None
    """
    Schedule is the cron schedule. Defaults to `* * * * *`.
    """
    sink: Optional[Sink] = None
    """
    Sink is a reference to an object that will resolve to a uri to use as the sink.
    """
    timezone: Optional[str] = None
    """
    Timezone modifies the actual time relative to the specified timezone. Defaults to the system time zone. More general information about time zones: https://www.iana.org/time-zones List of valid timezone values: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    """


class PingSourceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PingSourceStatus"]:
            return PingSourceStatus

        def build(self) -> "PingSourceStatus":
            return PingSourceStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "PingSourceStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def ce_attributes(
            self, value_or_callback: List[CeAttribute], /
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CeAttribute, CeAttribute.Builder]],
                GenericListBuilder[CeAttribute, CeAttribute.Builder] | List[CeAttribute],
            ],
            /,
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def ce_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CeAttribute.Builder]: ...

        def ce_attributes(self, value_or_callback=None, /):
            """
            CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CeAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "ce_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_attributes", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "PingSourceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the "Generation" of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def sink_uri(self, value: Optional[str], /) -> Self:
            """
            SinkURI is the current active sink URI that has been configured for the Source.
            """
            return self._set("sink_uri", value)

        def sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("sink_ca_certs", value)

        def sink_audience(self, value: Optional[str], /) -> Self:
            """
            sinkAudience is the OIDC audience of the sink.
            """
            return self._set("sink_audience", value)

    class BuilderContext(BuilderContextBase["PingSourceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingSourceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingSourceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PingSourceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PingSourceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    ce_attributes: Annotated[Optional[List[CeAttribute]], Field(alias="ceAttributes")] = None
    """
    CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the "Generation" of the Service that was last processed by the controller.
    """
    sink_uri: Annotated[Optional[str], Field(alias="sinkUri")] = None
    """
    SinkURI is the current active sink URI that has been configured for the Source.
    """
    sink_ca_certs: Annotated[Optional[str], Field(alias="sinkCACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    sink_audience: Annotated[Optional[str], Field(alias="sinkAudience")] = None
    """
    sinkAudience is the OIDC audience of the sink.
    """


class CeOverridesModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CeOverridesModel1"]:
            return CeOverridesModel1

        def build(self) -> "CeOverridesModel1":
            return CeOverridesModel1(**self._attrs)

        def extensions(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
            """
            return self._set("extensions", value)

    class BuilderContext(BuilderContextBase["CeOverridesModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CeOverridesModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CeOverridesModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CeOverridesModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CeOverridesModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extensions: Optional[Dict[str, Any]] = None
    """
    Extensions specify what attribute are added or overridden on the outbound event. Each `Extensions` key-value pair are set on the event as an attribute extension independently.
    """


class Subject(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subject"]:
            return Subject

        def build(self) -> "Subject":
            return Subject(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. Mutually exclusive with Selector.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            """
            return self._set("namespace", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "Subject.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "Subject.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector of the referents. Mutually exclusive with Name.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["Subject.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subject.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subject."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subject", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subject.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    """
    name: Optional[str] = None
    """
    Name of the referent. Mutually exclusive with Selector.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent.
    """
    selector: Optional[Selector] = None
    """
    Selector of the referents. Mutually exclusive with Name.
    """


class SinkBindingSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SinkBindingSpec"]:
            return SinkBindingSpec

        def build(self) -> "SinkBindingSpec":
            return SinkBindingSpec(**self._attrs)

        @overload
        def ce_overrides(
            self, value_or_callback: Optional[CeOverridesModel1], /
        ) -> "SinkBindingSpec.Builder": ...

        @overload
        def ce_overrides(
            self,
            value_or_callback: Callable[
                [CeOverridesModel1.Builder],
                CeOverridesModel1.Builder | CeOverridesModel1,
            ],
            /,
        ) -> "SinkBindingSpec.Builder": ...

        @overload
        def ce_overrides(
            self, value_or_callback: Never = ...
        ) -> "CeOverridesModel1.BuilderContext": ...

        def ce_overrides(self, value_or_callback=None, /):
            """
            CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
            """
            if self._in_context and value_or_callback is None:
                context = CeOverridesModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "ce_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeOverridesModel1.builder())
                if isinstance(output, CeOverridesModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_overrides", value)

        @overload
        def sink(self, value_or_callback: Optional[Sink], /) -> "SinkBindingSpec.Builder": ...

        @overload
        def sink(
            self, value_or_callback: Callable[[Sink.Builder], Sink.Builder | Sink], /
        ) -> "SinkBindingSpec.Builder": ...

        @overload
        def sink(self, value_or_callback: Never = ...) -> "Sink.BuilderContext": ...

        def sink(self, value_or_callback=None, /):
            """
            Sink is a reference to an object that will resolve to a uri to use as the sink.
            """
            if self._in_context and value_or_callback is None:
                context = Sink.BuilderContext()
                context._parent_builder = self
                context._field_name = "sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sink.builder())
                if isinstance(output, Sink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sink", value)

        @overload
        def subject(self, value_or_callback: Optional[Subject], /) -> "SinkBindingSpec.Builder": ...

        @overload
        def subject(
            self,
            value_or_callback: Callable[[Subject.Builder], Subject.Builder | Subject],
            /,
        ) -> "SinkBindingSpec.Builder": ...

        @overload
        def subject(self, value_or_callback: Never = ...) -> "Subject.BuilderContext": ...

        def subject(self, value_or_callback=None, /):
            """
            Subject references the resource(s) whose "runtime contract" should be augmented by Binding implementations.
            """
            if self._in_context and value_or_callback is None:
                context = Subject.BuilderContext()
                context._parent_builder = self
                context._field_name = "subject"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.builder())
                if isinstance(output, Subject.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subject", value)

    class BuilderContext(BuilderContextBase["SinkBindingSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SinkBindingSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SinkBindingSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SinkBindingSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SinkBindingSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ce_overrides: Annotated[Optional[CeOverridesModel1], Field(alias="ceOverrides")] = None
    """
    CloudEventOverrides defines overrides to control the output format and modifications of the event sent to the sink.
    """
    sink: Optional[Sink] = None
    """
    Sink is a reference to an object that will resolve to a uri to use as the sink.
    """
    subject: Optional[Subject] = None
    """
    Subject references the resource(s) whose "runtime contract" should be augmented by Binding implementations.
    """


class SinkBindingStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SinkBindingStatus"]:
            return SinkBindingStatus

        def build(self) -> "SinkBindingStatus":
            return SinkBindingStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "SinkBindingStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "SinkBindingStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def ce_attributes(
            self, value_or_callback: List[CeAttribute], /
        ) -> "SinkBindingStatus.Builder": ...

        @overload
        def ce_attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CeAttribute, CeAttribute.Builder]],
                GenericListBuilder[CeAttribute, CeAttribute.Builder] | List[CeAttribute],
            ],
            /,
        ) -> "SinkBindingStatus.Builder": ...

        @overload
        def ce_attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CeAttribute.Builder]: ...

        def ce_attributes(self, value_or_callback=None, /):
            """
            CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CeAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "ce_attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CeAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ce_attributes", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "SinkBindingStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "SinkBindingStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def sink_uri(self, value: Optional[str], /) -> Self:
            """
            SinkURI is the current active sink URI that has been configured for the Source.
            """
            return self._set("sink_uri", value)

        def sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("sink_ca_certs", value)

        def sink_audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience of the sink.
            """
            return self._set("sink_audience", value)

        def oidc_token_secret_name(self, value: Optional[str], /) -> Self:
            """
            Name of the secret with the OIDC token for the sink.
            """
            return self._set("oidc_token_secret_name", value)

    class BuilderContext(BuilderContextBase["SinkBindingStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SinkBindingStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SinkBindingStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SinkBindingStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SinkBindingStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    ce_attributes: Annotated[Optional[List[CeAttribute]], Field(alias="ceAttributes")] = None
    """
    CloudEventAttributes are the specific attributes that the Source uses as part of its CloudEvents.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    sink_uri: Annotated[Optional[str], Field(alias="sinkUri")] = None
    """
    SinkURI is the current active sink URI that has been configured for the Source.
    """
    sink_ca_certs: Annotated[Optional[str], Field(alias="sinkCACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    sink_audience: Annotated[Optional[str], Field(alias="sinkAudience")] = None
    """
    Audience is the OIDC audience of the sink.
    """
    oidc_token_secret_name: Annotated[Optional[str], Field(alias="oidcTokenSecretName")] = None
    """
    Name of the secret with the OIDC token for the sink.
    """


class ApiServerSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiServerSource"]:
            return ApiServerSource

        def build(self) -> "ApiServerSource":
            return ApiServerSource(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[ApiServerSourceSpec], /
        ) -> "ApiServerSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ApiServerSourceSpec.Builder],
                ApiServerSourceSpec.Builder | ApiServerSourceSpec,
            ],
            /,
        ) -> "ApiServerSource.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ApiServerSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ApiServerSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiServerSourceSpec.builder())
                if isinstance(output, ApiServerSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ApiServerSourceStatus], /
        ) -> "ApiServerSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ApiServerSourceStatus.Builder],
                ApiServerSourceStatus.Builder | ApiServerSourceStatus,
            ],
            /,
        ) -> "ApiServerSource.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ApiServerSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ApiServerSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiServerSourceStatus.builder())
                if isinstance(output, ApiServerSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sources.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ApiServerSource"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ApiServerSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ApiServerSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["ApiServerSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiServerSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiServerSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiServerSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiServerSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[ApiServerSourceSpec] = None
    status: Optional[ApiServerSourceStatus] = None
    api_version: Annotated[
        Optional[Literal["sources.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "sources.knative.dev/v1"
    kind: Optional[Literal["ApiServerSource"]] = "ApiServerSource"
    metadata: Optional[apimachinery.ObjectMeta] = None


class ContainerSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ContainerSource"]:
            return ContainerSource

        def build(self) -> "ContainerSource":
            return ContainerSource(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[ContainerSourceSpec], /
        ) -> "ContainerSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ContainerSourceSpec.Builder],
                ContainerSourceSpec.Builder | ContainerSourceSpec,
            ],
            /,
        ) -> "ContainerSource.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ContainerSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ContainerSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ContainerSourceSpec.builder())
                if isinstance(output, ContainerSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ContainerSourceStatus], /
        ) -> "ContainerSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ContainerSourceStatus.Builder],
                ContainerSourceStatus.Builder | ContainerSourceStatus,
            ],
            /,
        ) -> "ContainerSource.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ContainerSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ContainerSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ContainerSourceStatus.builder())
                if isinstance(output, ContainerSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sources.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ContainerSource"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ContainerSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ContainerSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["ContainerSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ContainerSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ContainerSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ContainerSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ContainerSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[ContainerSourceSpec] = None
    status: Optional[ContainerSourceStatus] = None
    api_version: Annotated[
        Optional[Literal["sources.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "sources.knative.dev/v1"
    kind: Optional[Literal["ContainerSource"]] = "ContainerSource"
    metadata: Optional[apimachinery.ObjectMeta] = None


class PingSource(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PingSource"]:
            return PingSource

        def build(self) -> "PingSource":
            return PingSource(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[PingSourceSpec], /) -> "PingSource.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PingSourceSpec.Builder], PingSourceSpec.Builder | PingSourceSpec
            ],
            /,
        ) -> "PingSource.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PingSourceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PingSourceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PingSourceSpec.builder())
                if isinstance(output, PingSourceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PingSourceStatus], /
        ) -> "PingSource.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PingSourceStatus.Builder], PingSourceStatus.Builder | PingSourceStatus
            ],
            /,
        ) -> "PingSource.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "PingSourceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PingSourceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PingSourceStatus.builder())
                if isinstance(output, PingSourceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sources.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PingSource"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PingSource.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PingSource.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["PingSource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingSource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingSource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PingSource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PingSource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[PingSourceSpec] = None
    status: Optional[PingSourceStatus] = None
    api_version: Annotated[
        Optional[Literal["sources.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "sources.knative.dev/v1"
    kind: Optional[Literal["PingSource"]] = "PingSource"
    metadata: Optional[apimachinery.ObjectMeta] = None


class SinkBinding(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SinkBinding"]:
            return SinkBinding

        def build(self) -> "SinkBinding":
            return SinkBinding(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[SinkBindingSpec], /
        ) -> "SinkBinding.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [SinkBindingSpec.Builder], SinkBindingSpec.Builder | SinkBindingSpec
            ],
            /,
        ) -> "SinkBinding.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SinkBindingSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SinkBindingSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SinkBindingSpec.builder())
                if isinstance(output, SinkBindingSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[SinkBindingStatus], /
        ) -> "SinkBinding.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SinkBindingStatus.Builder],
                SinkBindingStatus.Builder | SinkBindingStatus,
            ],
            /,
        ) -> "SinkBinding.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "SinkBindingStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SinkBindingStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SinkBindingStatus.builder())
                if isinstance(output, SinkBindingStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sources.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["SinkBinding"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "SinkBinding.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "SinkBinding.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["SinkBinding.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SinkBinding.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SinkBinding."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SinkBinding", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SinkBinding.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[SinkBindingSpec] = None
    status: Optional[SinkBindingStatus] = None
    api_version: Annotated[
        Optional[Literal["sources.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "sources.knative.dev/v1"
    kind: Optional[Literal["SinkBinding"]] = "SinkBinding"
    metadata: Optional[apimachinery.ObjectMeta] = None
