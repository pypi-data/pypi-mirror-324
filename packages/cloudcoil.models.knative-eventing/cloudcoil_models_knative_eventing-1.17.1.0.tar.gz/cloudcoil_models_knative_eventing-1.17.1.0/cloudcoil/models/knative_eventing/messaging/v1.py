# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class ChannelTemplate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChannelTemplate"]:
            return ChannelTemplate

        def build(self) -> "ChannelTemplate":
            return ChannelTemplate(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def spec(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.
            """
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ChannelTemplate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChannelTemplate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChannelTemplate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChannelTemplate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChannelTemplate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    spec: Optional[Dict[str, Any]] = None
    """
    Spec defines the Spec to use for each channel created. Passed in verbatim to the Channel CRD as Spec section.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class DeadLetterSink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterSink"]:
            return DeadLetterSink

        def build(self) -> "DeadLetterSink":
            return DeadLetterSink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["DeadLetterSink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterSink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterSink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterSink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterSink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Delivery(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Delivery"]:
            return Delivery

        def build(self) -> "Delivery":
            return Delivery(**self._attrs)

        def backoff_delay(self, value: Optional[str], /) -> Self:
            """
            BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
            """
            return self._set("backoff_delay", value)

        def backoff_policy(self, value: Optional[str], /) -> Self:
            """
            BackoffPolicy is the retry backoff policy (linear, exponential).
            """
            return self._set("backoff_policy", value)

        @overload
        def dead_letter_sink(
            self, value_or_callback: Optional[DeadLetterSink], /
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self,
            value_or_callback: Callable[
                [DeadLetterSink.Builder], DeadLetterSink.Builder | DeadLetterSink
            ],
            /,
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self, value_or_callback: Never = ...
        ) -> "DeadLetterSink.BuilderContext": ...

        def dead_letter_sink(self, value_or_callback=None, /):
            """
            DeadLetterSink is the sink receiving event that could not be sent to a destination.
            """
            if self._in_context and value_or_callback is None:
                context = DeadLetterSink.BuilderContext()
                context._parent_builder = self
                context._field_name = "dead_letter_sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeadLetterSink.builder())
                if isinstance(output, DeadLetterSink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dead_letter_sink", value)

        def retry(self, value: Optional[int], /) -> Self:
            """
            Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
            """
            return self._set("retry", value)

    class BuilderContext(BuilderContextBase["Delivery.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Delivery.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Delivery."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Delivery", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Delivery.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backoff_delay: Annotated[Optional[str], Field(alias="backoffDelay")] = None
    """
    BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
    """
    backoff_policy: Annotated[Optional[str], Field(alias="backoffPolicy")] = None
    """
    BackoffPolicy is the retry backoff policy (linear, exponential).
    """
    dead_letter_sink: Annotated[Optional[DeadLetterSink], Field(alias="deadLetterSink")] = None
    """
    DeadLetterSink is the sink receiving event that could not be sent to a destination.
    """
    retry: Optional[int] = None
    """
    Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
    """


class DeadLetterSinkModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterSinkModel"]:
            return DeadLetterSinkModel

        def build(self) -> "DeadLetterSinkModel":
            return DeadLetterSinkModel(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "DeadLetterSinkModel.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "DeadLetterSinkModel.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

    class BuilderContext(BuilderContextBase["DeadLetterSinkModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterSinkModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterSinkModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterSinkModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterSinkModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
            """
            return self._set("service_account_name", value)

        def service_account_names(self, value: Optional[List[str]], /) -> Self:
            """
            ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
            """
            return self._set("service_account_names", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
    """
    service_account_names: Annotated[Optional[List[str]], Field(alias="serviceAccountNames")] = None
    """
    ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
    """


class Subscriber(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subscriber"]:
            return Subscriber

        def build(self) -> "Subscriber":
            return Subscriber(**self._attrs)

        @overload
        def delivery(self, value_or_callback: Optional[Delivery], /) -> "Subscriber.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "Subscriber.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            DeliverySpec contains options controlling the event delivery
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

        def generation(self, value: Optional[int], /) -> Self:
            """
            Generation of the origin of the subscriber with uid:UID.
            """
            return self._set("generation", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the subscription
            """
            return self._set("name", value)

        def reply_uri(self, value: Optional[str], /) -> Self:
            """
            ReplyURI is the endpoint for the reply
            """
            return self._set("reply_uri", value)

        def reply_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("reply_ca_certs", value)

        def reply_audience(self, value: Optional[str], /) -> Self:
            """
            ReplyAudience is the OIDC audience for the replyUri.
            """
            return self._set("reply_audience", value)

        def subscriber_uri(self, value: Optional[str], /) -> Self:
            """
            SubscriberURI is the endpoint for the subscriber
            """
            return self._set("subscriber_uri", value)

        def subscriber_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("subscriber_ca_certs", value)

        def subscriber_audience(self, value: Optional[str], /) -> Self:
            """
            SubscriberAudience is the OIDC audience for the subscriberUri.
            """
            return self._set("subscriber_audience", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID is used to understand the origin of the subscriber.
            """
            return self._set("uid", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "Subscriber.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "Subscriber.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

    class BuilderContext(BuilderContextBase["Subscriber.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subscriber.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subscriber."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subscriber", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subscriber.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    delivery: Optional[Delivery] = None
    """
    DeliverySpec contains options controlling the event delivery
    """
    generation: Optional[int] = None
    """
    Generation of the origin of the subscriber with uid:UID.
    """
    name: Optional[str] = None
    """
    The name of the subscription
    """
    reply_uri: Annotated[Optional[str], Field(alias="replyUri")] = None
    """
    ReplyURI is the endpoint for the reply
    """
    reply_ca_certs: Annotated[Optional[str], Field(alias="replyCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    reply_audience: Annotated[Optional[str], Field(alias="replyAudience")] = None
    """
    ReplyAudience is the OIDC audience for the replyUri.
    """
    subscriber_uri: Annotated[Optional[str], Field(alias="subscriberUri")] = None
    """
    SubscriberURI is the endpoint for the subscriber
    """
    subscriber_ca_certs: Annotated[Optional[str], Field(alias="subscriberCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    subscriber_audience: Annotated[Optional[str], Field(alias="subscriberAudience")] = None
    """
    SubscriberAudience is the OIDC audience for the subscriberUri.
    """
    uid: Optional[str] = None
    """
    UID is used to understand the origin of the subscriber.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """


class ChannelSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChannelSpec"]:
            return ChannelSpec

        def build(self) -> "ChannelSpec":
            return ChannelSpec(**self._attrs)

        @overload
        def channel_template(
            self, value_or_callback: Optional[ChannelTemplate], /
        ) -> "ChannelSpec.Builder": ...

        @overload
        def channel_template(
            self,
            value_or_callback: Callable[
                [ChannelTemplate.Builder], ChannelTemplate.Builder | ChannelTemplate
            ],
            /,
        ) -> "ChannelSpec.Builder": ...

        @overload
        def channel_template(
            self, value_or_callback: Never = ...
        ) -> "ChannelTemplate.BuilderContext": ...

        def channel_template(self, value_or_callback=None, /):
            """
            ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel. This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.
            """
            if self._in_context and value_or_callback is None:
                context = ChannelTemplate.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel_template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChannelTemplate.builder())
                if isinstance(output, ChannelTemplate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel_template", value)

        @overload
        def delivery(self, value_or_callback: Optional[Delivery], /) -> "ChannelSpec.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "ChannelSpec.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            DeliverySpec contains the default delivery spec for each subscription to this Channelable. Each subscription delivery spec, if any, overrides this global delivery spec.
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

        @overload
        def subscribers(self, value_or_callback: List[Subscriber], /) -> "ChannelSpec.Builder": ...

        @overload
        def subscribers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subscriber, Subscriber.Builder]],
                GenericListBuilder[Subscriber, Subscriber.Builder] | List[Subscriber],
            ],
            /,
        ) -> "ChannelSpec.Builder": ...

        @overload
        def subscribers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subscriber.Builder]: ...

        def subscribers(self, value_or_callback=None, /):
            """
            This is the list of subscriptions for this subscribable.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subscriber.Builder]()
                context._parent_builder = self
                context._field_name = "subscribers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subscriber.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscribers", value)

    class BuilderContext(BuilderContextBase["ChannelSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChannelSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChannelSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChannelSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChannelSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    channel_template: Annotated[Optional[ChannelTemplate], Field(alias="channelTemplate")] = None
    """
    ChannelTemplate specifies which Channel CRD to use to create the CRD Channel backing this Channel. This is immutable after creation. Normally this is set by the Channel defaulter, not directly by the user.
    """
    delivery: Optional[Delivery] = None
    """
    DeliverySpec contains the default delivery spec for each subscription to this Channelable. Each subscription delivery spec, if any, overrides this global delivery spec.
    """
    subscribers: Optional[List[Subscriber]] = None
    """
    This is the list of subscriptions for this subscribable.
    """


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    url: Optional[str] = None
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    audience: Optional[str] = None


class Channel(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Channel"]:
            return Channel

        def build(self) -> "Channel":
            return Channel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Channel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Channel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Channel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Channel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Channel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
            """
            return self._set("api_version", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the applied EventPolicy
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
    """
    name: Optional[str] = None
    """
    The name of the applied EventPolicy
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class DeadLetterChannel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterChannel"]:
            return DeadLetterChannel

        def build(self) -> "DeadLetterChannel":
            return DeadLetterChannel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["DeadLetterChannel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterChannel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterChannel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterChannel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterChannel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class SubscriberModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SubscriberModel"]:
            return SubscriberModel

        def build(self) -> "SubscriberModel":
            return SubscriberModel(**self._attrs)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details of Ready status.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            Generation of the origin of the subscriber with uid:UID.
            """
            return self._set("observed_generation", value)

        def ready(self, value: Optional[str], /) -> Self:
            """
            Status of the subscriber.
            """
            return self._set("ready", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID is used to understand the origin of the subscriber.
            """
            return self._set("uid", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "SubscriberModel.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "SubscriberModel.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

    class BuilderContext(BuilderContextBase["SubscriberModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SubscriberModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SubscriberModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SubscriberModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubscriberModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    message: Optional[str] = None
    """
    A human readable message indicating details of Ready status.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    Generation of the origin of the subscriber with uid:UID.
    """
    ready: Optional[str] = None
    """
    Status of the subscriber.
    """
    uid: Optional[str] = None
    """
    UID is used to understand the origin of the subscriber.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """


class ChannelStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChannelStatus"]:
            return ChannelStatus

        def build(self) -> "ChannelStatus":
            return ChannelStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "ChannelStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Channel is Addressable. It exposes the endpoint as an URI to get events delivered into the Channel mesh.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(self, value_or_callback: List[Address], /) -> "ChannelStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            Channel is Addressable. It exposes the endpoints as URIs to get events delivered into the Channel mesh.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def channel(self, value_or_callback: Optional[Channel], /) -> "ChannelStatus.Builder": ...

        @overload
        def channel(
            self,
            value_or_callback: Callable[[Channel.Builder], Channel.Builder | Channel],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def channel(self, value_or_callback: Never = ...) -> "Channel.BuilderContext": ...

        def channel(self, value_or_callback=None, /):
            """
            Channel is an KReference to the Channel CRD backing this Channel.
            """
            if self._in_context and value_or_callback is None:
                context = Channel.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Channel.builder())
                if isinstance(output, Channel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel", value)

        @overload
        def policies(self, value_or_callback: List[Policy], /) -> "ChannelStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "ChannelStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def dead_letter_channel(
            self, value_or_callback: Optional[DeadLetterChannel], /
        ) -> "ChannelStatus.Builder": ...

        @overload
        def dead_letter_channel(
            self,
            value_or_callback: Callable[
                [DeadLetterChannel.Builder],
                DeadLetterChannel.Builder | DeadLetterChannel,
            ],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def dead_letter_channel(
            self, value_or_callback: Never = ...
        ) -> "DeadLetterChannel.BuilderContext": ...

        def dead_letter_channel(self, value_or_callback=None, /):
            """
            DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.
            """
            if self._in_context and value_or_callback is None:
                context = DeadLetterChannel.BuilderContext()
                context._parent_builder = self
                context._field_name = "dead_letter_channel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeadLetterChannel.builder())
                if isinstance(output, DeadLetterChannel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dead_letter_channel", value)

        def dead_letter_sink_uri(self, value: Optional[str], /) -> Self:
            """
            DeadLetterSinkURI is the resolved URI of the dead letter sink that will be used as a fallback when not specified by Triggers.
            """
            return self._set("dead_letter_sink_uri", value)

        def dead_letter_sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("dead_letter_sink_ca_certs", value)

        def dead_letter_sink_audience(self, value: Optional[str], /) -> Self:
            """
            OIDC audience of the dead letter sink.
            """
            return self._set("dead_letter_sink_audience", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def subscribers(
            self, value_or_callback: List[SubscriberModel], /
        ) -> "ChannelStatus.Builder": ...

        @overload
        def subscribers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[SubscriberModel, SubscriberModel.Builder]],
                GenericListBuilder[SubscriberModel, SubscriberModel.Builder]
                | List[SubscriberModel],
            ],
            /,
        ) -> "ChannelStatus.Builder": ...

        @overload
        def subscribers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[SubscriberModel.Builder]: ...

        def subscribers(self, value_or_callback=None, /):
            """
            This is the list of subscription's statuses for this channel.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[SubscriberModel.Builder]()
                context._parent_builder = self
                context._field_name = "subscribers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SubscriberModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscribers", value)

    class BuilderContext(BuilderContextBase["ChannelStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChannelStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChannelStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChannelStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChannelStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Channel is Addressable. It exposes the endpoint as an URI to get events delivered into the Channel mesh.
    """
    addresses: Optional[List[Address]] = None
    """
    Channel is Addressable. It exposes the endpoints as URIs to get events delivered into the Channel mesh.
    """
    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    channel: Optional[Channel] = None
    """
    Channel is an KReference to the Channel CRD backing this Channel.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    dead_letter_channel: Annotated[
        Optional[DeadLetterChannel], Field(alias="deadLetterChannel")
    ] = None
    """
    DeadLetterChannel is a KReference and is set by the channel when it supports native error handling via a channel Failed messages are delivered here.
    """
    dead_letter_sink_uri: Annotated[Optional[str], Field(alias="deadLetterSinkUri")] = None
    """
    DeadLetterSinkURI is the resolved URI of the dead letter sink that will be used as a fallback when not specified by Triggers.
    """
    dead_letter_sink_ca_certs: Annotated[Optional[str], Field(alias="deadLetterSinkCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    dead_letter_sink_audience: Annotated[Optional[str], Field(alias="deadLetterSinkAudience")] = (
        None
    )
    """
    OIDC audience of the dead letter sink.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    subscribers: Optional[List[SubscriberModel]] = None
    """
    This is the list of subscription's statuses for this channel.
    """


class DeadLetterSinkModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterSinkModel1"]:
            return DeadLetterSinkModel1

        def build(self) -> "DeadLetterSinkModel1":
            return DeadLetterSinkModel1(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "DeadLetterSinkModel1.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "DeadLetterSinkModel1.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["DeadLetterSinkModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterSinkModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterSinkModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterSinkModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterSinkModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Reply(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Reply"]:
            return Reply

        def build(self) -> "Reply":
            return Reply(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Reply.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Reply.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Reply.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Reply.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Reply."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Reply", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Reply.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class SubscriberModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SubscriberModel1"]:
            return SubscriberModel1

        def build(self) -> "SubscriberModel1":
            return SubscriberModel1(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "SubscriberModel1.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "SubscriberModel1.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the subscription trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["SubscriberModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SubscriberModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SubscriberModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SubscriberModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubscriberModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the subscription trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class SubscriptionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SubscriptionSpec"]:
            return SubscriptionSpec

        def build(self) -> "SubscriptionSpec":
            return SubscriptionSpec(**self._attrs)

        @overload
        def channel(
            self, value_or_callback: Optional[Channel], /
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def channel(
            self,
            value_or_callback: Callable[[Channel.Builder], Channel.Builder | Channel],
            /,
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def channel(self, value_or_callback: Never = ...) -> "Channel.BuilderContext": ...

        def channel(self, value_or_callback=None, /):
            """
            Reference to a channel that will be used to create the subscription. You can specify only the following fields of the KReference: kind, apiVersion, name and namespace. The resource pointed by this KReference must meet the contract to the ChannelableSpec duck type. If the resource does not meet this contract it will be reflected in the Subscription's status.  This field is immutable. We have no good answer on what happens to the events that are currently in the channel being consumed from and what the semantics there should be. For now, you can always delete the Subscription and recreate it to point to a different channel, giving the user more control over what semantics should be used (drain the channel first, possibly have events dropped, etc.)
            """
            if self._in_context and value_or_callback is None:
                context = Channel.BuilderContext()
                context._parent_builder = self
                context._field_name = "channel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Channel.builder())
                if isinstance(output, Channel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("channel", value)

        @overload
        def delivery(
            self, value_or_callback: Optional[Delivery], /
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            Delivery configuration
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

        @overload
        def reply(self, value_or_callback: Optional[Reply], /) -> "SubscriptionSpec.Builder": ...

        @overload
        def reply(
            self, value_or_callback: Callable[[Reply.Builder], Reply.Builder | Reply], /
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def reply(self, value_or_callback: Never = ...) -> "Reply.BuilderContext": ...

        def reply(self, value_or_callback=None, /):
            """
            Reply specifies (optionally) how to handle events returned from the Subscriber target.
            """
            if self._in_context and value_or_callback is None:
                context = Reply.BuilderContext()
                context._parent_builder = self
                context._field_name = "reply"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Reply.builder())
                if isinstance(output, Reply.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("reply", value)

        @overload
        def subscriber(
            self, value_or_callback: Optional[SubscriberModel1], /
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def subscriber(
            self,
            value_or_callback: Callable[
                [SubscriberModel1.Builder], SubscriberModel1.Builder | SubscriberModel1
            ],
            /,
        ) -> "SubscriptionSpec.Builder": ...

        @overload
        def subscriber(
            self, value_or_callback: Never = ...
        ) -> "SubscriberModel1.BuilderContext": ...

        def subscriber(self, value_or_callback=None, /):
            """
            Subscriber is reference to (optional) function for processing events. Events from the Channel will be delivered here and replies are sent to a Destination as specified by the Reply.
            """
            if self._in_context and value_or_callback is None:
                context = SubscriberModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscriber"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SubscriberModel1.builder())
                if isinstance(output, SubscriberModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscriber", value)

    class BuilderContext(BuilderContextBase["SubscriptionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SubscriptionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SubscriptionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SubscriptionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubscriptionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    channel: Optional[Channel] = None
    """
    Reference to a channel that will be used to create the subscription. You can specify only the following fields of the KReference: kind, apiVersion, name and namespace. The resource pointed by this KReference must meet the contract to the ChannelableSpec duck type. If the resource does not meet this contract it will be reflected in the Subscription's status.  This field is immutable. We have no good answer on what happens to the events that are currently in the channel being consumed from and what the semantics there should be. For now, you can always delete the Subscription and recreate it to point to a different channel, giving the user more control over what semantics should be used (drain the channel first, possibly have events dropped, etc.)
    """
    delivery: Optional[Delivery] = None
    """
    Delivery configuration
    """
    reply: Optional[Reply] = None
    """
    Reply specifies (optionally) how to handle events returned from the Subscriber target.
    """
    subscriber: Optional[SubscriberModel1] = None
    """
    Subscriber is reference to (optional) function for processing events. Events from the Channel will be delivered here and replies are sent to a Destination as specified by the Reply.
    """


class PhysicalSubscription(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PhysicalSubscription"]:
            return PhysicalSubscription

        def build(self) -> "PhysicalSubscription":
            return PhysicalSubscription(**self._attrs)

        def dead_letter_sink_uri(self, value: Optional[str], /) -> Self:
            """
            ReplyURI is the fully resolved URI for the spec.delivery.deadLetterSink.
            """
            return self._set("dead_letter_sink_uri", value)

        def dead_letter_sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("dead_letter_sink_ca_certs", value)

        def dead_letter_sink_audience(self, value: Optional[str], /) -> Self:
            """
            OIDC audience of the dead letter sink.
            """
            return self._set("dead_letter_sink_audience", value)

        def reply_uri(self, value: Optional[str], /) -> Self:
            """
            ReplyURI is the fully resolved URI for the spec.reply.
            """
            return self._set("reply_uri", value)

        def reply_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("reply_ca_certs", value)

        def reply_audience(self, value: Optional[str], /) -> Self:
            """
            ReplyAudience is the OIDC audience for the replyUri.
            """
            return self._set("reply_audience", value)

        def subscriber_uri(self, value: Optional[str], /) -> Self:
            """
            SubscriberURI is the fully resolved URI for spec.subscriber.
            """
            return self._set("subscriber_uri", value)

        def subscriber_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("subscriber_ca_certs", value)

        def subscriber_audience(self, value: Optional[str], /) -> Self:
            """
            SubscriberAudience is the OIDC audience for the subscriberUri.
            """
            return self._set("subscriber_audience", value)

    class BuilderContext(BuilderContextBase["PhysicalSubscription.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PhysicalSubscription.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PhysicalSubscription."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PhysicalSubscription", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PhysicalSubscription.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dead_letter_sink_uri: Annotated[Optional[str], Field(alias="deadLetterSinkUri")] = None
    """
    ReplyURI is the fully resolved URI for the spec.delivery.deadLetterSink.
    """
    dead_letter_sink_ca_certs: Annotated[Optional[str], Field(alias="deadLetterSinkCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    dead_letter_sink_audience: Annotated[Optional[str], Field(alias="deadLetterSinkAudience")] = (
        None
    )
    """
    OIDC audience of the dead letter sink.
    """
    reply_uri: Annotated[Optional[str], Field(alias="replyUri")] = None
    """
    ReplyURI is the fully resolved URI for the spec.reply.
    """
    reply_ca_certs: Annotated[Optional[str], Field(alias="replyCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    reply_audience: Annotated[Optional[str], Field(alias="replyAudience")] = None
    """
    ReplyAudience is the OIDC audience for the replyUri.
    """
    subscriber_uri: Annotated[Optional[str], Field(alias="subscriberUri")] = None
    """
    SubscriberURI is the fully resolved URI for spec.subscriber.
    """
    subscriber_ca_certs: Annotated[Optional[str], Field(alias="subscriberCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    subscriber_audience: Annotated[Optional[str], Field(alias="subscriberAudience")] = None
    """
    SubscriberAudience is the OIDC audience for the subscriberUri.
    """


class SubscriptionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SubscriptionStatus"]:
            return SubscriptionStatus

        def build(self) -> "SubscriptionStatus":
            return SubscriptionStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "SubscriptionStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def physical_subscription(
            self, value_or_callback: Optional[PhysicalSubscription], /
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def physical_subscription(
            self,
            value_or_callback: Callable[
                [PhysicalSubscription.Builder],
                PhysicalSubscription.Builder | PhysicalSubscription,
            ],
            /,
        ) -> "SubscriptionStatus.Builder": ...

        @overload
        def physical_subscription(
            self, value_or_callback: Never = ...
        ) -> "PhysicalSubscription.BuilderContext": ...

        def physical_subscription(self, value_or_callback=None, /):
            """
            PhysicalSubscription is the fully resolved values that this Subscription represents.
            """
            if self._in_context and value_or_callback is None:
                context = PhysicalSubscription.BuilderContext()
                context._parent_builder = self
                context._field_name = "physical_subscription"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PhysicalSubscription.builder())
                if isinstance(output, PhysicalSubscription.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("physical_subscription", value)

    class BuilderContext(BuilderContextBase["SubscriptionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SubscriptionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SubscriptionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SubscriptionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SubscriptionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    physical_subscription: Annotated[
        Optional[PhysicalSubscription], Field(alias="physicalSubscription")
    ] = None
    """
    PhysicalSubscription is the fully resolved values that this Subscription represents.
    """


class ChannelModel(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ChannelModel"]:
            return ChannelModel

        def build(self) -> "ChannelModel":
            return ChannelModel(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[ChannelSpec], /) -> "ChannelModel.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ChannelSpec.Builder], ChannelSpec.Builder | ChannelSpec],
            /,
        ) -> "ChannelModel.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ChannelSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ChannelSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChannelSpec.builder())
                if isinstance(output, ChannelSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ChannelStatus], /
        ) -> "ChannelModel.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ChannelStatus.Builder], ChannelStatus.Builder | ChannelStatus
            ],
            /,
        ) -> "ChannelModel.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ChannelStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ChannelStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ChannelStatus.builder())
                if isinstance(output, ChannelStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["messaging.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Channel"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ChannelModel.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ChannelModel.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["ChannelModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ChannelModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ChannelModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ChannelModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ChannelModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[ChannelSpec] = None
    status: Optional[ChannelStatus] = None
    api_version: Annotated[
        Optional[Literal["messaging.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "messaging.knative.dev/v1"
    kind: Optional[Literal["Channel"]] = "Channel"
    metadata: Optional[apimachinery.ObjectMeta] = None


class Subscription(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subscription"]:
            return Subscription

        def build(self) -> "Subscription":
            return Subscription(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[SubscriptionSpec], /
        ) -> "Subscription.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [SubscriptionSpec.Builder], SubscriptionSpec.Builder | SubscriptionSpec
            ],
            /,
        ) -> "Subscription.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "SubscriptionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SubscriptionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SubscriptionSpec.builder())
                if isinstance(output, SubscriptionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[SubscriptionStatus], /
        ) -> "Subscription.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [SubscriptionStatus.Builder],
                SubscriptionStatus.Builder | SubscriptionStatus,
            ],
            /,
        ) -> "Subscription.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "SubscriptionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SubscriptionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SubscriptionStatus.builder())
                if isinstance(output, SubscriptionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["messaging.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Subscription"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Subscription.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Subscription.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Subscription.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subscription.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subscription."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subscription", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subscription.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[SubscriptionSpec] = None
    status: Optional[SubscriptionStatus] = None
    api_version: Annotated[
        Optional[Literal["messaging.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "messaging.knative.dev/v1"
    kind: Optional[Literal["Subscription"]] = "Subscription"
    metadata: Optional[apimachinery.ObjectMeta] = None
