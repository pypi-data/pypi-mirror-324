# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Log(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Log"]:
            return Log

        def build(self) -> "Log":
            return Log(**self._attrs)

        def logger_name(self, value: Optional[str], /) -> Self:
            """
            Name of the logging category to use
            """
            return self._set("logger_name", value)

        def level(self, value: Optional[str], /) -> Self:
            """
            Logging level to use
            """
            return self._set("level", value)

        def log_mask(self, value: Optional[bool], /) -> Self:
            """
            Mask sensitive information like password or passphrase in the log
            """
            return self._set("log_mask", value)

        def marker(self, value: Optional[str], /) -> Self:
            """
            An optional Marker name to use
            """
            return self._set("marker", value)

        def multiline(self, value: Optional[bool], /) -> Self:
            """
            If enabled then each information is outputted on a newline
            """
            return self._set("multiline", value)

        def show_all_properties(self, value: Optional[bool], /) -> Self:
            """
            Show all of the exchange properties (both internal and custom)
            """
            return self._set("show_all_properties", value)

        def show_body(self, value: Optional[bool], /) -> Self:
            """
            Show the message body
            """
            return self._set("show_body", value)

        def show_body_type(self, value: Optional[bool], /) -> Self:
            """
            Show the body Java type
            """
            return self._set("show_body_type", value)

        def show_exchange_pattern(self, value: Optional[bool], /) -> Self:
            """
            Shows the Message Exchange Pattern (or MEP for short)
            """
            return self._set("show_exchange_pattern", value)

        def show_headers(self, value: Optional[bool], /) -> Self:
            """
            Show the headers received
            """
            return self._set("show_headers", value)

        def show_properties(self, value: Optional[bool], /) -> Self:
            """
            Show the exchange properties (only custom). Use showAllProperties to show both internal and custom properties.
            """
            return self._set("show_properties", value)

        def show_streams(self, value: Optional[bool], /) -> Self:
            """
            Show the stream bodies (they may not be available in following steps)
            """
            return self._set("show_streams", value)

        def show_cached_streams(self, value: Optional[bool], /) -> Self:
            """
            Whether Camel should show cached stream bodies or not.
            """
            return self._set("show_cached_streams", value)

    class BuilderContext(BuilderContextBase["Log.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Log.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Log."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Log", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Log.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    logger_name: Annotated[Optional[str], Field(alias="loggerName", title="Logger Name")] = (
        "log-sink"
    )
    """
    Name of the logging category to use
    """
    level: Annotated[Optional[str], Field(title="Log Level")] = "INFO"
    """
    Logging level to use
    """
    log_mask: Annotated[Optional[bool], Field(alias="logMask", title="Log Mask")] = False
    """
    Mask sensitive information like password or passphrase in the log
    """
    marker: Annotated[Optional[str], Field(title="Marker")] = None
    """
    An optional Marker name to use
    """
    multiline: Annotated[Optional[bool], Field(title="Multiline")] = False
    """
    If enabled then each information is outputted on a newline
    """
    show_all_properties: Annotated[
        Optional[bool], Field(alias="showAllProperties", title="Show All Properties")
    ] = False
    """
    Show all of the exchange properties (both internal and custom)
    """
    show_body: Annotated[Optional[bool], Field(alias="showBody", title="Show Body")] = True
    """
    Show the message body
    """
    show_body_type: Annotated[
        Optional[bool], Field(alias="showBodyType", title="Show Body Type")
    ] = True
    """
    Show the body Java type
    """
    show_exchange_pattern: Annotated[
        Optional[bool],
        Field(alias="showExchangePattern", title="Show Exchange Pattern"),
    ] = True
    """
    Shows the Message Exchange Pattern (or MEP for short)
    """
    show_headers: Annotated[Optional[bool], Field(alias="showHeaders", title="Show Headers")] = (
        False
    )
    """
    Show the headers received
    """
    show_properties: Annotated[
        Optional[bool], Field(alias="showProperties", title="Show Properties")
    ] = False
    """
    Show the exchange properties (only custom). Use showAllProperties to show both internal and custom properties.
    """
    show_streams: Annotated[Optional[bool], Field(alias="showStreams", title="Show Streams")] = (
        False
    )
    """
    Show the stream bodies (they may not be available in following steps)
    """
    show_cached_streams: Annotated[
        Optional[bool], Field(alias="showCachedStreams", title="Show Cached Streams")
    ] = True
    """
    Whether Camel should show cached stream bodies or not.
    """


class S3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["S3"]:
            return S3

        def build(self) -> "S3":
            return S3(**self._attrs)

        def arn(self, value: Optional[str], /) -> Self:
            """
            The S3 Bucket name or Amazon Resource Name (ARN).
            """
            return self._set("arn", value)

        def delete_after_read(self, value: Optional[bool], /) -> Self:
            """
            Specifies to delete objects after consuming them.
            """
            return self._set("delete_after_read", value)

        def move_after_read(self, value: Optional[bool], /) -> Self:
            """
            Move objects from S3 bucket to a different bucket after they have been retrieved.
            """
            return self._set("move_after_read", value)

        def destination_bucket(self, value: Optional[str], /) -> Self:
            """
            Define the destination bucket where an object must be moved when moveAfterRead is set to true.
            """
            return self._set("destination_bucket", value)

        def destination_bucket_prefix(self, value: Optional[str], /) -> Self:
            """
            Define the destination bucket prefix to use when an object must be moved, and moveAfterRead is set to true.
            """
            return self._set("destination_bucket_prefix", value)

        def destination_bucket_suffix(self, value: Optional[str], /) -> Self:
            """
            Define the destination bucket suffix to use when an object must be moved, and moveAfterRead is set to true.
            """
            return self._set("destination_bucket_suffix", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region to access.
            """
            return self._set("region", value)

        def auto_create_bucket(self, value: Optional[bool], /) -> Self:
            """
            Specifies to automatically create the S3 bucket.
            """
            return self._set("auto_create_bucket", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            The AWS S3 bucket prefix to consider while searching.
            """
            return self._set("prefix", value)

        def ignore_body(self, value: Optional[bool], /) -> Self:
            """
            If true, the S3 Object body is ignored. Setting this to true overrides any behavior defined by the `includeBody` option. If false, the S3 object is put in the body.
            """
            return self._set("ignore_body", value)

        def uri_endpoint_override(self, value: Optional[str], /) -> Self:
            """
            The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
            """
            return self._set("uri_endpoint_override", value)

        def override_endpoint(self, value: Optional[bool], /) -> Self:
            """
            Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
            """
            return self._set("override_endpoint", value)

        def force_path_style(self, value: Optional[bool], /) -> Self:
            """
            Forces path style when accessing AWS S3 buckets.
            """
            return self._set("force_path_style", value)

        def delay(self, value: Optional[int], /) -> Self:
            """
            The number of milliseconds before the next poll of the selected bucket.
            """
            return self._set("delay", value)

        def max_messages_per_poll(self, value: Optional[int], /) -> Self:
            """
            Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.
            """
            return self._set("max_messages_per_poll", value)

    class BuilderContext(BuilderContextBase["S3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = S3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for S3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["S3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use S3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arn: Annotated[Optional[str], Field(title="Bucket Name")] = None
    """
    The S3 Bucket name or Amazon Resource Name (ARN).
    """
    delete_after_read: Annotated[
        Optional[bool], Field(alias="deleteAfterRead", title="Auto-delete Objects")
    ] = True
    """
    Specifies to delete objects after consuming them.
    """
    move_after_read: Annotated[
        Optional[bool], Field(alias="moveAfterRead", title="Move Objects After Delete")
    ] = False
    """
    Move objects from S3 bucket to a different bucket after they have been retrieved.
    """
    destination_bucket: Annotated[
        Optional[str], Field(alias="destinationBucket", title="Destination Bucket")
    ] = None
    """
    Define the destination bucket where an object must be moved when moveAfterRead is set to true.
    """
    destination_bucket_prefix: Annotated[
        Optional[str],
        Field(alias="destinationBucketPrefix", title="Destination Bucket Prefix"),
    ] = None
    """
    Define the destination bucket prefix to use when an object must be moved, and moveAfterRead is set to true.
    """
    destination_bucket_suffix: Annotated[
        Optional[str],
        Field(alias="destinationBucketSuffix", title="Destination Bucket Suffix"),
    ] = None
    """
    Define the destination bucket suffix to use when an object must be moved, and moveAfterRead is set to true.
    """
    region: Annotated[Optional[str], Field(title="AWS Region")] = None
    """
    The AWS region to access.
    """
    auto_create_bucket: Annotated[
        Optional[bool], Field(alias="autoCreateBucket", title="Autocreate Bucket")
    ] = False
    """
    Specifies to automatically create the S3 bucket.
    """
    prefix: Annotated[Optional[str], Field(examples=["folder/"], title="Prefix")] = None
    """
    The AWS S3 bucket prefix to consider while searching.
    """
    ignore_body: Annotated[Optional[bool], Field(alias="ignoreBody", title="Ignore Body")] = False
    """
    If true, the S3 Object body is ignored. Setting this to true overrides any behavior defined by the `includeBody` option. If false, the S3 object is put in the body.
    """
    uri_endpoint_override: Annotated[
        Optional[str],
        Field(alias="uriEndpointOverride", title="Overwrite Endpoint URI"),
    ] = None
    """
    The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
    """
    override_endpoint: Annotated[
        Optional[bool], Field(alias="overrideEndpoint", title="Endpoint Overwrite")
    ] = False
    """
    Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
    """
    force_path_style: Annotated[
        Optional[bool], Field(alias="forcePathStyle", title="Force Path Style")
    ] = False
    """
    Forces path style when accessing AWS S3 buckets.
    """
    delay: Annotated[Optional[int], Field(title="Delay")] = 500
    """
    The number of milliseconds before the next poll of the selected bucket.
    """
    max_messages_per_poll: Annotated[
        Optional[int], Field(alias="maxMessagesPerPoll", title="Max Messages Per Poll")
    ] = 10
    """
    Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.
    """


class Sqs(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sqs"]:
            return Sqs

        def build(self) -> "Sqs":
            return Sqs(**self._attrs)

        def arn(self, value: Optional[str], /) -> Self:
            """
            The SQS Queue Name or ARN
            """
            return self._set("arn", value)

        def delete_after_read(self, value: Optional[bool], /) -> Self:
            """
            Delete messages after consuming them
            """
            return self._set("delete_after_read", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region to access.
            """
            return self._set("region", value)

        def auto_create_queue(self, value: Optional[bool], /) -> Self:
            """
            Setting the autocreation of the SQS queue.
            """
            return self._set("auto_create_queue", value)

        def host(self, value: Optional[str], /) -> Self:
            """
            The hostname of the Amazon AWS cloud.
            """
            return self._set("host", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            The underlying protocol used to communicate with SQS
            """
            return self._set("protocol", value)

        def queue_url(self, value: Optional[str], /) -> Self:
            """
            The full SQS Queue URL (required if using KEDA)
            """
            return self._set("queue_url", value)

        def uri_endpoint_override(self, value: Optional[str], /) -> Self:
            """
            The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
            """
            return self._set("uri_endpoint_override", value)

        def override_endpoint(self, value: Optional[bool], /) -> Self:
            """
            Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
            """
            return self._set("override_endpoint", value)

        def delay(self, value: Optional[int], /) -> Self:
            """
            The number of milliseconds before the next poll of the selected stream
            """
            return self._set("delay", value)

        def greedy(self, value: Optional[bool], /) -> Self:
            """
            If greedy is enabled, then the polling will happen immediately again, if the previous run polled 1 or more messages.
            """
            return self._set("greedy", value)

        def max_messages_per_poll(self, value: Optional[int], /) -> Self:
            """
            The maximum number of messages to return. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values 1 to 10. Default 1.
            """
            return self._set("max_messages_per_poll", value)

        def wait_time_seconds(self, value: Optional[int], /) -> Self:
            """
            The duration (in seconds) for which the call waits for a message to arrive in the queue before returning. If a message is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call does not return a message list.
            """
            return self._set("wait_time_seconds", value)

        def visibility_timeout(self, value: Optional[int], /) -> Self:
            """
            The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
            """
            return self._set("visibility_timeout", value)

    class BuilderContext(BuilderContextBase["Sqs.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sqs.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sqs."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sqs", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sqs.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arn: Annotated[Optional[str], Field(title="Queue Name")] = None
    """
    The SQS Queue Name or ARN
    """
    delete_after_read: Annotated[
        Optional[bool], Field(alias="deleteAfterRead", title="Auto-delete Messages")
    ] = True
    """
    Delete messages after consuming them
    """
    region: Annotated[Optional[str], Field(title="AWS Region")] = None
    """
    The AWS region to access.
    """
    auto_create_queue: Annotated[
        Optional[bool], Field(alias="autoCreateQueue", title="Autocreate Queue")
    ] = False
    """
    Setting the autocreation of the SQS queue.
    """
    host: Annotated[Optional[str], Field(title="AWS Host")] = "amazonaws.com"
    """
    The hostname of the Amazon AWS cloud.
    """
    protocol: Annotated[Optional[str], Field(examples=["http or https"], title="Protocol")] = (
        "https"
    )
    """
    The underlying protocol used to communicate with SQS
    """
    queue_url: Annotated[Optional[str], Field(alias="queueURL", title="Queue URL")] = None
    """
    The full SQS Queue URL (required if using KEDA)
    """
    uri_endpoint_override: Annotated[
        Optional[str],
        Field(alias="uriEndpointOverride", title="Overwrite Endpoint URI"),
    ] = None
    """
    The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
    """
    override_endpoint: Annotated[
        Optional[bool], Field(alias="overrideEndpoint", title="Endpoint Overwrite")
    ] = False
    """
    Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
    """
    delay: Annotated[Optional[int], Field(title="Delay")] = 500
    """
    The number of milliseconds before the next poll of the selected stream
    """
    greedy: Annotated[Optional[bool], Field(title="Greedy Scheduler")] = False
    """
    If greedy is enabled, then the polling will happen immediately again, if the previous run polled 1 or more messages.
    """
    max_messages_per_poll: Annotated[
        Optional[int], Field(alias="maxMessagesPerPoll", title="Max Messages Per Poll")
    ] = 1
    """
    The maximum number of messages to return. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values 1 to 10. Default 1.
    """
    wait_time_seconds: Annotated[
        Optional[int], Field(alias="waitTimeSeconds", title="Wait Time Seconds")
    ] = None
    """
    The duration (in seconds) for which the call waits for a message to arrive in the queue before returning. If a message is available, the call returns sooner than WaitTimeSeconds. If no messages are available and the wait time expires, the call does not return a message list.
    """
    visibility_timeout: Annotated[
        Optional[int], Field(alias="visibilityTimeout", title="Visibility Timeout")
    ] = None
    """
    The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
    """


class Sns(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sns"]:
            return Sns

        def build(self) -> "Sns":
            return Sns(**self._attrs)

        def arn(self, value: Optional[str], /) -> Self:
            """
            The SNS topic name name or Amazon Resource Name (ARN).
            """
            return self._set("arn", value)

        def region(self, value: Optional[str], /) -> Self:
            """
            The AWS region to access.
            """
            return self._set("region", value)

        def auto_create_topic(self, value: Optional[bool], /) -> Self:
            """
            Setting the autocreation of the SNS topic.
            """
            return self._set("auto_create_topic", value)

        def uri_endpoint_override(self, value: Optional[str], /) -> Self:
            """
            The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
            """
            return self._set("uri_endpoint_override", value)

        def override_endpoint(self, value: Optional[bool], /) -> Self:
            """
            Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
            """
            return self._set("override_endpoint", value)

    class BuilderContext(BuilderContextBase["Sns.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sns.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sns."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sns", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sns.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arn: Annotated[Optional[str], Field(title="Topic Name")] = None
    """
    The SNS topic name name or Amazon Resource Name (ARN).
    """
    region: Annotated[Optional[str], Field(title="AWS Region")] = None
    """
    The AWS region to access.
    """
    auto_create_topic: Annotated[
        Optional[bool], Field(alias="autoCreateTopic", title="Autocreate Topic")
    ] = False
    """
    Setting the autocreation of the SNS topic.
    """
    uri_endpoint_override: Annotated[
        Optional[str],
        Field(alias="uriEndpointOverride", title="Overwrite Endpoint URI"),
    ] = None
    """
    The overriding endpoint URI. To use this option, you must also select the `overrideEndpoint` option.
    """
    override_endpoint: Annotated[
        Optional[bool], Field(alias="overrideEndpoint", title="Endpoint Overwrite")
    ] = False
    """
    Select this option to override the endpoint URI. To use this option, you must also provide a URI for the `uriEndpointOverride` option.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Secret name
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Secret name
    """


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Secret.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Secret.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Secret reference.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Secret reference.
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Auth.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Auth.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Auth secret
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret: Optional[Secret] = None
    """
    Auth secret
    """


class Aws(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Aws"]:
            return Aws

        def build(self) -> "Aws":
            return Aws(**self._attrs)

        @overload
        def s3(self, value_or_callback: Optional[S3], /) -> "Aws.Builder": ...

        @overload
        def s3(
            self, value_or_callback: Callable[[S3.Builder], S3.Builder | S3], /
        ) -> "Aws.Builder": ...

        @overload
        def s3(self, value_or_callback: Never = ...) -> "S3.BuilderContext": ...

        def s3(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = S3.BuilderContext()
                context._parent_builder = self
                context._field_name = "s3"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(S3.builder())
                if isinstance(output, S3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("s3", value)

        @overload
        def sqs(self, value_or_callback: Optional[Sqs], /) -> "Aws.Builder": ...

        @overload
        def sqs(
            self, value_or_callback: Callable[[Sqs.Builder], Sqs.Builder | Sqs], /
        ) -> "Aws.Builder": ...

        @overload
        def sqs(self, value_or_callback: Never = ...) -> "Sqs.BuilderContext": ...

        def sqs(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Sqs.BuilderContext()
                context._parent_builder = self
                context._field_name = "sqs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sqs.builder())
                if isinstance(output, Sqs.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sqs", value)

        @overload
        def sns(self, value_or_callback: Optional[Sns], /) -> "Aws.Builder": ...

        @overload
        def sns(
            self, value_or_callback: Callable[[Sns.Builder], Sns.Builder | Sns], /
        ) -> "Aws.Builder": ...

        @overload
        def sns(self, value_or_callback: Never = ...) -> "Sns.BuilderContext": ...

        def sns(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Sns.BuilderContext()
                context._parent_builder = self
                context._field_name = "sns"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sns.builder())
                if isinstance(output, Sns.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sns", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "Aws.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "Aws.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth configurations
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

    class BuilderContext(BuilderContextBase["Aws.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Aws.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Aws."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Aws", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Aws.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    s3: Optional[S3] = None
    sqs: Optional[Sqs] = None
    sns: Optional[Sns] = None
    auth: Optional[Auth] = None
    """
    Auth configurations
    """


class IntegrationSinkSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IntegrationSinkSpec"]:
            return IntegrationSinkSpec

        def build(self) -> "IntegrationSinkSpec":
            return IntegrationSinkSpec(**self._attrs)

        @overload
        def log(self, value_or_callback: Optional[Log], /) -> "IntegrationSinkSpec.Builder": ...

        @overload
        def log(
            self, value_or_callback: Callable[[Log.Builder], Log.Builder | Log], /
        ) -> "IntegrationSinkSpec.Builder": ...

        @overload
        def log(self, value_or_callback: Never = ...) -> "Log.BuilderContext": ...

        def log(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Log.BuilderContext()
                context._parent_builder = self
                context._field_name = "log"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Log.builder())
                if isinstance(output, Log.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("log", value)

        @overload
        def aws(self, value_or_callback: Optional[Aws], /) -> "IntegrationSinkSpec.Builder": ...

        @overload
        def aws(
            self, value_or_callback: Callable[[Aws.Builder], Aws.Builder | Aws], /
        ) -> "IntegrationSinkSpec.Builder": ...

        @overload
        def aws(self, value_or_callback: Never = ...) -> "Aws.BuilderContext": ...

        def aws(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Aws.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Aws.builder())
                if isinstance(output, Aws.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws", value)

    class BuilderContext(BuilderContextBase["IntegrationSinkSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IntegrationSinkSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IntegrationSinkSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IntegrationSinkSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IntegrationSinkSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    log: Optional[Log] = None
    aws: Optional[Aws] = None


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    url: Optional[str] = None
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    audience: Optional[str] = None


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
            """
            return self._set("api_version", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the applied EventPolicy
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
    """
    name: Optional[str] = None
    """
    The name of the applied EventPolicy
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class IntegrationSinkStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IntegrationSinkStatus"]:
            return IntegrationSinkStatus

        def build(self) -> "IntegrationSinkStatus":
            return IntegrationSinkStatus(**self._attrs)

        @overload
        def address(
            self, value_or_callback: Optional[Address], /
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            IntegrationSink is Addressable. It exposes the endpoints as URIs to get events delivered into the used Kamelet.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(
            self, value_or_callback: List[Address], /
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            IntegrationSink is Addressable. It exposes the endpoints as URIs to get events delivered into the used Kamelet.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def policies(
            self, value_or_callback: List[Policy], /
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "IntegrationSinkStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["IntegrationSinkStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IntegrationSinkStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IntegrationSinkStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IntegrationSinkStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IntegrationSinkStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    IntegrationSink is Addressable. It exposes the endpoints as URIs to get events delivered into the used Kamelet.
    """
    addresses: Optional[List[Address]] = None
    """
    IntegrationSink is Addressable. It exposes the endpoints as URIs to get events delivered into the used Kamelet.
    """
    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class JobSinkSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["JobSinkSpec"]:
            return JobSinkSpec

        def build(self) -> "JobSinkSpec":
            return JobSinkSpec(**self._attrs)

        def job(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Full Job resource object, see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#job-v1-batch for more details.
            """
            return self._set("job", value)

    class BuilderContext(BuilderContextBase["JobSinkSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = JobSinkSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for JobSinkSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["JobSinkSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use JobSinkSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    job: Optional[Dict[str, Any]] = None
    """
    Full Job resource object, see https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.30/#job-v1-batch for more details.
    """


class Job(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Job"]:
            return Job

        def build(self) -> "Job":
            return Job(**self._attrs)

        def selector(self, value: Optional[str], /) -> Self:
            """
            Label selector for all scheduled jobs
            """
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["Job.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Job.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Job."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Job", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Job.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    selector: Optional[str] = None
    """
    Label selector for all scheduled jobs
    """


class JobSinkStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["JobSinkStatus"]:
            return JobSinkStatus

        def build(self) -> "JobSinkStatus":
            return JobSinkStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "JobSinkStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "JobSinkStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            JobSink is Addressable. It exposes the endpoint as an URI to schedule long running jobs when an even occurs.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(self, value_or_callback: List[Address], /) -> "JobSinkStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "JobSinkStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            JobSink is Addressable. It exposes the endpoint as an URI to schedule long running jobs when an even occurs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        @overload
        def job(self, value_or_callback: Optional[Job], /) -> "JobSinkStatus.Builder": ...

        @overload
        def job(
            self, value_or_callback: Callable[[Job.Builder], Job.Builder | Job], /
        ) -> "JobSinkStatus.Builder": ...

        @overload
        def job(self, value_or_callback: Never = ...) -> "Job.BuilderContext": ...

        def job(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Job.BuilderContext()
                context._parent_builder = self
                context._field_name = "job"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Job.builder())
                if isinstance(output, Job.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("job", value)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def policies(self, value_or_callback: List[Policy], /) -> "JobSinkStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "JobSinkStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "JobSinkStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "JobSinkStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["JobSinkStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = JobSinkStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for JobSinkStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["JobSinkStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use JobSinkStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    JobSink is Addressable. It exposes the endpoint as an URI to schedule long running jobs when an even occurs.
    """
    addresses: Optional[List[Address]] = None
    """
    JobSink is Addressable. It exposes the endpoint as an URI to schedule long running jobs when an even occurs.
    """
    job: Optional[Job] = None
    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class IntegrationSink(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IntegrationSink"]:
            return IntegrationSink

        def build(self) -> "IntegrationSink":
            return IntegrationSink(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[IntegrationSinkSpec], /
        ) -> "IntegrationSink.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [IntegrationSinkSpec.Builder],
                IntegrationSinkSpec.Builder | IntegrationSinkSpec,
            ],
            /,
        ) -> "IntegrationSink.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IntegrationSinkSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IntegrationSinkSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IntegrationSinkSpec.builder())
                if isinstance(output, IntegrationSinkSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[IntegrationSinkStatus], /
        ) -> "IntegrationSink.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [IntegrationSinkStatus.Builder],
                IntegrationSinkStatus.Builder | IntegrationSinkStatus,
            ],
            /,
        ) -> "IntegrationSink.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "IntegrationSinkStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IntegrationSinkStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IntegrationSinkStatus.builder())
                if isinstance(output, IntegrationSinkStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sinks.knative.dev/v1alpha1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IntegrationSink"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "IntegrationSink.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "IntegrationSink.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["IntegrationSink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IntegrationSink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IntegrationSink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IntegrationSink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IntegrationSink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[IntegrationSinkSpec] = None
    status: Optional[IntegrationSinkStatus] = None
    api_version: Annotated[
        Optional[Literal["sinks.knative.dev/v1alpha1"]], Field(alias="apiVersion")
    ] = "sinks.knative.dev/v1alpha1"
    kind: Optional[Literal["IntegrationSink"]] = "IntegrationSink"
    metadata: Optional[apimachinery.ObjectMeta] = None


class JobSink(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["JobSink"]:
            return JobSink

        def build(self) -> "JobSink":
            return JobSink(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[JobSinkSpec], /) -> "JobSink.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[JobSinkSpec.Builder], JobSinkSpec.Builder | JobSinkSpec],
            /,
        ) -> "JobSink.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "JobSinkSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = JobSinkSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(JobSinkSpec.builder())
                if isinstance(output, JobSinkSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[JobSinkStatus], /) -> "JobSink.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [JobSinkStatus.Builder], JobSinkStatus.Builder | JobSinkStatus
            ],
            /,
        ) -> "JobSink.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "JobSinkStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = JobSinkStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(JobSinkStatus.builder())
                if isinstance(output, JobSinkStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["sinks.knative.dev/v1alpha1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["JobSink"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "JobSink.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "JobSink.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["JobSink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = JobSink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for JobSink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["JobSink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use JobSink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[JobSinkSpec] = None
    status: Optional[JobSinkStatus] = None
    api_version: Annotated[
        Optional[Literal["sinks.knative.dev/v1alpha1"]], Field(alias="apiVersion")
    ] = "sinks.knative.dev/v1alpha1"
    kind: Optional[Literal["JobSink"]] = "JobSink"
    metadata: Optional[apimachinery.ObjectMeta] = None
