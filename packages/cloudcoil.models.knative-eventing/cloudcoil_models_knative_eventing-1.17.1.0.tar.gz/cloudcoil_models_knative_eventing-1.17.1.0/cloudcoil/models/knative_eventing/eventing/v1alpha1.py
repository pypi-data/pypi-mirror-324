# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class From(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["From"]:
            return From

        def build(self) -> "From":
            return From(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "From.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "From.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref contains a direct reference to a resource which is allowed to send events to the target.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def sub(self, value: Optional[str], /) -> Self:
            """
            Sub sets the OIDC identity name to be allowed to send events to the target. It is also possible to set a glob-like pattern to match any suffix.
            """
            return self._set("sub", value)

    class BuilderContext(BuilderContextBase["From.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = From.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for From."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["From", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use From.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref contains a direct reference to a resource which is allowed to send events to the target.
    """
    sub: Optional[str] = None
    """
    Sub sets the OIDC identity name to be allowed to send events to the target. It is also possible to set a glob-like pattern to match any suffix.
    """


class RefModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RefModel"]:
            return RefModel

        def build(self) -> "RefModel":
            return RefModel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["RefModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RefModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RefModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RefModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RefModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: Optional[str], /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: Optional[str], /) -> Self:
            """
            operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[str] = None
    """
    key is the label key that the selector applies to.
    """
    operator: Optional[str] = None
    """
    operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[str] = None
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, Any]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class To(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["To"]:
            return To

        def build(self) -> "To":
            return To(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[RefModel], /) -> "To.Builder": ...

        @overload
        def ref(
            self,
            value_or_callback: Callable[[RefModel.Builder], RefModel.Builder | RefModel],
            /,
        ) -> "To.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "RefModel.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref contains the direct reference to a target
            """
            if self._in_context and value_or_callback is None:
                context = RefModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RefModel.builder())
                if isinstance(output, RefModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "To.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "To.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector contains a selector to group targets
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["To.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = To.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for To."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["To", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use To.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[RefModel] = None
    """
    Ref contains the direct reference to a target
    """
    selector: Optional[Selector] = None
    """
    Selector contains a selector to group targets
    """


class Filter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Filter"]:
            return Filter

        def build(self) -> "Filter":
            return Filter(**self._attrs)

        def all(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            All evaluates to true if all the nested expressions evaluate to true. It must contain at least one filter expression
            """
            return self._set("all", value)

        def any(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            Any evaluates to true if any of the nested expressions evaluate to true. It must contain at least one filter expression
            """
            return self._set("any", value)

        def cesql(self, value: Optional[str], /) -> Self:
            """
            CESQL is a CloudEvents SQL v1 expression that will evaluate to true or false for each CloudEvent.
            """
            return self._set("cesql", value)

        def exact(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Exact evaluates to true if the values of the matching CloudEvents attributes all exactly match with the associated value string specified (case sensitive)
            """
            return self._set("exact", value)

        def not_(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Not evaluates to true if the nested expression evaluates to false.
            """
            return self._set("not_", value)

        def prefix(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Prefix evaluates to true if the values of the matching CloudEvents attributes all start with the associated value string specified (case sensitive)
            """
            return self._set("prefix", value)

        def suffix(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Exact evaluates to true if the values of the matching CloudEvents attributes all end with the associated value string specified (case sensitive)
            """
            return self._set("suffix", value)

    class BuilderContext(BuilderContextBase["Filter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Filter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Filter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Filter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Filter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[Dict[str, Any]]] = None
    """
    All evaluates to true if all the nested expressions evaluate to true. It must contain at least one filter expression
    """
    any: Optional[List[Dict[str, Any]]] = None
    """
    Any evaluates to true if any of the nested expressions evaluate to true. It must contain at least one filter expression
    """
    cesql: Optional[str] = None
    """
    CESQL is a CloudEvents SQL v1 expression that will evaluate to true or false for each CloudEvent.
    """
    exact: Optional[Dict[str, Any]] = None
    """
    Exact evaluates to true if the values of the matching CloudEvents attributes all exactly match with the associated value string specified (case sensitive)
    """
    not_: Annotated[Optional[Dict[str, Any]], Field(alias="not")] = None
    """
    Not evaluates to true if the nested expression evaluates to false.
    """
    prefix: Optional[Dict[str, Any]] = None
    """
    Prefix evaluates to true if the values of the matching CloudEvents attributes all start with the associated value string specified (case sensitive)
    """
    suffix: Optional[Dict[str, Any]] = None
    """
    Exact evaluates to true if the values of the matching CloudEvents attributes all end with the associated value string specified (case sensitive)
    """


class EventPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EventPolicySpec"]:
            return EventPolicySpec

        def build(self) -> "EventPolicySpec":
            return EventPolicySpec(**self._attrs)

        @overload
        def from_(self, value_or_callback: List[From], /) -> "EventPolicySpec.Builder": ...

        @overload
        def from_(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[From, From.Builder]],
                GenericListBuilder[From, From.Builder] | List[From],
            ],
            /,
        ) -> "EventPolicySpec.Builder": ...

        @overload
        def from_(self, value_or_callback: Never = ...) -> ListBuilderContext[From.Builder]: ...

        def from_(self, value_or_callback=None, /):
            """
            From is the list of sources or oidc identities, which are allowed to send events to the targets (.spec.to).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[From.Builder]()
                context._parent_builder = self
                context._field_name = "from_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(From.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("from_", value)

        @overload
        def to(self, value_or_callback: List[To], /) -> "EventPolicySpec.Builder": ...

        @overload
        def to(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[To, To.Builder]],
                GenericListBuilder[To, To.Builder] | List[To],
            ],
            /,
        ) -> "EventPolicySpec.Builder": ...

        @overload
        def to(self, value_or_callback: Never = ...) -> ListBuilderContext[To.Builder]: ...

        def to(self, value_or_callback=None, /):
            """
            To lists all resources for which this policy applies. Resources in this list must act like an ingress and have an audience. The resources are part of the same namespace as the EventPolicy. An empty list means it applies to all resources in the EventPolicies namespace
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[To.Builder]()
                context._parent_builder = self
                context._field_name = "to"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(To.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("to", value)

        @overload
        def filters(self, value_or_callback: List[Filter], /) -> "EventPolicySpec.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Filter, Filter.Builder]],
                GenericListBuilder[Filter, Filter.Builder] | List[Filter],
            ],
            /,
        ) -> "EventPolicySpec.Builder": ...

        @overload
        def filters(self, value_or_callback: Never = ...) -> ListBuilderContext[Filter.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Filters is an array of SubscriptionsAPIFilters that evaluate to true or false. If any filter expression in the array evaluates to false, the event will not continue pass the ingress of the target resources of the policy
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Filter.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

    class BuilderContext(BuilderContextBase["EventPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EventPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EventPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EventPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EventPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_: Annotated[Optional[List[From]], Field(alias="from")] = None
    """
    From is the list of sources or oidc identities, which are allowed to send events to the targets (.spec.to).
    """
    to: Optional[List[To]] = None
    """
    To lists all resources for which this policy applies. Resources in this list must act like an ingress and have an audience. The resources are part of the same namespace as the EventPolicy. An empty list means it applies to all resources in the EventPolicies namespace
    """
    filters: Optional[List[Filter]] = None
    """
    Filters is an array of SubscriptionsAPIFilters that evaluate to true or false. If any filter expression in the array evaluates to false, the event will not continue pass the ingress of the target resources of the policy
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class EventPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EventPolicyStatus"]:
            return EventPolicyStatus

        def build(self) -> "EventPolicyStatus":
            return EventPolicyStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "EventPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "EventPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def from_(self, value: Optional[List[str]], /) -> Self:
            """
            From is the list of resolved oidc identities from .spec.from
            """
            return self._set("from_", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["EventPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EventPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EventPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EventPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EventPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    from_: Annotated[Optional[List[str]], Field(alias="from")] = None
    """
    From is the list of resolved oidc identities from .spec.from
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class BrokerRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BrokerRef"]:
            return BrokerRef

        def build(self) -> "BrokerRef":
            return BrokerRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API Version of the broker.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the broker. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the broker. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["BrokerRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BrokerRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BrokerRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BrokerRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BrokerRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API Version of the broker.
    """
    kind: Optional[str] = None
    """
    Kind of the broker. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the broker. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class RefModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RefModel1"]:
            return RefModel1

        def build(self) -> "RefModel1":
            return RefModel1(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["RefModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RefModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RefModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RefModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RefModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class DeadLetterSink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterSink"]:
            return DeadLetterSink

        def build(self) -> "DeadLetterSink":
            return DeadLetterSink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[RefModel1], /) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(
            self,
            value_or_callback: Callable[[RefModel1.Builder], RefModel1.Builder | RefModel1],
            /,
        ) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "RefModel1.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = RefModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RefModel1.builder())
                if isinstance(output, RefModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["DeadLetterSink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterSink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterSink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterSink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterSink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[RefModel1] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Delivery(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Delivery"]:
            return Delivery

        def build(self) -> "Delivery":
            return Delivery(**self._attrs)

        def backoff_delay(self, value: Optional[str], /) -> Self:
            """
            BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
            """
            return self._set("backoff_delay", value)

        def backoff_policy(self, value: Optional[str], /) -> Self:
            """
            BackoffPolicy is the retry backoff policy (linear, exponential).
            """
            return self._set("backoff_policy", value)

        @overload
        def dead_letter_sink(
            self, value_or_callback: Optional[DeadLetterSink], /
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self,
            value_or_callback: Callable[
                [DeadLetterSink.Builder], DeadLetterSink.Builder | DeadLetterSink
            ],
            /,
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self, value_or_callback: Never = ...
        ) -> "DeadLetterSink.BuilderContext": ...

        def dead_letter_sink(self, value_or_callback=None, /):
            """
            DeadLetterSink is the sink receiving event that could not be sent to a destination.
            """
            if self._in_context and value_or_callback is None:
                context = DeadLetterSink.BuilderContext()
                context._parent_builder = self
                context._field_name = "dead_letter_sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeadLetterSink.builder())
                if isinstance(output, DeadLetterSink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dead_letter_sink", value)

        def retry(self, value: Optional[int], /) -> Self:
            """
            Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
            """
            return self._set("retry", value)

    class BuilderContext(BuilderContextBase["Delivery.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Delivery.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Delivery."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Delivery", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Delivery.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backoff_delay: Annotated[Optional[str], Field(alias="backoffDelay")] = None
    """
    BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
    """
    backoff_policy: Annotated[Optional[str], Field(alias="backoffPolicy")] = None
    """
    BackoffPolicy is the retry backoff policy (linear, exponential).
    """
    dead_letter_sink: Annotated[Optional[DeadLetterSink], Field(alias="deadLetterSink")] = None
    """
    DeadLetterSink is the sink receiving event that could not be sent to a destination.
    """
    retry: Optional[int] = None
    """
    Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
    """


class RequestReplySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestReplySpec"]:
            return RequestReplySpec

        def build(self) -> "RequestReplySpec":
            return RequestReplySpec(**self._attrs)

        @overload
        def broker_ref(
            self, value_or_callback: Optional[BrokerRef], /
        ) -> "RequestReplySpec.Builder": ...

        @overload
        def broker_ref(
            self,
            value_or_callback: Callable[[BrokerRef.Builder], BrokerRef.Builder | BrokerRef],
            /,
        ) -> "RequestReplySpec.Builder": ...

        @overload
        def broker_ref(self, value_or_callback: Never = ...) -> "BrokerRef.BuilderContext": ...

        def broker_ref(self, value_or_callback=None, /):
            """
            A KReference referring to the broker this RequestReply forwards events to. CrossNamespace references are not allowed.
            """
            if self._in_context and value_or_callback is None:
                context = BrokerRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "broker_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BrokerRef.builder())
                if isinstance(output, BrokerRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("broker_ref", value)

        def correlation_attribute(self, value: Optional[str], /) -> Self:
            """
            The name of the cloudevent attribute where the correlation id will be set on new events.
            """
            return self._set("correlation_attribute", value)

        def reply_attribute(self, value: Optional[str], /) -> Self:
            """
            The name of the cloudevents attribute which will hold the correlation id for an event which will be treated as a reply.
            """
            return self._set("reply_attribute", value)

        def secrets(self, value: Optional[List[str]], /) -> Self:
            """
            A list of the names of one or more secrets used to sign the correlation ids and reply ids. The secrets must be in the same namespace as the requestreply resource.
            """
            return self._set("secrets", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            A ISO8601 string representing how long RequestReply holds onto an incoming request before it times out without a reply.
            """
            return self._set("timeout", value)

        @overload
        def delivery(
            self, value_or_callback: Optional[Delivery], /
        ) -> "RequestReplySpec.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "RequestReplySpec.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            Delivery contains the delivery spec for each trigger to this Broker. Each trigger delivery spec, if any, overrides this global delivery spec.
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

    class BuilderContext(BuilderContextBase["RequestReplySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestReplySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestReplySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestReplySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestReplySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    broker_ref: Annotated[Optional[BrokerRef], Field(alias="brokerRef")] = None
    """
    A KReference referring to the broker this RequestReply forwards events to. CrossNamespace references are not allowed.
    """
    correlation_attribute: Annotated[Optional[str], Field(alias="correlationAttribute")] = None
    """
    The name of the cloudevent attribute where the correlation id will be set on new events.
    """
    reply_attribute: Annotated[Optional[str], Field(alias="replyAttribute")] = None
    """
    The name of the cloudevents attribute which will hold the correlation id for an event which will be treated as a reply.
    """
    secrets: Optional[List[str]] = None
    """
    A list of the names of one or more secrets used to sign the correlation ids and reply ids. The secrets must be in the same namespace as the requestreply resource.
    """
    timeout: Optional[str] = None
    """
    A ISO8601 string representing how long RequestReply holds onto an incoming request before it times out without a reply.
    """
    delivery: Optional[Delivery] = None
    """
    Delivery contains the delivery spec for each trigger to this Broker. Each trigger delivery spec, if any, overrides this global delivery spec.
    """


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    url: Optional[str] = None
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    audience: Optional[str] = None


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            The API version of the applied EventPolicy. This indicates whichversion of EventPolicy is supported by the resource.
            """
            return self._set("api_version", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the applied EventPolicy
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    The API version of the applied EventPolicy. This indicates whichversion of EventPolicy is supported by the resource.
    """
    name: Optional[str] = None
    """
    The name of the applied EventPolicy
    """


class RequestReplyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestReplyStatus"]:
            return RequestReplyStatus

        def build(self) -> "RequestReplyStatus":
            return RequestReplyStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def address(
            self, value_or_callback: Optional[Address], /
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            RequestReply is Addressable. It exposes the endpoint as an URI to get events delivered.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(
            self, value_or_callback: List[Address], /
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            RequestReply is Addressable. It exposes the endpoints as URIs to get events delivered.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        @overload
        def policies(self, value_or_callback: List[Policy], /) -> "RequestReplyStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "RequestReplyStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["RequestReplyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestReplyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestReplyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestReplyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestReplyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    address: Optional[Address] = None
    """
    RequestReply is Addressable. It exposes the endpoint as an URI to get events delivered.
    """
    addresses: Optional[List[Address]] = None
    """
    RequestReply is Addressable. It exposes the endpoints as URIs to get events delivered.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class EventPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EventPolicy"]:
            return EventPolicy

        def build(self) -> "EventPolicy":
            return EventPolicy(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[EventPolicySpec], /
        ) -> "EventPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [EventPolicySpec.Builder], EventPolicySpec.Builder | EventPolicySpec
            ],
            /,
        ) -> "EventPolicy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "EventPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = EventPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EventPolicySpec.builder())
                if isinstance(output, EventPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[EventPolicyStatus], /
        ) -> "EventPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [EventPolicyStatus.Builder],
                EventPolicyStatus.Builder | EventPolicyStatus,
            ],
            /,
        ) -> "EventPolicy.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "EventPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = EventPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EventPolicyStatus.builder())
                if isinstance(output, EventPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["eventing.knative.dev/v1alpha1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["EventPolicy"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "EventPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "EventPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["EventPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EventPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EventPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EventPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EventPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[EventPolicySpec] = None
    status: Optional[EventPolicyStatus] = None
    api_version: Annotated[
        Optional[Literal["eventing.knative.dev/v1alpha1"]], Field(alias="apiVersion")
    ] = "eventing.knative.dev/v1alpha1"
    kind: Optional[Literal["EventPolicy"]] = "EventPolicy"
    metadata: Optional[apimachinery.ObjectMeta] = None


class RequestReply(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestReply"]:
            return RequestReply

        def build(self) -> "RequestReply":
            return RequestReply(**self._attrs)

        @overload
        def spec(
            self, value_or_callback: Optional[RequestReplySpec], /
        ) -> "RequestReply.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [RequestReplySpec.Builder], RequestReplySpec.Builder | RequestReplySpec
            ],
            /,
        ) -> "RequestReply.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "RequestReplySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RequestReplySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestReplySpec.builder())
                if isinstance(output, RequestReplySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[RequestReplyStatus], /
        ) -> "RequestReply.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [RequestReplyStatus.Builder],
                RequestReplyStatus.Builder | RequestReplyStatus,
            ],
            /,
        ) -> "RequestReply.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "RequestReplyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RequestReplyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestReplyStatus.builder())
                if isinstance(output, RequestReplyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["eventing.knative.dev/v1alpha1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["RequestReply"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "RequestReply.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "RequestReply.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["RequestReply.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestReply.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestReply."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestReply", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestReply.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[RequestReplySpec] = None
    status: Optional[RequestReplyStatus] = None
    api_version: Annotated[
        Optional[Literal["eventing.knative.dev/v1alpha1"]], Field(alias="apiVersion")
    ] = "eventing.knative.dev/v1alpha1"
    kind: Optional[Literal["RequestReply"]] = "RequestReply"
    metadata: Optional[apimachinery.ObjectMeta] = None
