# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Config(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Config"]:
            return Config

        def build(self) -> "Config":
            return Config(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Config.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Config.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Config."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Config", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Config.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ This is optional field, it gets defaulted to the object holding it if left out.
    """


class DeadLetterSink(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeadLetterSink"]:
            return DeadLetterSink

        def build(self) -> "DeadLetterSink":
            return DeadLetterSink(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "DeadLetterSink.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["DeadLetterSink.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeadLetterSink.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeadLetterSink."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeadLetterSink", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeadLetterSink.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class Delivery(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Delivery"]:
            return Delivery

        def build(self) -> "Delivery":
            return Delivery(**self._attrs)

        def backoff_delay(self, value: Optional[str], /) -> Self:
            """
            BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
            """
            return self._set("backoff_delay", value)

        def backoff_policy(self, value: Optional[str], /) -> Self:
            """
            BackoffPolicy is the retry backoff policy (linear, exponential).
            """
            return self._set("backoff_policy", value)

        @overload
        def dead_letter_sink(
            self, value_or_callback: Optional[DeadLetterSink], /
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self,
            value_or_callback: Callable[
                [DeadLetterSink.Builder], DeadLetterSink.Builder | DeadLetterSink
            ],
            /,
        ) -> "Delivery.Builder": ...

        @overload
        def dead_letter_sink(
            self, value_or_callback: Never = ...
        ) -> "DeadLetterSink.BuilderContext": ...

        def dead_letter_sink(self, value_or_callback=None, /):
            """
            DeadLetterSink is the sink receiving event that could not be sent to a destination.
            """
            if self._in_context and value_or_callback is None:
                context = DeadLetterSink.BuilderContext()
                context._parent_builder = self
                context._field_name = "dead_letter_sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeadLetterSink.builder())
                if isinstance(output, DeadLetterSink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dead_letter_sink", value)

        def retry(self, value: Optional[int], /) -> Self:
            """
            Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
            """
            return self._set("retry", value)

    class BuilderContext(BuilderContextBase["Delivery.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Delivery.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Delivery."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Delivery", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Delivery.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backoff_delay: Annotated[Optional[str], Field(alias="backoffDelay")] = None
    """
    BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
    """
    backoff_policy: Annotated[Optional[str], Field(alias="backoffPolicy")] = None
    """
    BackoffPolicy is the retry backoff policy (linear, exponential).
    """
    dead_letter_sink: Annotated[Optional[DeadLetterSink], Field(alias="deadLetterSink")] = None
    """
    DeadLetterSink is the sink receiving event that could not be sent to a destination.
    """
    retry: Optional[int] = None
    """
    Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
    """


class BrokerSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BrokerSpec"]:
            return BrokerSpec

        def build(self) -> "BrokerSpec":
            return BrokerSpec(**self._attrs)

        @overload
        def config(self, value_or_callback: Optional[Config], /) -> "BrokerSpec.Builder": ...

        @overload
        def config(
            self,
            value_or_callback: Callable[[Config.Builder], Config.Builder | Config],
            /,
        ) -> "BrokerSpec.Builder": ...

        @overload
        def config(self, value_or_callback: Never = ...) -> "Config.BuilderContext": ...

        def config(self, value_or_callback=None, /):
            """
            Config is a KReference to the configuration that specifies configuration options for this Broker. For example, this could be a pointer to a ConfigMap.
            """
            if self._in_context and value_or_callback is None:
                context = Config.BuilderContext()
                context._parent_builder = self
                context._field_name = "config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Config.builder())
                if isinstance(output, Config.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config", value)

        @overload
        def delivery(self, value_or_callback: Optional[Delivery], /) -> "BrokerSpec.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[[Delivery.Builder], Delivery.Builder | Delivery],
            /,
        ) -> "BrokerSpec.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "Delivery.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            Delivery contains the delivery spec for each trigger to this Broker. Each trigger delivery spec, if any, overrides this global delivery spec.
            """
            if self._in_context and value_or_callback is None:
                context = Delivery.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Delivery.builder())
                if isinstance(output, Delivery.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

    class BuilderContext(BuilderContextBase["BrokerSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BrokerSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BrokerSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BrokerSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BrokerSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config: Optional[Config] = None
    """
    Config is a KReference to the configuration that specifies configuration options for this Broker. For example, this could be a pointer to a ConfigMap.
    """
    delivery: Optional[Delivery] = None
    """
    Delivery contains the delivery spec for each trigger to this Broker. Each trigger delivery spec, if any, overrides this global delivery spec.
    """


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    url: Optional[str] = None
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    audience: Optional[str] = None


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
            """
            return self._set("api_version", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            The name of the applied EventPolicy
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    The API version of the applied EventPolicy. This indicates, which version of EventPolicy is supported by the resource.
    """
    name: Optional[str] = None
    """
    The name of the applied EventPolicy
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another. We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition. When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class BrokerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BrokerStatus"]:
            return BrokerStatus

        def build(self) -> "BrokerStatus":
            return BrokerStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "BrokerStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "BrokerStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Broker is Addressable. It exposes the endpoint as an URI to get events delivered into the Broker mesh.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        @overload
        def addresses(self, value_or_callback: List[Address], /) -> "BrokerStatus.Builder": ...

        @overload
        def addresses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Address, Address.Builder]],
                GenericListBuilder[Address, Address.Builder] | List[Address],
            ],
            /,
        ) -> "BrokerStatus.Builder": ...

        @overload
        def addresses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Address.Builder]: ...

        def addresses(self, value_or_callback=None, /):
            """
            Broker is Addressable. It exposes the endpoints as URIs to get events delivered into the Broker mesh.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Address.Builder]()
                context._parent_builder = self
                context._field_name = "addresses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("addresses", value)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def policies(self, value_or_callback: List[Policy], /) -> "BrokerStatus.Builder": ...

        @overload
        def policies(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Policy, Policy.Builder]],
                GenericListBuilder[Policy, Policy.Builder] | List[Policy],
            ],
            /,
        ) -> "BrokerStatus.Builder": ...

        @overload
        def policies(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Policy.Builder]: ...

        def policies(self, value_or_callback=None, /):
            """
            List of applied EventPolicies
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Policy.Builder]()
                context._parent_builder = self
                context._field_name = "policies"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("policies", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "BrokerStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "BrokerStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def dead_letter_sink_uri(self, value: Optional[str], /) -> Self:
            """
            DeadLetterSinkURI is the resolved URI of the dead letter sink that will be used as a fallback when not specified by Triggers.
            """
            return self._set("dead_letter_sink_uri", value)

        def dead_letter_sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("dead_letter_sink_ca_certs", value)

        def dead_letter_sink_audience(self, value: Optional[str], /) -> Self:
            """
            OIDC audience of the dead letter sink.
            """
            return self._set("dead_letter_sink_audience", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["BrokerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BrokerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BrokerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BrokerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BrokerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Broker is Addressable. It exposes the endpoint as an URI to get events delivered into the Broker mesh.
    """
    addresses: Optional[List[Address]] = None
    """
    Broker is Addressable. It exposes the endpoints as URIs to get events delivered into the Broker mesh.
    """
    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    policies: Optional[List[Policy]] = None
    """
    List of applied EventPolicies
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    dead_letter_sink_uri: Annotated[Optional[str], Field(alias="deadLetterSinkUri")] = None
    """
    DeadLetterSinkURI is the resolved URI of the dead letter sink that will be used as a fallback when not specified by Triggers.
    """
    dead_letter_sink_ca_certs: Annotated[Optional[str], Field(alias="deadLetterSinkCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    dead_letter_sink_audience: Annotated[Optional[str], Field(alias="deadLetterSinkAudience")] = (
        None
    )
    """
    OIDC audience of the dead letter sink.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """


class BrokerRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BrokerRef"]:
            return BrokerRef

        def build(self) -> "BrokerRef":
            return BrokerRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["BrokerRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BrokerRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BrokerRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BrokerRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BrokerRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """


class DeliveryModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DeliveryModel"]:
            return DeliveryModel

        def build(self) -> "DeliveryModel":
            return DeliveryModel(**self._attrs)

        def backoff_delay(self, value: Optional[str], /) -> Self:
            """
            BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
            """
            return self._set("backoff_delay", value)

        def backoff_policy(self, value: Optional[str], /) -> Self:
            """
            BackoffPolicy is the retry backoff policy (linear, exponential).
            """
            return self._set("backoff_policy", value)

        @overload
        def dead_letter_sink(
            self, value_or_callback: Optional[DeadLetterSink], /
        ) -> "DeliveryModel.Builder": ...

        @overload
        def dead_letter_sink(
            self,
            value_or_callback: Callable[
                [DeadLetterSink.Builder], DeadLetterSink.Builder | DeadLetterSink
            ],
            /,
        ) -> "DeliveryModel.Builder": ...

        @overload
        def dead_letter_sink(
            self, value_or_callback: Never = ...
        ) -> "DeadLetterSink.BuilderContext": ...

        def dead_letter_sink(self, value_or_callback=None, /):
            """
            DeadLetterSink is the sink receiving event that could not be sent to a destination.
            """
            if self._in_context and value_or_callback is None:
                context = DeadLetterSink.BuilderContext()
                context._parent_builder = self
                context._field_name = "dead_letter_sink"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeadLetterSink.builder())
                if isinstance(output, DeadLetterSink.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dead_letter_sink", value)

        def retry(self, value: Optional[int], /) -> Self:
            """
            Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
            """
            return self._set("retry", value)

        def format(self, value: Optional[str], /) -> Self:
            """
            Format is the format used to serialize the event into a http request when delivering the event. It can be json (for structured events), binary (for binary events), or unset.
            """
            return self._set("format", value)

    class BuilderContext(BuilderContextBase["DeliveryModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DeliveryModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DeliveryModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DeliveryModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DeliveryModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    backoff_delay: Annotated[Optional[str], Field(alias="backoffDelay")] = None
    """
    BackoffDelay is the delay before retrying. More information on Duration format: - https://www.iso.org/iso-8601-date-and-time-format.html - https://en.wikipedia.org/wiki/ISO_8601  For linear policy, backoff delay is backoffDelay*<numberOfRetries>. For exponential policy, backoff delay is backoffDelay*2^<numberOfRetries>.
    """
    backoff_policy: Annotated[Optional[str], Field(alias="backoffPolicy")] = None
    """
    BackoffPolicy is the retry backoff policy (linear, exponential).
    """
    dead_letter_sink: Annotated[Optional[DeadLetterSink], Field(alias="deadLetterSink")] = None
    """
    DeadLetterSink is the sink receiving event that could not be sent to a destination.
    """
    retry: Optional[int] = None
    """
    Retry is the minimum number of retries the sender should attempt when sending an event before moving it to the dead letter sink.
    """
    format: Optional[str] = None
    """
    Format is the format used to serialize the event into a http request when delivering the event. It can be json (for structured events), binary (for binary events), or unset.
    """


class Filter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Filter"]:
            return Filter

        def build(self) -> "Filter":
            return Filter(**self._attrs)

        def attributes(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Attributes filters events by exact match on event context attributes. Each key in the map is compared with the equivalent key in the event context. An event passes the filter if all values are equal to the specified values.  Nested context attributes are not supported as keys. Only string values are supported.
            """
            return self._set("attributes", value)

    class BuilderContext(BuilderContextBase["Filter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Filter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Filter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Filter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Filter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attributes: Optional[Dict[str, Any]] = None
    """
    Attributes filters events by exact match on event context attributes. Each key in the map is compared with the equivalent key in the event context. An event passes the filter if all values are equal to the specified values.  Nested context attributes are not supported as keys. Only string values are supported.
    """


class FilterModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FilterModel"]:
            return FilterModel

        def build(self) -> "FilterModel":
            return FilterModel(**self._attrs)

        def all(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            All evaluates to true if all the nested expressions evaluate to true. It must contain at least one filter expression.
            """
            return self._set("all", value)

        def any(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            Any evaluates to true if at least one of the nested expressions evaluates to true. It must contain at least one filter expression.
            """
            return self._set("any", value)

        def cesql(self, value: Optional[str], /) -> Self:
            """
            CESQL is a CloudEvents SQL expression that will be evaluated to true or false against each CloudEvent.
            """
            return self._set("cesql", value)

        def exact(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Exact evaluates to true if the values of the matching CloudEvents attributes all exactly match with the associated value String specified (case-sensitive). The keys are the names of the CloudEvents attributes to be matched, and their values are the String values to use in the comparison. The attribute name and value specified in the filter express must not be empty strings.
            """
            return self._set("exact", value)

        def not_(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Not evaluates to true if the nested expression evaluates to false.
            """
            return self._set("not_", value)

        def prefix(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Prefix evaluates to true if the values of the matching CloudEvents attributes all start with the associated value String specified (case sensitive). The keys are the names of the CloudEvents attributes to be matched, and their values are the String values to use in the comparison. The attribute name and value specified in the filter express must not be empty strings.
            """
            return self._set("prefix", value)

        def suffix(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Suffix evaluates to true if the values of the matching CloudEvents attributes all end with the associated value String specified (case sensitive). The keys are the names of the CloudEvents attributes to be matched, and their values are the String values to use in the comparison. The attribute name and value specified in the filter express must not be empty strings.
            """
            return self._set("suffix", value)

    class BuilderContext(BuilderContextBase["FilterModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FilterModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FilterModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FilterModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FilterModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[Dict[str, Any]]] = None
    """
    All evaluates to true if all the nested expressions evaluate to true. It must contain at least one filter expression.
    """
    any: Optional[List[Dict[str, Any]]] = None
    """
    Any evaluates to true if at least one of the nested expressions evaluates to true. It must contain at least one filter expression.
    """
    cesql: Optional[str] = None
    """
    CESQL is a CloudEvents SQL expression that will be evaluated to true or false against each CloudEvent.
    """
    exact: Optional[Dict[str, Any]] = None
    """
    Exact evaluates to true if the values of the matching CloudEvents attributes all exactly match with the associated value String specified (case-sensitive). The keys are the names of the CloudEvents attributes to be matched, and their values are the String values to use in the comparison. The attribute name and value specified in the filter express must not be empty strings.
    """
    not_: Annotated[Optional[Dict[str, Any]], Field(alias="not")] = None
    """
    Not evaluates to true if the nested expression evaluates to false.
    """
    prefix: Optional[Dict[str, Any]] = None
    """
    Prefix evaluates to true if the values of the matching CloudEvents attributes all start with the associated value String specified (case sensitive). The keys are the names of the CloudEvents attributes to be matched, and their values are the String values to use in the comparison. The attribute name and value specified in the filter express must not be empty strings.
    """
    suffix: Optional[Dict[str, Any]] = None
    """
    Suffix evaluates to true if the values of the matching CloudEvents attributes all end with the associated value String specified (case sensitive). The keys are the names of the CloudEvents attributes to be matched, and their values are the String values to use in the comparison. The attribute name and value specified in the filter express must not be empty strings.
    """


class Subscriber(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subscriber"]:
            return Subscriber

        def build(self) -> "Subscriber":
            return Subscriber(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "Subscriber.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "Subscriber.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref points to an Addressable.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        def uri(self, value: Optional[str], /) -> Self:
            """
            URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
            """
            return self._set("uri", value)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
            """
            return self._set("audience", value)

    class BuilderContext(BuilderContextBase["Subscriber.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subscriber.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subscriber."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subscriber", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subscriber.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref points to an Addressable.
    """
    uri: Optional[str] = None
    """
    URI can be an absolute URL(non-empty scheme and non-empty host) pointing to the target or a relative URI. Relative URIs will be resolved using the base URI retrieved from Ref.
    """
    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format that the source trusts when sending events to the sink.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience. This only needs to be set if the target is not an Addressable and thus the Audience can't be received from the target itself. If specified, it takes precedence over the target's Audience.
    """


class TriggerSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TriggerSpec"]:
            return TriggerSpec

        def build(self) -> "TriggerSpec":
            return TriggerSpec(**self._attrs)

        def broker(self, value: Optional[str], /) -> Self:
            """
            Broker is the broker that this trigger receives events from.
            """
            return self._set("broker", value)

        @overload
        def broker_ref(
            self, value_or_callback: Optional[BrokerRef], /
        ) -> "TriggerSpec.Builder": ...

        @overload
        def broker_ref(
            self,
            value_or_callback: Callable[[BrokerRef.Builder], BrokerRef.Builder | BrokerRef],
            /,
        ) -> "TriggerSpec.Builder": ...

        @overload
        def broker_ref(self, value_or_callback: Never = ...) -> "BrokerRef.BuilderContext": ...

        def broker_ref(self, value_or_callback=None, /):
            """
            Reference to a broker that is enabled for cross-namespace referencing. You can specify only the following fields of the KReference: kind, apiVersion, name and namespace.
            """
            if self._in_context and value_or_callback is None:
                context = BrokerRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "broker_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BrokerRef.builder())
                if isinstance(output, BrokerRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("broker_ref", value)

        @overload
        def delivery(
            self, value_or_callback: Optional[DeliveryModel], /
        ) -> "TriggerSpec.Builder": ...

        @overload
        def delivery(
            self,
            value_or_callback: Callable[
                [DeliveryModel.Builder], DeliveryModel.Builder | DeliveryModel
            ],
            /,
        ) -> "TriggerSpec.Builder": ...

        @overload
        def delivery(self, value_or_callback: Never = ...) -> "DeliveryModel.BuilderContext": ...

        def delivery(self, value_or_callback=None, /):
            """
            Delivery contains the delivery spec for this specific trigger.
            """
            if self._in_context and value_or_callback is None:
                context = DeliveryModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "delivery"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DeliveryModel.builder())
                if isinstance(output, DeliveryModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("delivery", value)

        @overload
        def filter(self, value_or_callback: Optional[Filter], /) -> "TriggerSpec.Builder": ...

        @overload
        def filter(
            self,
            value_or_callback: Callable[[Filter.Builder], Filter.Builder | Filter],
            /,
        ) -> "TriggerSpec.Builder": ...

        @overload
        def filter(self, value_or_callback: Never = ...) -> "Filter.BuilderContext": ...

        def filter(self, value_or_callback=None, /):
            """
            Filter is the filter to apply against all events from the Broker. Only events that pass this filter will be sent to the Subscriber. If not specified, will default to allowing all events.
            """
            if self._in_context and value_or_callback is None:
                context = Filter.BuilderContext()
                context._parent_builder = self
                context._field_name = "filter"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Filter.builder())
                if isinstance(output, Filter.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("filter", value)

        @overload
        def filters(self, value_or_callback: List[FilterModel], /) -> "TriggerSpec.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[FilterModel, FilterModel.Builder]],
                GenericListBuilder[FilterModel, FilterModel.Builder] | List[FilterModel],
            ],
            /,
        ) -> "TriggerSpec.Builder": ...

        @overload
        def filters(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[FilterModel.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Filters is an array of SubscriptionsAPIFilter that evaluate to true or false. If any filter expression in the array evaluates to false, the event must not be sent to the Subscriber. If all the filter expressions in the array evaluate to true, the event must be attempted to be delivered. Absence of a filter or empty array implies a value of true. In the event of users specifying both Filter and Filters, then the latter will override the former. This will allow users to try out the effect of the new Filters field without compromising the existing attribute-based Filter and try it out on existing Trigger objects.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[FilterModel.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FilterModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

        @overload
        def subscriber(
            self, value_or_callback: Optional[Subscriber], /
        ) -> "TriggerSpec.Builder": ...

        @overload
        def subscriber(
            self,
            value_or_callback: Callable[[Subscriber.Builder], Subscriber.Builder | Subscriber],
            /,
        ) -> "TriggerSpec.Builder": ...

        @overload
        def subscriber(self, value_or_callback: Never = ...) -> "Subscriber.BuilderContext": ...

        def subscriber(self, value_or_callback=None, /):
            """
            Subscriber is the addressable that receives events from the Broker that pass the Filter. It is required.
            """
            if self._in_context and value_or_callback is None:
                context = Subscriber.BuilderContext()
                context._parent_builder = self
                context._field_name = "subscriber"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subscriber.builder())
                if isinstance(output, Subscriber.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subscriber", value)

    class BuilderContext(BuilderContextBase["TriggerSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TriggerSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TriggerSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TriggerSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TriggerSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    broker: Optional[str] = None
    """
    Broker is the broker that this trigger receives events from.
    """
    broker_ref: Annotated[Optional[BrokerRef], Field(alias="brokerRef")] = None
    """
    Reference to a broker that is enabled for cross-namespace referencing. You can specify only the following fields of the KReference: kind, apiVersion, name and namespace.
    """
    delivery: Optional[DeliveryModel] = None
    """
    Delivery contains the delivery spec for this specific trigger.
    """
    filter: Optional[Filter] = None
    """
    Filter is the filter to apply against all events from the Broker. Only events that pass this filter will be sent to the Subscriber. If not specified, will default to allowing all events.
    """
    filters: Optional[List[FilterModel]] = None
    """
    Filters is an array of SubscriptionsAPIFilter that evaluate to true or false. If any filter expression in the array evaluates to false, the event must not be sent to the Subscriber. If all the filter expressions in the array evaluate to true, the event must be attempted to be delivered. Absence of a filter or empty array implies a value of true. In the event of users specifying both Filter and Filters, then the latter will override the former. This will allow users to try out the effect of the new Filters field without compromising the existing attribute-based Filter and try it out on existing Trigger objects.
    """
    subscriber: Optional[Subscriber] = None
    """
    Subscriber is the addressable that receives events from the Broker that pass the Filter. It is required.
    """


class Auth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Auth"]:
            return Auth

        def build(self) -> "Auth":
            return Auth(**self._attrs)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
            """
            return self._set("service_account_name", value)

        def service_account_names(self, value: Optional[List[str]], /) -> Self:
            """
            ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
            """
            return self._set("service_account_names", value)

    class BuilderContext(BuilderContextBase["Auth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Auth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Auth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Auth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Auth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the generated service account used for this components OIDC authentication.
    """
    service_account_names: Annotated[Optional[List[str]], Field(alias="serviceAccountNames")] = None
    """
    ServiceAccountNames is the list of names of the generated service accounts used for this components OIDC authentication.
    """


class TriggerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TriggerStatus"]:
            return TriggerStatus

        def build(self) -> "TriggerStatus":
            return TriggerStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def auth(self, value_or_callback: Optional[Auth], /) -> "TriggerStatus.Builder": ...

        @overload
        def auth(
            self, value_or_callback: Callable[[Auth.Builder], Auth.Builder | Auth], /
        ) -> "TriggerStatus.Builder": ...

        @overload
        def auth(self, value_or_callback: Never = ...) -> "Auth.BuilderContext": ...

        def auth(self, value_or_callback=None, /):
            """
            Auth provides the relevant information for OIDC authentication.
            """
            if self._in_context and value_or_callback is None:
                context = Auth.BuilderContext()
                context._parent_builder = self
                context._field_name = "auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Auth.builder())
                if isinstance(output, Auth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("auth", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "TriggerStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "TriggerStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def dead_letter_sink_uri(self, value: Optional[str], /) -> Self:
            """
            DeadLetterSinkURI is the resolved URI of the dead letter sink for this Trigger, in case there is none this will fallback to it's Broker status DeadLetterSinkURI.
            """
            return self._set("dead_letter_sink_uri", value)

        def dead_letter_sink_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("dead_letter_sink_ca_certs", value)

        def dead_letter_sink_audience(self, value: Optional[str], /) -> Self:
            """
            OIDC audience of the dead letter sink.
            """
            return self._set("dead_letter_sink_audience", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def subscriber_uri(self, value: Optional[str], /) -> Self:
            """
            SubscriberURI is the resolved URI of the receiver for this Trigger.
            """
            return self._set("subscriber_uri", value)

        def subscriber_ca_certs(self, value: Optional[str], /) -> Self:
            """
            Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("subscriber_ca_certs", value)

        def subscriber_audience(self, value: Optional[str], /) -> Self:
            """
            OIDC audience of the subscriber.
            """
            return self._set("subscriber_audience", value)

    class BuilderContext(BuilderContextBase["TriggerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TriggerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TriggerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TriggerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TriggerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, Any]] = None
    """
    Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.
    """
    auth: Optional[Auth] = None
    """
    Auth provides the relevant information for OIDC authentication.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    dead_letter_sink_uri: Annotated[Optional[str], Field(alias="deadLetterSinkUri")] = None
    """
    DeadLetterSinkURI is the resolved URI of the dead letter sink for this Trigger, in case there is none this will fallback to it's Broker status DeadLetterSinkURI.
    """
    dead_letter_sink_ca_certs: Annotated[Optional[str], Field(alias="deadLetterSinkCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    dead_letter_sink_audience: Annotated[Optional[str], Field(alias="deadLetterSinkAudience")] = (
        None
    )
    """
    OIDC audience of the dead letter sink.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.
    """
    subscriber_uri: Annotated[Optional[str], Field(alias="subscriberUri")] = None
    """
    SubscriberURI is the resolved URI of the receiver for this Trigger.
    """
    subscriber_ca_certs: Annotated[Optional[str], Field(alias="subscriberCACerts")] = None
    """
    Certification Authority (CA) certificates in PEM format according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    subscriber_audience: Annotated[Optional[str], Field(alias="subscriberAudience")] = None
    """
    OIDC audience of the subscriber.
    """


class Broker(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Broker"]:
            return Broker

        def build(self) -> "Broker":
            return Broker(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[BrokerSpec], /) -> "Broker.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[BrokerSpec.Builder], BrokerSpec.Builder | BrokerSpec],
            /,
        ) -> "Broker.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "BrokerSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BrokerSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BrokerSpec.builder())
                if isinstance(output, BrokerSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[BrokerStatus], /) -> "Broker.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [BrokerStatus.Builder], BrokerStatus.Builder | BrokerStatus
            ],
            /,
        ) -> "Broker.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "BrokerStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BrokerStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BrokerStatus.builder())
                if isinstance(output, BrokerStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["eventing.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Broker"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Broker.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Broker.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Broker.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Broker.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Broker."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Broker", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Broker.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[BrokerSpec] = None
    status: Optional[BrokerStatus] = None
    api_version: Annotated[
        Optional[Literal["eventing.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "eventing.knative.dev/v1"
    kind: Optional[Literal["Broker"]] = "Broker"
    metadata: Optional[apimachinery.ObjectMeta] = None


class Trigger(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Trigger"]:
            return Trigger

        def build(self) -> "Trigger":
            return Trigger(**self._attrs)

        @overload
        def spec(self, value_or_callback: Optional[TriggerSpec], /) -> "Trigger.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[TriggerSpec.Builder], TriggerSpec.Builder | TriggerSpec],
            /,
        ) -> "Trigger.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TriggerSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TriggerSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TriggerSpec.builder())
                if isinstance(output, TriggerSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[TriggerStatus], /) -> "Trigger.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [TriggerStatus.Builder], TriggerStatus.Builder | TriggerStatus
            ],
            /,
        ) -> "Trigger.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "TriggerStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TriggerStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TriggerStatus.builder())
                if isinstance(output, TriggerStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def api_version(self, value: Optional[Literal["eventing.knative.dev/v1"]], /) -> Self:
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Trigger"]], /) -> Self:
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Trigger.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Trigger.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

    class BuilderContext(BuilderContextBase["Trigger.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Trigger.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Trigger."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Trigger", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Trigger.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    spec: Optional[TriggerSpec] = None
    status: Optional[TriggerStatus] = None
    api_version: Annotated[
        Optional[Literal["eventing.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "eventing.knative.dev/v1"
    kind: Optional[Literal["Trigger"]] = "Trigger"
    metadata: Optional[apimachinery.ObjectMeta] = None
