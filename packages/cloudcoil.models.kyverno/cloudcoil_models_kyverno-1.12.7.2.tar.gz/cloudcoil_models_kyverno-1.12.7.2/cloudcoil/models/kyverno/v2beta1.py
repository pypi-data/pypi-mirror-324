# Generated by cloudcoil-model-codegen v0.4.7
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class All(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["All"]:
            return All

        def build(self) -> "All":
            return All(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["All.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = All.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for All."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["All", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use All.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel"]:
            return AnyModel

        def build(self) -> "AnyModel":
            return AnyModel(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class Conditions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Conditions"]:
            return Conditions

        def build(self) -> "Conditions":
            return Conditions(**self._attrs)

        @overload
        def all(self, value_or_callback: List[All], /) -> "Conditions.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[All, All.Builder]],
                GenericListBuilder[All, All.Builder] | List[All],
            ],
            /,
        ) -> "Conditions.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[All.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[All.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(All.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel], /) -> "Conditions.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel, AnyModel.Builder]],
                GenericListBuilder[AnyModel, AnyModel.Builder] | List[AnyModel],
            ],
            /,
        ) -> "Conditions.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Conditions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Conditions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Conditions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Conditions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Conditions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[All]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass.
    """
    any: Optional[List[AnyModel]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass.
    """


class Datum(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Datum"]:
            return Datum

        def build(self) -> "Datum":
            return Datum(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            Key is a unique identifier for the data value
            """
            return self._set("key", value)

        def value(self, value: Any, /) -> Self:
            """
            Value is the data value
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Datum.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Datum.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Datum."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Datum", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Datum.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    Key is a unique identifier for the data value
    """
    value: Any
    """
    Value is the data value
    """


class Service(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

        def ca_bundle(self, value: Optional[str], /) -> Self:
            """
            CABundle is a PEM encoded CA bundle which will be used to validate
            the server certificate.
            """
            return self._set("ca_bundle", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the JSON web service URL. A typical form is
            `https://{service}.{namespace}:{port}/{path}`.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_bundle: Annotated[Optional[str], Field(alias="caBundle")] = None
    """
    CABundle is a PEM encoded CA bundle which will be used to validate
    the server certificate.
    """
    url: str
    """
    URL is the JSON web service URL. A typical form is
    `https://{service}.{namespace}:{port}/{path}`.
    """


class ApiCall(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiCall"]:
            return ApiCall

        def build(self) -> "ApiCall":
            return ApiCall(**self._attrs)

        @overload
        def data(self, value_or_callback: List[Datum], /) -> "ApiCall.Builder": ...

        @overload
        def data(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Datum, Datum.Builder]],
                GenericListBuilder[Datum, Datum.Builder] | List[Datum],
            ],
            /,
        ) -> "ApiCall.Builder": ...

        @overload
        def data(self, value_or_callback: Never = ...) -> ListBuilderContext[Datum.Builder]: ...

        def data(self, value_or_callback=None, /):
            """
            The data object specifies the POST data sent to the server.
            Only applicable when the method field is set to POST.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Datum.Builder]()
                context._parent_builder = self
                context._field_name = "data"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Datum.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("data", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JSON Match Expression that can be used to
            transform the JSON response returned from the server. For example
            a JMESPath of "items | length(@)" applied to the API server response
            for the URLPath "/apis/apps/v1/deployments" will return the total count
            of deployments across all namespaces.
            """
            return self._set("jmes_path", value)

        def method(self, value: Optional[Literal["GET", "POST"]], /) -> Self:
            """
            Method is the HTTP request type (GET or POST).
            """
            return self._set("method", value)

        @overload
        def service(self, value_or_callback: Optional[Service], /) -> "ApiCall.Builder": ...

        @overload
        def service(
            self,
            value_or_callback: Callable[[Service.Builder], Service.Builder | Service],
            /,
        ) -> "ApiCall.Builder": ...

        @overload
        def service(self, value_or_callback: Never = ...) -> "Service.BuilderContext": ...

        def service(self, value_or_callback=None, /):
            """
            Service is an API call to a JSON web service.
            This is used for non-Kubernetes API server calls.
            It's mutually exclusive with the URLPath field.
            """
            if self._in_context and value_or_callback is None:
                context = Service.BuilderContext()
                context._parent_builder = self
                context._field_name = "service"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Service.builder())
                if isinstance(output, Service.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service", value)

        def url_path(self, value: Optional[str], /) -> Self:
            """
            URLPath is the URL path to be used in the HTTP GET or POST request to the
            Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
            The format required is the same format used by the `kubectl get --raw` command.
            See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
            for details.
            It's mutually exclusive with the Service field.
            """
            return self._set("url_path", value)

    class BuilderContext(BuilderContextBase["ApiCall.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiCall.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiCall."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiCall", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiCall.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[List[Datum]] = None
    """
    The data object specifies the POST data sent to the server.
    Only applicable when the method field is set to POST.
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JSON Match Expression that can be used to
    transform the JSON response returned from the server. For example
    a JMESPath of "items | length(@)" applied to the API server response
    for the URLPath "/apis/apps/v1/deployments" will return the total count
    of deployments across all namespaces.
    """
    method: Optional[Literal["GET", "POST"]] = "GET"
    """
    Method is the HTTP request type (GET or POST).
    """
    service: Optional[Service] = None
    """
    Service is an API call to a JSON web service.
    This is used for non-Kubernetes API server calls.
    It's mutually exclusive with the URLPath field.
    """
    url_path: Annotated[Optional[str], Field(alias="urlPath")] = None
    """
    URLPath is the URL path to be used in the HTTP GET or POST request to the
    Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
    The format required is the same format used by the `kubectl get --raw` command.
    See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
    for details.
    It's mutually exclusive with the Service field.
    """


class ConfigMap(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMap"]:
            return ConfigMap

        def build(self) -> "ConfigMap":
            return ConfigMap(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is the ConfigMap name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace is the ConfigMap namespace.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ConfigMap.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMap.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMap."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMap", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMap.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name is the ConfigMap name.
    """
    namespace: Optional[str] = None
    """
    Namespace is the ConfigMap namespace.
    """


class GlobalReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GlobalReference"]:
            return GlobalReference

        def build(self) -> "GlobalReference":
            return GlobalReference(**self._attrs)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JSON Match Expression that can be used to
            transform the JSON response returned from the server. For example
            a JMESPath of "items | length(@)" applied to the API server response
            for the URLPath "/apis/apps/v1/deployments" will return the total count
            of deployments across all namespaces.
            """
            return self._set("jmes_path", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the global context entry
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["GlobalReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GlobalReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GlobalReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GlobalReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GlobalReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JSON Match Expression that can be used to
    transform the JSON response returned from the server. For example
    a JMESPath of "items | length(@)" applied to the API server response
    for the URLPath "/apis/apps/v1/deployments" will return the total count
    of deployments across all namespaces.
    """
    name: Optional[str] = None
    """
    Name of the global context entry
    """


class ImageRegistryCredentials(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRegistryCredentials"]:
            return ImageRegistryCredentials

        def build(self) -> "ImageRegistryCredentials":
            return ImageRegistryCredentials(**self._attrs)

        def allow_insecure_registry(self, value: Optional[bool], /) -> Self:
            """
            AllowInsecureRegistry allows insecure access to a registry.
            """
            return self._set("allow_insecure_registry", value)

        def providers(
            self,
            value: Optional[List[Literal["default", "amazon", "azure", "google", "github"]]],
            /,
        ) -> Self:
            """
            Providers specifies a list of OCI Registry names, whose authentication providers are provided.
            It can be of one of these values: default,google,azure,amazon,github.
            """
            return self._set("providers", value)

        def secrets(self, value: Optional[List[str]], /) -> Self:
            """
            Secrets specifies a list of secrets that are provided for credentials.
            Secrets must live in the Kyverno namespace.
            """
            return self._set("secrets", value)

    class BuilderContext(BuilderContextBase["ImageRegistryCredentials.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRegistryCredentials.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRegistryCredentials."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRegistryCredentials", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRegistryCredentials.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_insecure_registry: Annotated[Optional[bool], Field(alias="allowInsecureRegistry")] = None
    """
    AllowInsecureRegistry allows insecure access to a registry.
    """
    providers: Optional[List[Literal["default", "amazon", "azure", "google", "github"]]] = None
    """
    Providers specifies a list of OCI Registry names, whose authentication providers are provided.
    It can be of one of these values: default,google,azure,amazon,github.
    """
    secrets: Optional[List[str]] = None
    """
    Secrets specifies a list of secrets that are provided for credentials.
    Secrets must live in the Kyverno namespace.
    """


class ImageRegistry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRegistry"]:
            return ImageRegistry

        def build(self) -> "ImageRegistry":
            return ImageRegistry(**self._attrs)

        @overload
        def image_registry_credentials(
            self, value_or_callback: Optional[ImageRegistryCredentials], /
        ) -> "ImageRegistry.Builder": ...

        @overload
        def image_registry_credentials(
            self,
            value_or_callback: Callable[
                [ImageRegistryCredentials.Builder],
                ImageRegistryCredentials.Builder | ImageRegistryCredentials,
            ],
            /,
        ) -> "ImageRegistry.Builder": ...

        @overload
        def image_registry_credentials(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistryCredentials.BuilderContext": ...

        def image_registry_credentials(self, value_or_callback=None, /):
            """
            ImageRegistryCredentials provides credentials that will be used for authentication with registry
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistryCredentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry_credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistryCredentials.builder())
                if isinstance(output, ImageRegistryCredentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry_credentials", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JSON Match Expression that can be used to
            transform the ImageData struct returned as a result of processing
            the image reference.
            """
            return self._set("jmes_path", value)

        def reference(self, value: str, /) -> Self:
            """
            Reference is image reference to a container image in the registry.
            Example: ghcr.io/kyverno/kyverno:latest
            """
            return self._set("reference", value)

    class BuilderContext(BuilderContextBase["ImageRegistry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRegistry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRegistry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRegistry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRegistry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials], Field(alias="imageRegistryCredentials")
    ] = None
    """
    ImageRegistryCredentials provides credentials that will be used for authentication with registry
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JSON Match Expression that can be used to
    transform the ImageData struct returned as a result of processing
    the image reference.
    """
    reference: str
    """
    Reference is image reference to a container image in the registry.
    Example: ghcr.io/kyverno/kyverno:latest
    """


class Variable(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Variable"]:
            return Variable

        def build(self) -> "Variable":
            return Variable(**self._attrs)

        def default(self, value: Optional[Any], /) -> Self:
            """
            Default is an optional arbitrary JSON object that the variable may take if the JMESPath
            expression evaluates to nil
            """
            return self._set("default", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath Expression that can be used to
            transform the variable.
            """
            return self._set("jmes_path", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is any arbitrary JSON object representable in YAML or JSON form.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Variable.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Variable.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Variable."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Variable", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Variable.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default: Optional[Any] = None
    """
    Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    expression evaluates to nil
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath Expression that can be used to
    transform the variable.
    """
    value: Optional[Any] = None
    """
    Value is any arbitrary JSON object representable in YAML or JSON form.
    """


class Context(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Context"]:
            return Context

        def build(self) -> "Context":
            return Context(**self._attrs)

        @overload
        def api_call(self, value_or_callback: Optional[ApiCall], /) -> "Context.Builder": ...

        @overload
        def api_call(
            self,
            value_or_callback: Callable[[ApiCall.Builder], ApiCall.Builder | ApiCall],
            /,
        ) -> "Context.Builder": ...

        @overload
        def api_call(self, value_or_callback: Never = ...) -> "ApiCall.BuilderContext": ...

        def api_call(self, value_or_callback=None, /):
            """
            APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
            The data returned is stored in the context with the name for the context entry.
            """
            if self._in_context and value_or_callback is None:
                context = ApiCall.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_call"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiCall.builder())
                if isinstance(output, ApiCall.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_call", value)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Context.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Context.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap is the ConfigMap reference.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def global_reference(
            self, value_or_callback: Optional[GlobalReference], /
        ) -> "Context.Builder": ...

        @overload
        def global_reference(
            self,
            value_or_callback: Callable[
                [GlobalReference.Builder], GlobalReference.Builder | GlobalReference
            ],
            /,
        ) -> "Context.Builder": ...

        @overload
        def global_reference(
            self, value_or_callback: Never = ...
        ) -> "GlobalReference.BuilderContext": ...

        def global_reference(self, value_or_callback=None, /):
            """
            GlobalContextEntryReference is a reference to a cached global context entry.
            """
            if self._in_context and value_or_callback is None:
                context = GlobalReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "global_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GlobalReference.builder())
                if isinstance(output, GlobalReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("global_reference", value)

        @overload
        def image_registry(
            self, value_or_callback: Optional[ImageRegistry], /
        ) -> "Context.Builder": ...

        @overload
        def image_registry(
            self,
            value_or_callback: Callable[
                [ImageRegistry.Builder], ImageRegistry.Builder | ImageRegistry
            ],
            /,
        ) -> "Context.Builder": ...

        @overload
        def image_registry(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistry.BuilderContext": ...

        def image_registry(self, value_or_callback=None, /):
            """
            ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
            details.
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistry.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistry.builder())
                if isinstance(output, ImageRegistry.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the variable name.
            """
            return self._set("name", value)

        @overload
        def variable(self, value_or_callback: Optional[Variable], /) -> "Context.Builder": ...

        @overload
        def variable(
            self,
            value_or_callback: Callable[[Variable.Builder], Variable.Builder | Variable],
            /,
        ) -> "Context.Builder": ...

        @overload
        def variable(self, value_or_callback: Never = ...) -> "Variable.BuilderContext": ...

        def variable(self, value_or_callback=None, /):
            """
            Variable defines an arbitrary JMESPath context variable that can be defined inline.
            """
            if self._in_context and value_or_callback is None:
                context = Variable.BuilderContext()
                context._parent_builder = self
                context._field_name = "variable"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Variable.builder())
                if isinstance(output, Variable.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("variable", value)

    class BuilderContext(BuilderContextBase["Context.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Context.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Context."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Context", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Context.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_call: Annotated[Optional[ApiCall], Field(alias="apiCall")] = None
    """
    APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
    The data returned is stored in the context with the name for the context entry.
    """
    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap is the ConfigMap reference.
    """
    global_reference: Annotated[Optional[GlobalReference], Field(alias="globalReference")] = None
    """
    GlobalContextEntryReference is a reference to a cached global context entry.
    """
    image_registry: Annotated[Optional[ImageRegistry], Field(alias="imageRegistry")] = None
    """
    ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
    details.
    """
    name: Optional[str] = None
    """
    Name is the variable name.
    """
    variable: Optional[Variable] = None
    """
    Variable defines an arbitrary JMESPath context variable that can be defined inline.
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Resources(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Resources"]:
            return Resources

        def build(self) -> "Resources":
            return Resources(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
            and values support the wildcard characters "*" (matches zero or many characters) and
            "?" (matches at least one character).
            """
            return self._set("annotations", value)

        def kinds(self, value: Optional[List[str]], /) -> Self:
            """
            Kinds is a list of resource kinds.
            """
            return self._set("kinds", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the name of the resource. The name supports wildcard characters
            "*" (matches zero or many characters) and "?" (at least one character).
            NOTE: "Name" is being deprecated in favor of "Names".
            """
            return self._set("name", value)

        def names(self, value: Optional[List[str]], /) -> Self:
            """
            Names are the names of the resources. Each name supports wildcard characters
            "*" (matches zero or many characters) and "?" (at least one character).
            """
            return self._set("names", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "Resources.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            NamespaceSelector is a label selector for the resource namespace. Label keys and values
            in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
            and `?` (matches one character).Wildcards allows writing label selectors like
            ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
            does not match an empty label set.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            Namespaces is a list of namespaces names. Each name supports wildcard characters
            "*" (matches zero or many characters) and "?" (at least one character).
            """
            return self._set("namespaces", value)

        def operations(
            self,
            value: Optional[List[Literal["CREATE", "CONNECT", "UPDATE", "DELETE"]]],
            /,
        ) -> Self:
            """
            Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
            """
            return self._set("operations", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "Resources.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
            characters `*` (matches zero or many characters) and `?` (matches one character).
            Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
            using ["*" : "*"] matches any key and value but does not match an empty label set.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["Resources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Resources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Resources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Resources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Resources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
    and values support the wildcard characters "*" (matches zero or many characters) and
    "?" (matches at least one character).
    """
    kinds: Optional[List[str]] = None
    """
    Kinds is a list of resource kinds.
    """
    name: Optional[str] = None
    """
    Name is the name of the resource. The name supports wildcard characters
    "*" (matches zero or many characters) and "?" (at least one character).
    NOTE: "Name" is being deprecated in favor of "Names".
    """
    names: Optional[List[str]] = None
    """
    Names are the names of the resources. Each name supports wildcard characters
    "*" (matches zero or many characters) and "?" (at least one character).
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    NamespaceSelector is a label selector for the resource namespace. Label keys and values
    in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
    and `?` (matches one character).Wildcards allows writing label selectors like
    ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
    does not match an empty label set.
    """
    namespaces: Optional[List[str]] = None
    """
    Namespaces is a list of namespaces names. Each name supports wildcard characters
    "*" (matches zero or many characters) and "?" (at least one character).
    """
    operations: Optional[List[Literal["CREATE", "CONNECT", "UPDATE", "DELETE"]]] = None
    """
    Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    """
    selector: Optional[Selector] = None
    """
    Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
    characters `*` (matches zero or many characters) and `?` (matches one character).
    Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
    using ["*" : "*"] matches any key and value but does not match an empty label set.
    """


class Subject(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subject"]:
            return Subject

        def build(self) -> "Subject":
            return Subject(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup holds the API group of the referenced subject.
            Defaults to "" for ServiceAccount subjects.
            Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
            If the Authorizer does not recognized the kind value, the Authorizer should report an error.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the object being referenced.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
            the Authorizer should report an error.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Subject.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subject.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subject."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subject", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subject.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup holds the API group of the referenced subject.
    Defaults to "" for ServiceAccount subjects.
    Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    """
    kind: str
    """
    Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
    If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    """
    name: str
    """
    Name of the object being referenced.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
    the Authorizer should report an error.
    """


class AllModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel"]:
            return AllModel

        def build(self) -> "AllModel":
            return AllModel(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel1"]:
            return AnyModel1

        def build(self) -> "AnyModel1":
            return AnyModel1(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel1.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel1.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel1.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel1.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class Exclude(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exclude"]:
            return Exclude

        def build(self) -> "Exclude":
            return Exclude(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel], /) -> "Exclude.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel, AllModel.Builder]],
                GenericListBuilder[AllModel, AllModel.Builder] | List[AllModel],
            ],
            /,
        ) -> "Exclude.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel1], /) -> "Exclude.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel1, AnyModel1.Builder]],
                GenericListBuilder[AnyModel1, AnyModel1.Builder] | List[AnyModel1],
            ],
            /,
        ) -> "Exclude.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel1.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel1.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Exclude.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exclude.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exclude."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exclude", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exclude.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel1]] = None
    """
    Any allows specifying resources which will be ORed
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel], /) -> "Match.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel, AllModel.Builder]],
                GenericListBuilder[AllModel, AllModel.Builder] | List[AllModel],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel1], /) -> "Match.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel1, AnyModel1.Builder]],
                GenericListBuilder[AnyModel1, AnyModel1.Builder] | List[AnyModel1],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel1.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel1.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel1]] = None
    """
    Any allows specifying resources which will be ORed
    """


class CleanupPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CleanupPolicySpec"]:
            return CleanupPolicySpec

        def build(self) -> "CleanupPolicySpec":
            return CleanupPolicySpec(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions defines the conditions used to select the resources which will be cleaned up.
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "CleanupPolicySpec.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(
            self, value_or_callback: Optional[Exclude], /
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[[Exclude.Builder], Exclude.Builder | Exclude],
            /,
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "Exclude.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when cleanuppolicy should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = Exclude.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exclude.builder())
                if isinstance(output, Exclude.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def match(self, value_or_callback: Optional[Match], /) -> "CleanupPolicySpec.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when cleanuppolicy should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        def schedule(self, value: str, /) -> Self:
            """
            The schedule in Cron format
            """
            return self._set("schedule", value)

    class BuilderContext(BuilderContextBase["CleanupPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CleanupPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CleanupPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CleanupPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CleanupPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Conditions] = None
    """
    Conditions defines the conditions used to select the resources which will be cleaned up.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[Exclude] = None
    """
    ExcludeResources defines when cleanuppolicy should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    match: Optional[Match] = None
    """
    MatchResources defines when cleanuppolicy should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    schedule: str
    """
    The schedule in Cron format
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            ---
            Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
            useful (see .node.status.conditions), the ability to deconflict is important.
            The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    ---
    Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
    useful (see .node.status.conditions), the ability to deconflict is important.
    The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    """


class CleanupPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CleanupPolicyStatus"]:
            return CleanupPolicyStatus

        def build(self) -> "CleanupPolicyStatus":
            return CleanupPolicyStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_execution_time(self, value: Optional[datetime], /) -> Self:
            return self._set("last_execution_time", value)

    class BuilderContext(BuilderContextBase["CleanupPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CleanupPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CleanupPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CleanupPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CleanupPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_execution_time: Annotated[Optional[datetime], Field(alias="lastExecutionTime")] = None


class AllModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel1"]:
            return AllModel1

        def build(self) -> "AllModel1":
            return AllModel1(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel2"]:
            return AnyModel2

        def build(self) -> "AnyModel2":
            return AnyModel2(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AllModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel2"]:
            return AllModel2

        def build(self) -> "AllModel2":
            return AllModel2(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel2.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel2.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel2.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel2.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel3"]:
            return AnyModel3

        def build(self) -> "AnyModel3":
            return AnyModel3(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel3.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel3.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel3.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel3.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class ClusterCleanupPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCleanupPolicySpec"]:
            return ClusterCleanupPolicySpec

        def build(self) -> "ClusterCleanupPolicySpec":
            return ClusterCleanupPolicySpec(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions defines the conditions used to select the resources which will be cleaned up.
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def context(
            self, value_or_callback: List[Context], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(
            self, value_or_callback: Optional[Exclude], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[[Exclude.Builder], Exclude.Builder | Exclude],
            /,
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "Exclude.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when cleanuppolicy should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = Exclude.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exclude.builder())
                if isinstance(output, Exclude.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def match(
            self, value_or_callback: Optional[Match], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when cleanuppolicy should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        def schedule(self, value: str, /) -> Self:
            """
            The schedule in Cron format
            """
            return self._set("schedule", value)

    class BuilderContext(BuilderContextBase["ClusterCleanupPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCleanupPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCleanupPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCleanupPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCleanupPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Conditions] = None
    """
    Conditions defines the conditions used to select the resources which will be cleaned up.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[Exclude] = None
    """
    ExcludeResources defines when cleanuppolicy should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    match: Optional[Match] = None
    """
    MatchResources defines when cleanuppolicy should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    schedule: str
    """
    The schedule in Cron format
    """


class ClusterCleanupPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCleanupPolicyStatus"]:
            return ClusterCleanupPolicyStatus

        def build(self) -> "ClusterCleanupPolicyStatus":
            return ClusterCleanupPolicyStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ClusterCleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ClusterCleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_execution_time(self, value: Optional[datetime], /) -> Self:
            return self._set("last_execution_time", value)

    class BuilderContext(BuilderContextBase["ClusterCleanupPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCleanupPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCleanupPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCleanupPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCleanupPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_execution_time: Annotated[Optional[datetime], Field(alias="lastExecutionTime")] = None


class CelPrecondition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CelPrecondition"]:
            return CelPrecondition

        def build(self) -> "CelPrecondition":
            return CelPrecondition(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
            CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:


            'object' - The object from the incoming request. The value is null for DELETE requests.
            'oldObject' - The existing object. The value is null for CREATE requests.
            'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
            'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
              See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
            'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
              request resource.
            Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/


            Required.
            """
            return self._set("expression", value)

        def name(self, value: str, /) -> Self:
            """
            Name is an identifier for this match condition, used for strategic merging of MatchConditions,
            as well as providing an identifier for logging purposes. A good name should be descriptive of
            the associated expression.
            Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
            must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
            '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
            optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')


            Required.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["CelPrecondition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CelPrecondition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CelPrecondition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CelPrecondition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CelPrecondition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
    CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:


    'object' - The object from the incoming request. The value is null for DELETE requests.
    'oldObject' - The existing object. The value is null for CREATE requests.
    'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
    'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
      See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
    'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
      request resource.
    Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/


    Required.
    """
    name: str
    """
    Name is an identifier for this match condition, used for strategic merging of MatchConditions,
    as well as providing an identifier for logging purposes. A good name should be descriptive of
    the associated expression.
    Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
    must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
    '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
    optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')


    Required.
    """


class Clone(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Clone"]:
            return Clone

        def build(self) -> "Clone":
            return Clone(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies name of the resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies source resource namespace.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Clone.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Clone.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Clone."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Clone", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Clone.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    Name specifies name of the resource.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies source resource namespace.
    """


class CloneList(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CloneList"]:
            return CloneList

        def build(self) -> "CloneList":
            return CloneList(**self._attrs)

        def kinds(self, value: Optional[List[str]], /) -> Self:
            """
            Kinds is a list of resource kinds.
            """
            return self._set("kinds", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies source resource namespace.
            """
            return self._set("namespace", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "CloneList.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "CloneList.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector is a label selector. Label keys and values in `matchLabels`.
            wildcard characters are not supported.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["CloneList.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CloneList.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CloneList."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CloneList", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CloneList.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kinds: Optional[List[str]] = None
    """
    Kinds is a list of resource kinds.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies source resource namespace.
    """
    selector: Optional[Selector] = None
    """
    Selector is a label selector. Label keys and values in `matchLabels`.
    wildcard characters are not supported.
    """


class Generate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Generate"]:
            return Generate

        def build(self) -> "Generate":
            return Generate(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion specifies resource apiVersion.
            """
            return self._set("api_version", value)

        @overload
        def clone(self, value_or_callback: Optional[Clone], /) -> "Generate.Builder": ...

        @overload
        def clone(
            self, value_or_callback: Callable[[Clone.Builder], Clone.Builder | Clone], /
        ) -> "Generate.Builder": ...

        @overload
        def clone(self, value_or_callback: Never = ...) -> "Clone.BuilderContext": ...

        def clone(self, value_or_callback=None, /):
            """
            Clone specifies the source resource used to populate each generated resource.
            At most one of Data or Clone can be specified. If neither are provided, the generated
            resource will be created with default data only.
            """
            if self._in_context and value_or_callback is None:
                context = Clone.BuilderContext()
                context._parent_builder = self
                context._field_name = "clone"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Clone.builder())
                if isinstance(output, Clone.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("clone", value)

        @overload
        def clone_list(self, value_or_callback: Optional[CloneList], /) -> "Generate.Builder": ...

        @overload
        def clone_list(
            self,
            value_or_callback: Callable[[CloneList.Builder], CloneList.Builder | CloneList],
            /,
        ) -> "Generate.Builder": ...

        @overload
        def clone_list(self, value_or_callback: Never = ...) -> "CloneList.BuilderContext": ...

        def clone_list(self, value_or_callback=None, /):
            """
            CloneList specifies the list of source resource used to populate each generated resource.
            """
            if self._in_context and value_or_callback is None:
                context = CloneList.BuilderContext()
                context._parent_builder = self
                context._field_name = "clone_list"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CloneList.builder())
                if isinstance(output, CloneList.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("clone_list", value)

        def data(self, value: Optional[Any], /) -> Self:
            """
            Data provides the resource declaration used to populate each generated resource.
            At most one of Data or Clone must be specified. If neither are provided, the generated
            resource will be created with default data only.
            """
            return self._set("data", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind specifies resource kind.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the resource name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies resource namespace.
            """
            return self._set("namespace", value)

        def orphan_downstream_on_policy_delete(self, value: Optional[bool], /) -> Self:
            """
            OrphanDownstreamOnPolicyDelete controls whether generated resources should be deleted when the rule that generated
            them is deleted with synchronization enabled. This option is only applicable to generate rules of the data type.
            See https://kyverno.io/docs/writing-policies/generate/#data-examples.
            Defaults to "false" if not specified.
            """
            return self._set("orphan_downstream_on_policy_delete", value)

        def synchronize(self, value: Optional[bool], /) -> Self:
            """
            Synchronize controls if generated resources should be kept in-sync with their source resource.
            If Synchronize is set to "true" changes to generated resources will be overwritten with resource
            data from Data or the resource specified in the Clone declaration.
            Optional. Defaults to "false" if not specified.
            """
            return self._set("synchronize", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID specifies the resource uid.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Generate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Generate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Generate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Generate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Generate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion specifies resource apiVersion.
    """
    clone: Optional[Clone] = None
    """
    Clone specifies the source resource used to populate each generated resource.
    At most one of Data or Clone can be specified. If neither are provided, the generated
    resource will be created with default data only.
    """
    clone_list: Annotated[Optional[CloneList], Field(alias="cloneList")] = None
    """
    CloneList specifies the list of source resource used to populate each generated resource.
    """
    data: Optional[Any] = None
    """
    Data provides the resource declaration used to populate each generated resource.
    At most one of Data or Clone must be specified. If neither are provided, the generated
    resource will be created with default data only.
    """
    kind: Optional[str] = None
    """
    Kind specifies resource kind.
    """
    name: Optional[str] = None
    """
    Name specifies the resource name.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies resource namespace.
    """
    orphan_downstream_on_policy_delete: Annotated[
        Optional[bool], Field(alias="orphanDownstreamOnPolicyDelete")
    ] = None
    """
    OrphanDownstreamOnPolicyDelete controls whether generated resources should be deleted when the rule that generated
    them is deleted with synchronization enabled. This option is only applicable to generate rules of the data type.
    See https://kyverno.io/docs/writing-policies/generate/#data-examples.
    Defaults to "false" if not specified.
    """
    synchronize: Optional[bool] = None
    """
    Synchronize controls if generated resources should be kept in-sync with their source resource.
    If Synchronize is set to "true" changes to generated resources will be overwritten with resource
    data from Data or the resource specified in the Clone declaration.
    Optional. Defaults to "false" if not specified.
    """
    uid: Optional[str] = None
    """
    UID specifies the resource uid.
    """


class ImageExtractor(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageExtractor"]:
            return ImageExtractor

        def build(self) -> "ImageExtractor":
            return ImageExtractor(**self._attrs)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath expression to apply to the image value.
            This is useful when the extracted image begins with a prefix like 'docker://'.
            The 'trim_prefix' function may be used to trim the prefix: trim_prefix(@, 'docker://').
            Note - Image digest mutation may not be used when applying a JMESPAth to an image.
            """
            return self._set("jmes_path", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            Key is an optional name of the field within 'path' that will be used to uniquely identify an image.
            Note - this field MUST be unique.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the entry the image will be available under 'images.<name>' in the context.
            If this field is not defined, image entries will appear under 'images.custom'.
            """
            return self._set("name", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the path to the object containing the image field in a custom resource.
            It should be slash-separated. Each slash-separated key must be a valid YAML key or a wildcard '*'.
            Wildcard keys are expanded in case of arrays or objects.
            """
            return self._set("path", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value is an optional name of the field within 'path' that points to the image URI.
            This is useful when a custom 'key' is also defined.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["ImageExtractor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageExtractor.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageExtractor."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageExtractor", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageExtractor.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath expression to apply to the image value.
    This is useful when the extracted image begins with a prefix like 'docker://'.
    The 'trim_prefix' function may be used to trim the prefix: trim_prefix(@, 'docker://').
    Note - Image digest mutation may not be used when applying a JMESPAth to an image.
    """
    key: Optional[str] = None
    """
    Key is an optional name of the field within 'path' that will be used to uniquely identify an image.
    Note - this field MUST be unique.
    """
    name: Optional[str] = None
    """
    Name is the entry the image will be available under 'images.<name>' in the context.
    If this field is not defined, image entries will appear under 'images.custom'.
    """
    path: str
    """
    Path is the path to the object containing the image field in a custom resource.
    It should be slash-separated. Each slash-separated key must be a valid YAML key or a wildcard '*'.
    Wildcard keys are expanded in case of arrays or objects.
    """
    value: Optional[str] = None
    """
    Value is an optional name of the field within 'path' that points to the image URI.
    This is useful when a custom 'key' is also defined.
    """


class AllModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel3"]:
            return AllModel3

        def build(self) -> "AllModel3":
            return AllModel3(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel4"]:
            return AnyModel4

        def build(self) -> "AnyModel4":
            return AnyModel4(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class Preconditions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Preconditions"]:
            return Preconditions

        def build(self) -> "Preconditions":
            return Preconditions(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel3], /) -> "Preconditions.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel3, AllModel3.Builder]],
                GenericListBuilder[AllModel3, AllModel3.Builder] | List[AllModel3],
            ],
            /,
        ) -> "Preconditions.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel3.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel3.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel4], /) -> "Preconditions.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel4, AnyModel4.Builder]],
                GenericListBuilder[AnyModel4, AnyModel4.Builder] | List[AnyModel4],
            ],
            /,
        ) -> "Preconditions.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel4.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel4.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel4.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Preconditions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Preconditions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Preconditions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Preconditions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Preconditions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel3]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass
    """
    any: Optional[List[AnyModel4]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass
    """


class Foreach(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Foreach"]:
            return Foreach

        def build(self) -> "Foreach":
            return Foreach(**self._attrs)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "Foreach.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "Foreach.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def order(self, value: Optional[Literal["Ascending", "Descending"]], /) -> Self:
            """
            Order defines the iteration order on the list.
            Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
            """
            return self._set("order", value)

        def patch_strategic_merge(self, value: Optional[Any], /) -> Self:
            """
            PatchStrategicMerge is a strategic merge patch used to modify resources.
            See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
            and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
            """
            return self._set("patch_strategic_merge", value)

        def patches_json6902(self, value: Optional[str], /) -> Self:
            """
            PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
            See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
            """
            return self._set("patches_json6902", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[Preconditions], /
        ) -> "Foreach.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [Preconditions.Builder], Preconditions.Builder | Preconditions
            ],
            /,
        ) -> "Foreach.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "Preconditions.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = Preconditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Preconditions.builder())
                if isinstance(output, Preconditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["Foreach.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Foreach.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Foreach."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Foreach", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Foreach.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    order: Optional[Literal["Ascending", "Descending"]] = None
    """
    Order defines the iteration order on the list.
    Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
    """
    patch_strategic_merge: Annotated[Optional[Any], Field(alias="patchStrategicMerge")] = None
    """
    PatchStrategicMerge is a strategic merge patch used to modify resources.
    See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
    and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
    """
    patches_json6902: Annotated[Optional[str], Field(alias="patchesJson6902")] = None
    """
    PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
    See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
    """
    preconditions: Optional[Preconditions] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class Target(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Target"]:
            return Target

        def build(self) -> "Target":
            return Target(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion specifies resource apiVersion.
            """
            return self._set("api_version", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "Target.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "Target.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind specifies resource kind.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the resource name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies resource namespace.
            """
            return self._set("namespace", value)

        def preconditions(self, value: Optional[Any], /) -> Self:
            """
            Preconditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
            of conditions (without `any` or `all` statements is supported for backwards compatibility but
            will be deprecated in the next major release.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            return self._set("preconditions", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID specifies the resource uid.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Target.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Target.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Target."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Target", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Target.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion specifies resource apiVersion.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    kind: Optional[str] = None
    """
    Kind specifies resource kind.
    """
    name: Optional[str] = None
    """
    Name specifies the resource name.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies resource namespace.
    """
    preconditions: Optional[Any] = None
    """
    Preconditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
    of conditions (without `any` or `all` statements is supported for backwards compatibility but
    will be deprecated in the next major release.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """
    uid: Optional[str] = None
    """
    UID specifies the resource uid.
    """


class Mutate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Mutate"]:
            return Mutate

        def build(self) -> "Mutate":
            return Mutate(**self._attrs)

        @overload
        def foreach(self, value_or_callback: List[Foreach], /) -> "Mutate.Builder": ...

        @overload
        def foreach(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Foreach, Foreach.Builder]],
                GenericListBuilder[Foreach, Foreach.Builder] | List[Foreach],
            ],
            /,
        ) -> "Mutate.Builder": ...

        @overload
        def foreach(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Foreach.Builder]: ...

        def foreach(self, value_or_callback=None, /):
            """
            ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Foreach.Builder]()
                context._parent_builder = self
                context._field_name = "foreach"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Foreach.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("foreach", value)

        def patch_strategic_merge(self, value: Optional[Any], /) -> Self:
            """
            PatchStrategicMerge is a strategic merge patch used to modify resources.
            See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
            and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
            """
            return self._set("patch_strategic_merge", value)

        def patches_json6902(self, value: Optional[str], /) -> Self:
            """
            PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
            See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
            """
            return self._set("patches_json6902", value)

        @overload
        def targets(self, value_or_callback: List[Target], /) -> "Mutate.Builder": ...

        @overload
        def targets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Target, Target.Builder]],
                GenericListBuilder[Target, Target.Builder] | List[Target],
            ],
            /,
        ) -> "Mutate.Builder": ...

        @overload
        def targets(self, value_or_callback: Never = ...) -> ListBuilderContext[Target.Builder]: ...

        def targets(self, value_or_callback=None, /):
            """
            Targets defines the target resources to be mutated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Target.Builder]()
                context._parent_builder = self
                context._field_name = "targets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Target.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("targets", value)

    class BuilderContext(BuilderContextBase["Mutate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Mutate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Mutate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Mutate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Mutate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    foreach: Optional[List[Foreach]] = None
    """
    ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
    """
    patch_strategic_merge: Annotated[Optional[Any], Field(alias="patchStrategicMerge")] = None
    """
    PatchStrategicMerge is a strategic merge patch used to modify resources.
    See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
    and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
    """
    patches_json6902: Annotated[Optional[str], Field(alias="patchesJson6902")] = None
    """
    PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
    See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
    """
    targets: Optional[List[Target]] = None
    """
    Targets defines the target resources to be mutated.
    """


class AllModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel4"]:
            return AllModel4

        def build(self) -> "AllModel4":
            return AllModel4(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel5"]:
            return AnyModel5

        def build(self) -> "AnyModel5":
            return AnyModel5(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class PreconditionsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreconditionsModel"]:
            return PreconditionsModel

        def build(self) -> "PreconditionsModel":
            return PreconditionsModel(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel4], /) -> "PreconditionsModel.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel4, AllModel4.Builder]],
                GenericListBuilder[AllModel4, AllModel4.Builder] | List[AllModel4],
            ],
            /,
        ) -> "PreconditionsModel.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel4.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel4.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel4.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel5], /) -> "PreconditionsModel.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel5, AnyModel5.Builder]],
                GenericListBuilder[AnyModel5, AnyModel5.Builder] | List[AnyModel5],
            ],
            /,
        ) -> "PreconditionsModel.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel5.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel5.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel5.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["PreconditionsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PreconditionsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreconditionsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PreconditionsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreconditionsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel4]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass.
    """
    any: Optional[List[AnyModel5]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass.
    """


class AuditAnnotation(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AuditAnnotation"]:
            return AuditAnnotation

        def build(self) -> "AuditAnnotation":
            return AuditAnnotation(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key specifies the audit annotation key. The audit annotation keys of
            a ValidatingAdmissionPolicy must be unique. The key must be a qualified
            name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.


            The key is combined with the resource name of the
            ValidatingAdmissionPolicy to construct an audit annotation key:
            "{ValidatingAdmissionPolicy name}/{key}".


            If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
            and the same audit annotation key, the annotation key will be identical.
            In this case, the first annotation written with the key will be included
            in the audit event and all subsequent annotations with the same key
            will be discarded.


            Required.
            """
            return self._set("key", value)

        def value_expression(self, value: str, /) -> Self:
            """
            valueExpression represents the expression which is evaluated by CEL to
            produce an audit annotation value. The expression must evaluate to either
            a string or null value. If the expression evaluates to a string, the
            audit annotation is included with the string value. If the expression
            evaluates to null or empty string the audit annotation will be omitted.
            The valueExpression may be no longer than 5kb in length.
            If the result of the valueExpression is more than 10kb in length, it
            will be truncated to 10kb.


            If multiple ValidatingAdmissionPolicyBinding resources match an
            API request, then the valueExpression will be evaluated for
            each binding. All unique values produced by the valueExpressions
            will be joined together in a comma-separated list.


            Required.
            """
            return self._set("value_expression", value)

    class BuilderContext(BuilderContextBase["AuditAnnotation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AuditAnnotation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AuditAnnotation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AuditAnnotation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AuditAnnotation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key specifies the audit annotation key. The audit annotation keys of
    a ValidatingAdmissionPolicy must be unique. The key must be a qualified
    name ([A-Za-z0-9][-A-Za-z0-9_.]*) no more than 63 bytes in length.


    The key is combined with the resource name of the
    ValidatingAdmissionPolicy to construct an audit annotation key:
    "{ValidatingAdmissionPolicy name}/{key}".


    If an admission webhook uses the same resource name as this ValidatingAdmissionPolicy
    and the same audit annotation key, the annotation key will be identical.
    In this case, the first annotation written with the key will be included
    in the audit event and all subsequent annotations with the same key
    will be discarded.


    Required.
    """
    value_expression: Annotated[str, Field(alias="valueExpression")]
    """
    valueExpression represents the expression which is evaluated by CEL to
    produce an audit annotation value. The expression must evaluate to either
    a string or null value. If the expression evaluates to a string, the
    audit annotation is included with the string value. If the expression
    evaluates to null or empty string the audit annotation will be omitted.
    The valueExpression may be no longer than 5kb in length.
    If the result of the valueExpression is more than 10kb in length, it
    will be truncated to 10kb.


    If multiple ValidatingAdmissionPolicyBinding resources match an
    API request, then the valueExpression will be evaluated for
    each binding. All unique values produced by the valueExpressions
    will be joined together in a comma-separated list.


    Required.
    """


class Expression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Expression"]:
            return Expression

        def build(self) -> "Expression":
            return Expression(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression represents the expression which will be evaluated by CEL.
            ref: https://github.com/google/cel-spec
            CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:


            - 'object' - The object from the incoming request. The value is null for DELETE requests.
            - 'oldObject' - The existing object. The value is null for CREATE requests.
            - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
            - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
            - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
            - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
              For example, a variable named 'foo' can be accessed as 'variables.foo'.
            - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
              See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
            - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
              request resource.


            The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
            object. No other metadata properties are accessible.


            Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
            Accessible property names are escaped according to the following rules when accessed in the expression:
            - '__' escapes to '__underscores__'
            - '.' escapes to '__dot__'
            - '-' escapes to '__dash__'
            - '/' escapes to '__slash__'
            - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
                  "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
                  "import", "let", "loop", "package", "namespace", "return".
            Examples:
              - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
              - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
              - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}


            Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
            Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
              - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
                non-intersecting elements in `Y` are appended, retaining their partial order.
              - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
                are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
                non-intersecting keys are appended, retaining their partial order.
            Required.
            """
            return self._set("expression", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message represents the message displayed when validation fails. The message is required if the Expression contains
            line breaks. The message must not contain line breaks.
            If unset, the message is "failed rule: {Rule}".
            e.g. "must be a URL with the host matching spec.host"
            If the Expression contains line breaks. Message is required.
            The message must not contain line breaks.
            If unset, the message is "failed Expression: {Expression}".
            """
            return self._set("message", value)

        def message_expression(self, value: Optional[str], /) -> Self:
            """
            messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
            Since messageExpression is used as a failure message, it must evaluate to a string.
            If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
            If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
            as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
            that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
            the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
            messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
            Example:
            "object.x must be less than max ("+string(params.max)+")"
            """
            return self._set("message_expression", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            Reason represents a machine-readable description of why this validation failed.
            If this is the first validation in the list to fail, this reason, as well as the
            corresponding HTTP response code, are used in the
            HTTP response to the client.
            The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
            If not set, StatusReasonInvalid is used in the response to the client.
            """
            return self._set("reason", value)

    class BuilderContext(BuilderContextBase["Expression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Expression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Expression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Expression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Expression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression represents the expression which will be evaluated by CEL.
    ref: https://github.com/google/cel-spec
    CEL expressions have access to the contents of the API request/response, organized into CEL variables as well as some other useful variables:


    - 'object' - The object from the incoming request. The value is null for DELETE requests.
    - 'oldObject' - The existing object. The value is null for CREATE requests.
    - 'request' - Attributes of the API request([ref](/pkg/apis/admission/types.go#AdmissionRequest)).
    - 'params' - Parameter resource referred to by the policy binding being evaluated. Only populated if the policy has a ParamKind.
    - 'namespaceObject' - The namespace object that the incoming object belongs to. The value is null for cluster-scoped resources.
    - 'variables' - Map of composited variables, from its name to its lazily evaluated value.
      For example, a variable named 'foo' can be accessed as 'variables.foo'.
    - 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
      See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
    - 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
      request resource.


    The `apiVersion`, `kind`, `metadata.name` and `metadata.generateName` are always accessible from the root of the
    object. No other metadata properties are accessible.


    Only property names of the form `[a-zA-Z_.-/][a-zA-Z0-9_.-/]*` are accessible.
    Accessible property names are escaped according to the following rules when accessed in the expression:
    - '__' escapes to '__underscores__'
    - '.' escapes to '__dot__'
    - '-' escapes to '__dash__'
    - '/' escapes to '__slash__'
    - Property names that exactly match a CEL RESERVED keyword escape to '__{keyword}__'. The keywords are:
          "true", "false", "null", "in", "as", "break", "const", "continue", "else", "for", "function", "if",
          "import", "let", "loop", "package", "namespace", "return".
    Examples:
      - Expression accessing a property named "namespace": {"Expression": "object.__namespace__ > 0"}
      - Expression accessing a property named "x-prop": {"Expression": "object.x__dash__prop > 0"}
      - Expression accessing a property named "redact__d": {"Expression": "object.redact__underscores__d > 0"}


    Equality on arrays with list type of 'set' or 'map' ignores element order, i.e. [1, 2] == [2, 1].
    Concatenation on arrays with x-kubernetes-list-type use the semantics of the list type:
      - 'set': `X + Y` performs a union where the array positions of all elements in `X` are preserved and
        non-intersecting elements in `Y` are appended, retaining their partial order.
      - 'map': `X + Y` performs a merge where the array positions of all keys in `X` are preserved but the values
        are overwritten by values in `Y` when the key sets of `X` and `Y` intersect. Elements in `Y` with
        non-intersecting keys are appended, retaining their partial order.
    Required.
    """
    message: Optional[str] = None
    """
    Message represents the message displayed when validation fails. The message is required if the Expression contains
    line breaks. The message must not contain line breaks.
    If unset, the message is "failed rule: {Rule}".
    e.g. "must be a URL with the host matching spec.host"
    If the Expression contains line breaks. Message is required.
    The message must not contain line breaks.
    If unset, the message is "failed Expression: {Expression}".
    """
    message_expression: Annotated[Optional[str], Field(alias="messageExpression")] = None
    """
    messageExpression declares a CEL expression that evaluates to the validation failure message that is returned when this rule fails.
    Since messageExpression is used as a failure message, it must evaluate to a string.
    If both message and messageExpression are present on a validation, then messageExpression will be used if validation fails.
    If messageExpression results in a runtime error, the runtime error is logged, and the validation failure message is produced
    as if the messageExpression field were unset. If messageExpression evaluates to an empty string, a string with only spaces, or a string
    that contains line breaks, then the validation failure message will also be produced as if the messageExpression field were unset, and
    the fact that messageExpression produced an empty string/string with only spaces/string with line breaks will be logged.
    messageExpression has access to all the same variables as the `expression` except for 'authorizer' and 'authorizer.requestResource'.
    Example:
    "object.x must be less than max ("+string(params.max)+")"
    """
    reason: Optional[str] = None
    """
    Reason represents a machine-readable description of why this validation failed.
    If this is the first validation in the list to fail, this reason, as well as the
    corresponding HTTP response code, are used in the
    HTTP response to the client.
    The currently supported reasons are: "Unauthorized", "Forbidden", "Invalid", "RequestEntityTooLarge".
    If not set, StatusReasonInvalid is used in the response to the client.
    """


class ParamKind(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ParamKind"]:
            return ParamKind

        def build(self) -> "ParamKind":
            return ParamKind(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion is the API group version the resources belong to.
            In format of "group/version".
            Required.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind is the API kind the resources belong to.
            Required.
            """
            return self._set("kind", value)

    class BuilderContext(BuilderContextBase["ParamKind.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ParamKind.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ParamKind."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ParamKind", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ParamKind.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion is the API group version the resources belong to.
    In format of "group/version".
    Required.
    """
    kind: Optional[str] = None
    """
    Kind is the API kind the resources belong to.
    Required.
    """


class ParamRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ParamRef"]:
            return ParamRef

        def build(self) -> "ParamRef":
            return ParamRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            `name` is the name of the resource being referenced.


            `name` and `selector` are mutually exclusive properties. If one is set,
            the other must be unset.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            namespace is the namespace of the referenced resource. Allows limiting
            the search for params to a specific namespace. Applies to both `name` and
            `selector` fields.


            A per-namespace parameter may be used by specifying a namespace-scoped
            `paramKind` in the policy and leaving this field empty.


            - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
            field results in a configuration error.


            - If `paramKind` is namespace-scoped, the namespace of the object being
            evaluated for admission will be used when this field is left unset. Take
            care that if this is left empty the binding must not match any cluster-scoped
            resources, which will result in an error.
            """
            return self._set("namespace", value)

        def parameter_not_found_action(self, value: Optional[str], /) -> Self:
            """
            `parameterNotFoundAction` controls the behavior of the binding when the resource
            exists, and name or selector is valid, but there are no parameters
            matched by the binding. If the value is set to `Allow`, then no
            matched parameters will be treated as successful validation by the binding.
            If set to `Deny`, then no matched parameters will be subject to the
            `failurePolicy` of the policy.


            Allowed values are `Allow` or `Deny`
            Default to `Deny`
            """
            return self._set("parameter_not_found_action", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "ParamRef.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "ParamRef.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            selector can be used to match multiple param objects based on their labels.
            Supply selector: {} to match all resources of the ParamKind.


            If multiple params are found, they are all evaluated with the policy expressions
            and the results are ANDed together.


            One of `name` or `selector` must be set, but `name` and `selector` are
            mutually exclusive properties. If one is set, the other must be unset.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["ParamRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ParamRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ParamRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ParamRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ParamRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    `name` is the name of the resource being referenced.


    `name` and `selector` are mutually exclusive properties. If one is set,
    the other must be unset.
    """
    namespace: Optional[str] = None
    """
    namespace is the namespace of the referenced resource. Allows limiting
    the search for params to a specific namespace. Applies to both `name` and
    `selector` fields.


    A per-namespace parameter may be used by specifying a namespace-scoped
    `paramKind` in the policy and leaving this field empty.


    - If `paramKind` is cluster-scoped, this field MUST be unset. Setting this
    field results in a configuration error.


    - If `paramKind` is namespace-scoped, the namespace of the object being
    evaluated for admission will be used when this field is left unset. Take
    care that if this is left empty the binding must not match any cluster-scoped
    resources, which will result in an error.
    """
    parameter_not_found_action: Annotated[Optional[str], Field(alias="parameterNotFoundAction")] = (
        None
    )
    """
    `parameterNotFoundAction` controls the behavior of the binding when the resource
    exists, and name or selector is valid, but there are no parameters
    matched by the binding. If the value is set to `Allow`, then no
    matched parameters will be treated as successful validation by the binding.
    If set to `Deny`, then no matched parameters will be subject to the
    `failurePolicy` of the policy.


    Allowed values are `Allow` or `Deny`
    Default to `Deny`
    """
    selector: Optional[Selector] = None
    """
    selector can be used to match multiple param objects based on their labels.
    Supply selector: {} to match all resources of the ParamKind.


    If multiple params are found, they are all evaluated with the policy expressions
    and the results are ANDed together.


    One of `name` or `selector` must be set, but `name` and `selector` are
    mutually exclusive properties. If one is set, the other must be unset.
    """


class VariableModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel"]:
            return VariableModel

        def build(self) -> "VariableModel":
            return VariableModel(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression is the expression that will be evaluated as the value of the variable.
            The CEL expression has access to the same identifiers as the CEL expressions in Validation.
            """
            return self._set("expression", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
            The variable can be accessed in other expressions through `variables`
            For example, if name is "foo", the variable will be available as `variables.foo`
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["VariableModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression is the expression that will be evaluated as the value of the variable.
    The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    """
    name: str
    """
    Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    The variable can be accessed in other expressions through `variables`
    For example, if name is "foo", the variable will be available as `variables.foo`
    """


class Cel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cel"]:
            return Cel

        def build(self) -> "Cel":
            return Cel(**self._attrs)

        @overload
        def audit_annotations(
            self, value_or_callback: List[AuditAnnotation], /
        ) -> "Cel.Builder": ...

        @overload
        def audit_annotations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AuditAnnotation, AuditAnnotation.Builder]],
                GenericListBuilder[AuditAnnotation, AuditAnnotation.Builder]
                | List[AuditAnnotation],
            ],
            /,
        ) -> "Cel.Builder": ...

        @overload
        def audit_annotations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AuditAnnotation.Builder]: ...

        def audit_annotations(self, value_or_callback=None, /):
            """
            AuditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AuditAnnotation.Builder]()
                context._parent_builder = self
                context._field_name = "audit_annotations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AuditAnnotation.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("audit_annotations", value)

        @overload
        def expressions(self, value_or_callback: List[Expression], /) -> "Cel.Builder": ...

        @overload
        def expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Expression, Expression.Builder]],
                GenericListBuilder[Expression, Expression.Builder] | List[Expression],
            ],
            /,
        ) -> "Cel.Builder": ...

        @overload
        def expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Expression.Builder]: ...

        def expressions(self, value_or_callback=None, /):
            """
            Expressions is a list of CELExpression types.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Expression.Builder]()
                context._parent_builder = self
                context._field_name = "expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Expression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("expressions", value)

        @overload
        def param_kind(self, value_or_callback: Optional[ParamKind], /) -> "Cel.Builder": ...

        @overload
        def param_kind(
            self,
            value_or_callback: Callable[[ParamKind.Builder], ParamKind.Builder | ParamKind],
            /,
        ) -> "Cel.Builder": ...

        @overload
        def param_kind(self, value_or_callback: Never = ...) -> "ParamKind.BuilderContext": ...

        def param_kind(self, value_or_callback=None, /):
            """
            ParamKind is a tuple of Group Kind and Version.
            """
            if self._in_context and value_or_callback is None:
                context = ParamKind.BuilderContext()
                context._parent_builder = self
                context._field_name = "param_kind"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ParamKind.builder())
                if isinstance(output, ParamKind.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("param_kind", value)

        @overload
        def param_ref(self, value_or_callback: Optional[ParamRef], /) -> "Cel.Builder": ...

        @overload
        def param_ref(
            self,
            value_or_callback: Callable[[ParamRef.Builder], ParamRef.Builder | ParamRef],
            /,
        ) -> "Cel.Builder": ...

        @overload
        def param_ref(self, value_or_callback: Never = ...) -> "ParamRef.BuilderContext": ...

        def param_ref(self, value_or_callback=None, /):
            """
            ParamRef references a parameter resource.
            """
            if self._in_context and value_or_callback is None:
                context = ParamRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "param_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ParamRef.builder())
                if isinstance(output, ParamRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("param_ref", value)

        @overload
        def variables(self, value_or_callback: List[VariableModel], /) -> "Cel.Builder": ...

        @overload
        def variables(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VariableModel, VariableModel.Builder]],
                GenericListBuilder[VariableModel, VariableModel.Builder] | List[VariableModel],
            ],
            /,
        ) -> "Cel.Builder": ...

        @overload
        def variables(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VariableModel.Builder]: ...

        def variables(self, value_or_callback=None, /):
            """
            Variables contain definitions of variables that can be used in composition of other expressions.
            Each variable is defined as a named CEL expression.
            The variables defined here will be available under `variables` in other expressions of the policy.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VariableModel.Builder]()
                context._parent_builder = self
                context._field_name = "variables"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VariableModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("variables", value)

    class BuilderContext(BuilderContextBase["Cel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    audit_annotations: Annotated[
        Optional[List[AuditAnnotation]], Field(alias="auditAnnotations")
    ] = None
    """
    AuditAnnotations contains CEL expressions which are used to produce audit annotations for the audit event of the API request.
    """
    expressions: Optional[List[Expression]] = None
    """
    Expressions is a list of CELExpression types.
    """
    param_kind: Annotated[Optional[ParamKind], Field(alias="paramKind")] = None
    """
    ParamKind is a tuple of Group Kind and Version.
    """
    param_ref: Annotated[Optional[ParamRef], Field(alias="paramRef")] = None
    """
    ParamRef references a parameter resource.
    """
    variables: Optional[List[VariableModel]] = None
    """
    Variables contain definitions of variables that can be used in composition of other expressions.
    Each variable is defined as a named CEL expression.
    The variables defined here will be available under `variables` in other expressions of the policy.
    """


class Deny(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Deny"]:
            return Deny

        def build(self) -> "Deny":
            return Deny(**self._attrs)

        @overload
        def conditions(self, value_or_callback: Optional[Conditions], /) -> "Deny.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "Deny.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Multiple conditions can be declared under an `any` or `all` statement.
            See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["Deny.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Deny.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Deny."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Deny", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Deny.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Conditions] = None
    """
    Multiple conditions can be declared under an `any` or `all` statement.
    See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
    """


class VariableModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel1"]:
            return VariableModel1

        def build(self) -> "VariableModel1":
            return VariableModel1(**self._attrs)

        def default(self, value: Optional[Any], /) -> Self:
            """
            Default is an optional arbitrary JSON object that the variable may take if the JMESPath
            expression evaluates to nil
            """
            return self._set("default", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath Expression that can be used to
            transform the variable.
            """
            return self._set("jmes_path", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is any arbitrary JSON object representable in YAML or JSON form.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["VariableModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default: Optional[Any] = None
    """
    Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    expression evaluates to nil
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath Expression that can be used to
    transform the variable.
    """
    value: Optional[Any] = None
    """
    Value is any arbitrary JSON object representable in YAML or JSON form.
    """


class DenyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DenyModel"]:
            return DenyModel

        def build(self) -> "DenyModel":
            return DenyModel(**self._attrs)

        def conditions(self, value: Optional[Any], /) -> Self:
            """
            Multiple conditions can be declared under an `any` or `all` statement. A direct list
            of conditions (without `any` or `all` statements) is also supported for backwards compatibility
            but will be deprecated in the next major release.
            See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
            """
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["DenyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DenyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DenyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DenyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DenyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Any] = None
    """
    Multiple conditions can be declared under an `any` or `all` statement. A direct list
    of conditions (without `any` or `all` statements) is also supported for backwards compatibility
    but will be deprecated in the next major release.
    See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
    """


class AllModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel5"]:
            return AllModel5

        def build(self) -> "AllModel5":
            return AllModel5(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel6"]:
            return AnyModel6

        def build(self) -> "AnyModel6":
            return AnyModel6(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class PreconditionsModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreconditionsModel1"]:
            return PreconditionsModel1

        def build(self) -> "PreconditionsModel1":
            return PreconditionsModel1(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel5], /) -> "PreconditionsModel1.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel5, AllModel5.Builder]],
                GenericListBuilder[AllModel5, AllModel5.Builder] | List[AllModel5],
            ],
            /,
        ) -> "PreconditionsModel1.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel5.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel5.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel5.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel6], /) -> "PreconditionsModel1.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel6, AnyModel6.Builder]],
                GenericListBuilder[AnyModel6, AnyModel6.Builder] | List[AnyModel6],
            ],
            /,
        ) -> "PreconditionsModel1.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel6.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel6.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel6.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["PreconditionsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PreconditionsModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreconditionsModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PreconditionsModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreconditionsModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel5]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass
    """
    any: Optional[List[AnyModel6]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass
    """


class ForeachModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel"]:
            return ForeachModel

        def build(self) -> "ForeachModel":
            return ForeachModel(**self._attrs)

        def any_pattern(self, value: Optional[Any], /) -> Self:
            """
            AnyPattern specifies list of validation patterns. At least one of the patterns
            must be satisfied for the validation rule to succeed.
            """
            return self._set("any_pattern", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def deny(self, value_or_callback: Optional[DenyModel], /) -> "ForeachModel.Builder": ...

        @overload
        def deny(
            self,
            value_or_callback: Callable[[DenyModel.Builder], DenyModel.Builder | DenyModel],
            /,
        ) -> "ForeachModel.Builder": ...

        @overload
        def deny(self, value_or_callback: Never = ...) -> "DenyModel.BuilderContext": ...

        def deny(self, value_or_callback=None, /):
            """
            Deny defines conditions used to pass or fail a validation rule.
            """
            if self._in_context and value_or_callback is None:
                context = DenyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "deny"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DenyModel.builder())
                if isinstance(output, DenyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("deny", value)

        def element_scope(self, value: Optional[bool], /) -> Self:
            """
            ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
            When set to "false", "request.object" is used as the validation scope within the foreach
            block to allow referencing other elements in the subtree.
            """
            return self._set("element_scope", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def pattern(self, value: Optional[Any], /) -> Self:
            """
            Pattern specifies an overlay-style pattern used to check resources.
            """
            return self._set("pattern", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel1], /
        ) -> "ForeachModel.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel1.Builder],
                PreconditionsModel1.Builder | PreconditionsModel1,
            ],
            /,
        ) -> "ForeachModel.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel1.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel1.builder())
                if isinstance(output, PreconditionsModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any_pattern: Annotated[Optional[Any], Field(alias="anyPattern")] = None
    """
    AnyPattern specifies list of validation patterns. At least one of the patterns
    must be satisfied for the validation rule to succeed.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    deny: Optional[DenyModel] = None
    """
    Deny defines conditions used to pass or fail a validation rule.
    """
    element_scope: Annotated[Optional[bool], Field(alias="elementScope")] = None
    """
    ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
    When set to "false", "request.object" is used as the validation scope within the foreach
    block to allow referencing other elements in the subtree.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    pattern: Optional[Any] = None
    """
    Pattern specifies an overlay-style pattern used to check resources.
    """
    preconditions: Optional[PreconditionsModel1] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class Ctlog(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ctlog"]:
            return Ctlog

        def build(self) -> "Ctlog":
            return Ctlog(**self._attrs)

        def ignore_sct(self, value: Optional[bool], /) -> Self:
            """
            IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
            timestamp. Default is false. Set to true if this was opted out during signing.
            """
            return self._set("ignore_sct", value)

        def pubkey(self, value: Optional[str], /) -> Self:
            """
            PubKey, if set, is used to validate SCTs against a custom source.
            """
            return self._set("pubkey", value)

    class BuilderContext(BuilderContextBase["Ctlog.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ctlog.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ctlog."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ctlog", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ctlog.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore_sct: Annotated[Optional[bool], Field(alias="ignoreSCT")] = None
    """
    IgnoreSCT defines whether to use the Signed Certificate Timestamp (SCT) log to check for a certificate
    timestamp. Default is false. Set to true if this was opted out during signing.
    """
    pubkey: Optional[str] = None
    """
    PubKey, if set, is used to validate SCTs against a custom source.
    """


class Rekor(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rekor"]:
            return Rekor

        def build(self) -> "Rekor":
            return Rekor(**self._attrs)

        def ignore_tlog(self, value: Optional[bool], /) -> Self:
            """
            IgnoreTlog skips transparency log verification.
            """
            return self._set("ignore_tlog", value)

        def pubkey(self, value: Optional[str], /) -> Self:
            """
            RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
            If set, this will be used to validate transparency log signatures from a custom Rekor.
            """
            return self._set("pubkey", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Rekor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rekor.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rekor."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rekor", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rekor.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore_tlog: Annotated[Optional[bool], Field(alias="ignoreTlog")] = None
    """
    IgnoreTlog skips transparency log verification.
    """
    pubkey: Optional[str] = None
    """
    RekorPubKey is an optional PEM-encoded public key to use for a custom Rekor.
    If set, this will be used to validate transparency log signatures from a custom Rekor.
    """
    url: Optional[str] = None
    """
    URL is the address of the transparency log. Defaults to the public Rekor log instance https://rekor.sigstore.dev.
    """


class Certificates(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Certificates"]:
            return Certificates

        def build(self) -> "Certificates":
            return Certificates(**self._attrs)

        def cert(self, value: Optional[str], /) -> Self:
            """
            Cert is an optional PEM-encoded public certificate.
            """
            return self._set("cert", value)

        def cert_chain(self, value: Optional[str], /) -> Self:
            """
            CertChain is an optional PEM encoded set of certificates used to verify.
            """
            return self._set("cert_chain", value)

        @overload
        def ctlog(self, value_or_callback: Optional[Ctlog], /) -> "Certificates.Builder": ...

        @overload
        def ctlog(
            self, value_or_callback: Callable[[Ctlog.Builder], Ctlog.Builder | Ctlog], /
        ) -> "Certificates.Builder": ...

        @overload
        def ctlog(self, value_or_callback: Never = ...) -> "Ctlog.BuilderContext": ...

        def ctlog(self, value_or_callback=None, /):
            """
            CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
            Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
            """
            if self._in_context and value_or_callback is None:
                context = Ctlog.BuilderContext()
                context._parent_builder = self
                context._field_name = "ctlog"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ctlog.builder())
                if isinstance(output, Ctlog.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ctlog", value)

        @overload
        def rekor(self, value_or_callback: Optional[Rekor], /) -> "Certificates.Builder": ...

        @overload
        def rekor(
            self, value_or_callback: Callable[[Rekor.Builder], Rekor.Builder | Rekor], /
        ) -> "Certificates.Builder": ...

        @overload
        def rekor(self, value_or_callback: Never = ...) -> "Rekor.BuilderContext": ...

        def rekor(self, value_or_callback=None, /):
            """
            Rekor provides configuration for the Rekor transparency log service. If an empty object
            is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
            """
            if self._in_context and value_or_callback is None:
                context = Rekor.BuilderContext()
                context._parent_builder = self
                context._field_name = "rekor"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rekor.builder())
                if isinstance(output, Rekor.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rekor", value)

    class BuilderContext(BuilderContextBase["Certificates.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Certificates.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Certificates."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Certificates", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Certificates.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert: Optional[str] = None
    """
    Cert is an optional PEM-encoded public certificate.
    """
    cert_chain: Annotated[Optional[str], Field(alias="certChain")] = None
    """
    CertChain is an optional PEM encoded set of certificates used to verify.
    """
    ctlog: Optional[Ctlog] = None
    """
    CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
    Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
    """
    rekor: Optional[Rekor] = None
    """
    Rekor provides configuration for the Rekor transparency log service. If an empty object
    is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
    """


class Keyless(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Keyless"]:
            return Keyless

        def build(self) -> "Keyless":
            return Keyless(**self._attrs)

        def additional_extensions(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            AdditionalExtensions are certificate-extensions used for keyless signing.
            """
            return self._set("additional_extensions", value)

        @overload
        def ctlog(self, value_or_callback: Optional[Ctlog], /) -> "Keyless.Builder": ...

        @overload
        def ctlog(
            self, value_or_callback: Callable[[Ctlog.Builder], Ctlog.Builder | Ctlog], /
        ) -> "Keyless.Builder": ...

        @overload
        def ctlog(self, value_or_callback: Never = ...) -> "Ctlog.BuilderContext": ...

        def ctlog(self, value_or_callback=None, /):
            """
            CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
            Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
            """
            if self._in_context and value_or_callback is None:
                context = Ctlog.BuilderContext()
                context._parent_builder = self
                context._field_name = "ctlog"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ctlog.builder())
                if isinstance(output, Ctlog.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ctlog", value)

        def issuer(self, value: Optional[str], /) -> Self:
            """
            Issuer is the certificate issuer used for keyless signing.
            """
            return self._set("issuer", value)

        @overload
        def rekor(self, value_or_callback: Optional[Rekor], /) -> "Keyless.Builder": ...

        @overload
        def rekor(
            self, value_or_callback: Callable[[Rekor.Builder], Rekor.Builder | Rekor], /
        ) -> "Keyless.Builder": ...

        @overload
        def rekor(self, value_or_callback: Never = ...) -> "Rekor.BuilderContext": ...

        def rekor(self, value_or_callback=None, /):
            """
            Rekor provides configuration for the Rekor transparency log service. If an empty object
            is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
            """
            if self._in_context and value_or_callback is None:
                context = Rekor.BuilderContext()
                context._parent_builder = self
                context._field_name = "rekor"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rekor.builder())
                if isinstance(output, Rekor.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rekor", value)

        def roots(self, value: Optional[str], /) -> Self:
            """
            Roots is an optional set of PEM encoded trusted root certificates.
            If not provided, the system roots are used.
            """
            return self._set("roots", value)

        def subject(self, value: Optional[str], /) -> Self:
            """
            Subject is the verified identity used for keyless signing, for example the email address.
            """
            return self._set("subject", value)

    class BuilderContext(BuilderContextBase["Keyless.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Keyless.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Keyless."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Keyless", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Keyless.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_extensions: Annotated[
        Optional[Dict[str, str]], Field(alias="additionalExtensions")
    ] = None
    """
    AdditionalExtensions are certificate-extensions used for keyless signing.
    """
    ctlog: Optional[Ctlog] = None
    """
    CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
    Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
    """
    issuer: Optional[str] = None
    """
    Issuer is the certificate issuer used for keyless signing.
    """
    rekor: Optional[Rekor] = None
    """
    Rekor provides configuration for the Rekor transparency log service. If an empty object
    is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
    """
    roots: Optional[str] = None
    """
    Roots is an optional set of PEM encoded trusted root certificates.
    If not provided, the system roots are used.
    """
    subject: Optional[str] = None
    """
    Subject is the verified identity used for keyless signing, for example the email address.
    """


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret. The provided secret must contain a key named cosign.pub.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace name where the Secret exists.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret. The provided secret must contain a key named cosign.pub.
    """
    namespace: str
    """
    Namespace name where the Secret exists.
    """


class Keys(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Keys"]:
            return Keys

        def build(self) -> "Keys":
            return Keys(**self._attrs)

        @overload
        def ctlog(self, value_or_callback: Optional[Ctlog], /) -> "Keys.Builder": ...

        @overload
        def ctlog(
            self, value_or_callback: Callable[[Ctlog.Builder], Ctlog.Builder | Ctlog], /
        ) -> "Keys.Builder": ...

        @overload
        def ctlog(self, value_or_callback: Never = ...) -> "Ctlog.BuilderContext": ...

        def ctlog(self, value_or_callback=None, /):
            """
            CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
            Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
            """
            if self._in_context and value_or_callback is None:
                context = Ctlog.BuilderContext()
                context._parent_builder = self
                context._field_name = "ctlog"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ctlog.builder())
                if isinstance(output, Ctlog.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ctlog", value)

        def kms(self, value: Optional[str], /) -> Self:
            """
            KMS provides the URI to the public key stored in a Key Management System. See:
            https://github.com/sigstore/cosign/blob/main/KMS.md
            """
            return self._set("kms", value)

        def public_keys(self, value: Optional[str], /) -> Self:
            """
            Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
            specified or can be a variable reference to a key specified in a ConfigMap (see
            https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
            elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
            The named Secret must specify a key `cosign.pub` containing the public key used for
            verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
            When multiple keys are specified each key is processed as a separate staticKey entry
            (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
            """
            return self._set("public_keys", value)

        @overload
        def rekor(self, value_or_callback: Optional[Rekor], /) -> "Keys.Builder": ...

        @overload
        def rekor(
            self, value_or_callback: Callable[[Rekor.Builder], Rekor.Builder | Rekor], /
        ) -> "Keys.Builder": ...

        @overload
        def rekor(self, value_or_callback: Never = ...) -> "Rekor.BuilderContext": ...

        def rekor(self, value_or_callback=None, /):
            """
            Rekor provides configuration for the Rekor transparency log service. If an empty object
            is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
            """
            if self._in_context and value_or_callback is None:
                context = Rekor.BuilderContext()
                context._parent_builder = self
                context._field_name = "rekor"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rekor.builder())
                if isinstance(output, Rekor.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rekor", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Keys.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Keys.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            Reference to a Secret resource that contains a public key
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

        def signature_algorithm(self, value: Optional[str], /) -> Self:
            """
            Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
            """
            return self._set("signature_algorithm", value)

    class BuilderContext(BuilderContextBase["Keys.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Keys.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Keys."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Keys", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Keys.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ctlog: Optional[Ctlog] = None
    """
    CTLog (certificate timestamp log) provides a configuration for validation of Signed Certificate
    Timestamps (SCTs). If the value is unset, the default behavior by Cosign is used.
    """
    kms: Optional[str] = None
    """
    KMS provides the URI to the public key stored in a Key Management System. See:
    https://github.com/sigstore/cosign/blob/main/KMS.md
    """
    public_keys: Annotated[Optional[str], Field(alias="publicKeys")] = None
    """
    Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly
    specified or can be a variable reference to a key specified in a ConfigMap (see
    https://kyverno.io/docs/writing-policies/variables/), or reference a standard Kubernetes Secret
    elsewhere in the cluster by specifying it in the format "k8s://<namespace>/<secret_name>".
    The named Secret must specify a key `cosign.pub` containing the public key used for
    verification, (see https://github.com/sigstore/cosign/blob/main/KMS.md#kubernetes-secret).
    When multiple keys are specified each key is processed as a separate staticKey entry
    (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
    """
    rekor: Optional[Rekor] = None
    """
    Rekor provides configuration for the Rekor transparency log service. If an empty object
    is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
    """
    secret: Optional[Secret] = None
    """
    Reference to a Secret resource that contains a public key
    """
    signature_algorithm: Annotated[Optional[str], Field(alias="signatureAlgorithm")] = "sha256"
    """
    Specify signature algorithm for public keys. Supported values are sha224, sha256, sha384 and sha512.
    """


class Entry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Entry"]:
            return Entry

        def build(self) -> "Entry":
            return Entry(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations are used for image verification.
            Every specified key-value pair must exist and match in the verified payload.
            The payload may contain other key-value pairs.
            """
            return self._set("annotations", value)

        def attestor(self, value: Optional[Any], /) -> Self:
            """
            Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
            """
            return self._set("attestor", value)

        @overload
        def certificates(self, value_or_callback: Optional[Certificates], /) -> "Entry.Builder": ...

        @overload
        def certificates(
            self,
            value_or_callback: Callable[
                [Certificates.Builder], Certificates.Builder | Certificates
            ],
            /,
        ) -> "Entry.Builder": ...

        @overload
        def certificates(self, value_or_callback: Never = ...) -> "Certificates.BuilderContext": ...

        def certificates(self, value_or_callback=None, /):
            """
            Certificates specifies one or more certificates.
            """
            if self._in_context and value_or_callback is None:
                context = Certificates.BuilderContext()
                context._parent_builder = self
                context._field_name = "certificates"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Certificates.builder())
                if isinstance(output, Certificates.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("certificates", value)

        @overload
        def keyless(self, value_or_callback: Optional[Keyless], /) -> "Entry.Builder": ...

        @overload
        def keyless(
            self,
            value_or_callback: Callable[[Keyless.Builder], Keyless.Builder | Keyless],
            /,
        ) -> "Entry.Builder": ...

        @overload
        def keyless(self, value_or_callback: Never = ...) -> "Keyless.BuilderContext": ...

        def keyless(self, value_or_callback=None, /):
            """
            Keyless is a set of attribute used to verify a Sigstore keyless attestor.
            See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
            """
            if self._in_context and value_or_callback is None:
                context = Keyless.BuilderContext()
                context._parent_builder = self
                context._field_name = "keyless"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Keyless.builder())
                if isinstance(output, Keyless.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("keyless", value)

        @overload
        def keys(self, value_or_callback: Optional[Keys], /) -> "Entry.Builder": ...

        @overload
        def keys(
            self, value_or_callback: Callable[[Keys.Builder], Keys.Builder | Keys], /
        ) -> "Entry.Builder": ...

        @overload
        def keys(self, value_or_callback: Never = ...) -> "Keys.BuilderContext": ...

        def keys(self, value_or_callback=None, /):
            """
            Keys specifies one or more public keys.
            """
            if self._in_context and value_or_callback is None:
                context = Keys.BuilderContext()
                context._parent_builder = self
                context._field_name = "keys"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Keys.builder())
                if isinstance(output, Keys.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("keys", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
            If specified Repository will override other OCI image repository locations for this Attestor.
            """
            return self._set("repository", value)

    class BuilderContext(BuilderContextBase["Entry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Entry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Entry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Entry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Entry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations are used for image verification.
    Every specified key-value pair must exist and match in the verified payload.
    The payload may contain other key-value pairs.
    """
    attestor: Optional[Any] = None
    """
    Attestor is a nested set of Attestor used to specify a more complex set of match authorities.
    """
    certificates: Optional[Certificates] = None
    """
    Certificates specifies one or more certificates.
    """
    keyless: Optional[Keyless] = None
    """
    Keyless is a set of attribute used to verify a Sigstore keyless attestor.
    See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
    """
    keys: Optional[Keys] = None
    """
    Keys specifies one or more public keys.
    """
    repository: Optional[str] = None
    """
    Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule.
    If specified Repository will override other OCI image repository locations for this Attestor.
    """


class Attestor(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Attestor"]:
            return Attestor

        def build(self) -> "Attestor":
            return Attestor(**self._attrs)

        def count(self, value: Optional[int], /) -> Self:
            """
            Count specifies the required number of entries that must match. If the count is null, all entries must match
            (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
            value N, then N must be less than or equal to the size of entries, and at least N entries must match.
            """
            return self._set("count", value)

        @overload
        def entries(self, value_or_callback: List[Entry], /) -> "Attestor.Builder": ...

        @overload
        def entries(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Entry, Entry.Builder]],
                GenericListBuilder[Entry, Entry.Builder] | List[Entry],
            ],
            /,
        ) -> "Attestor.Builder": ...

        @overload
        def entries(self, value_or_callback: Never = ...) -> ListBuilderContext[Entry.Builder]: ...

        def entries(self, value_or_callback=None, /):
            """
            Entries contains the available attestors. An attestor can be a static key,
            attributes for keyless verification, or a nested attestor declaration.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Entry.Builder]()
                context._parent_builder = self
                context._field_name = "entries"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Entry.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("entries", value)

    class BuilderContext(BuilderContextBase["Attestor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Attestor.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Attestor."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Attestor", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Attestor.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    count: Annotated[Optional[int], Field(ge=1)] = None
    """
    Count specifies the required number of entries that must match. If the count is null, all entries must match
    (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a
    value N, then N must be less than or equal to the size of entries, and at least N entries must match.
    """
    entries: Optional[List[Entry]] = None
    """
    Entries contains the available attestors. An attestor can be a static key,
    attributes for keyless verification, or a nested attestor declaration.
    """


class DryRun(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DryRun"]:
            return DryRun

        def build(self) -> "DryRun":
            return DryRun(**self._attrs)

        def enable(self, value: Optional[bool], /) -> Self:
            return self._set("enable", value)

        def namespace(self, value: Optional[str], /) -> Self:
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["DryRun.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DryRun.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DryRun."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DryRun", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DryRun.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    enable: Optional[bool] = None
    namespace: Optional[str] = None


class Object(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Object"]:
            return Object

        def build(self) -> "Object":
            return Object(**self._attrs)

        def group(self, value: Optional[str], /) -> Self:
            return self._set("group", value)

        def kind(self, value: Optional[str], /) -> Self:
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            return self._set("namespace", value)

        def version(self, value: Optional[str], /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Object.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Object.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Object."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Object", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Object.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[str] = None
    kind: Optional[str] = None
    name: Optional[str] = None
    namespace: Optional[str] = None
    version: Optional[str] = None


class IgnoreField(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IgnoreField"]:
            return IgnoreField

        def build(self) -> "IgnoreField":
            return IgnoreField(**self._attrs)

        def fields(self, value: Optional[List[str]], /) -> Self:
            return self._set("fields", value)

        @overload
        def objects(self, value_or_callback: List[Object], /) -> "IgnoreField.Builder": ...

        @overload
        def objects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Object, Object.Builder]],
                GenericListBuilder[Object, Object.Builder] | List[Object],
            ],
            /,
        ) -> "IgnoreField.Builder": ...

        @overload
        def objects(self, value_or_callback: Never = ...) -> ListBuilderContext[Object.Builder]: ...

        def objects(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Object.Builder]()
                context._parent_builder = self
                context._field_name = "objects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Object.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("objects", value)

    class BuilderContext(BuilderContextBase["IgnoreField.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IgnoreField.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IgnoreField."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IgnoreField", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IgnoreField.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fields: Optional[List[str]] = None
    objects: Optional[List[Object]] = None


class Manifests(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Manifests"]:
            return Manifests

        def build(self) -> "Manifests":
            return Manifests(**self._attrs)

        def annotation_domain(self, value: Optional[str], /) -> Self:
            """
            AnnotationDomain is custom domain of annotation for message and signature. Default is "cosign.sigstore.dev".
            """
            return self._set("annotation_domain", value)

        @overload
        def attestors(self, value_or_callback: List[Attestor], /) -> "Manifests.Builder": ...

        @overload
        def attestors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestor, Attestor.Builder]],
                GenericListBuilder[Attestor, Attestor.Builder] | List[Attestor],
            ],
            /,
        ) -> "Manifests.Builder": ...

        @overload
        def attestors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestor.Builder]: ...

        def attestors(self, value_or_callback=None, /):
            """
            Attestors specified the required attestors (i.e. authorities)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestor.Builder]()
                context._parent_builder = self
                context._field_name = "attestors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestors", value)

        @overload
        def dry_run(self, value_or_callback: Optional[DryRun], /) -> "Manifests.Builder": ...

        @overload
        def dry_run(
            self,
            value_or_callback: Callable[[DryRun.Builder], DryRun.Builder | DryRun],
            /,
        ) -> "Manifests.Builder": ...

        @overload
        def dry_run(self, value_or_callback: Never = ...) -> "DryRun.BuilderContext": ...

        def dry_run(self, value_or_callback=None, /):
            """
            DryRun configuration
            """
            if self._in_context and value_or_callback is None:
                context = DryRun.BuilderContext()
                context._parent_builder = self
                context._field_name = "dry_run"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DryRun.builder())
                if isinstance(output, DryRun.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("dry_run", value)

        @overload
        def ignore_fields(self, value_or_callback: List[IgnoreField], /) -> "Manifests.Builder": ...

        @overload
        def ignore_fields(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[IgnoreField, IgnoreField.Builder]],
                GenericListBuilder[IgnoreField, IgnoreField.Builder] | List[IgnoreField],
            ],
            /,
        ) -> "Manifests.Builder": ...

        @overload
        def ignore_fields(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[IgnoreField.Builder]: ...

        def ignore_fields(self, value_or_callback=None, /):
            """
            Fields which will be ignored while comparing manifests.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[IgnoreField.Builder]()
                context._parent_builder = self
                context._field_name = "ignore_fields"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IgnoreField.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ignore_fields", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            Repository is an optional alternate OCI repository to use for resource bundle reference.
            The repository can be overridden per Attestor or Attestation.
            """
            return self._set("repository", value)

    class BuilderContext(BuilderContextBase["Manifests.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Manifests.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Manifests."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Manifests", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Manifests.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotation_domain: Annotated[Optional[str], Field(alias="annotationDomain")] = None
    """
    AnnotationDomain is custom domain of annotation for message and signature. Default is "cosign.sigstore.dev".
    """
    attestors: Optional[List[Attestor]] = None
    """
    Attestors specified the required attestors (i.e. authorities)
    """
    dry_run: Annotated[Optional[DryRun], Field(alias="dryRun")] = None
    """
    DryRun configuration
    """
    ignore_fields: Annotated[Optional[List[IgnoreField]], Field(alias="ignoreFields")] = None
    """
    Fields which will be ignored while comparing manifests.
    """
    repository: Optional[str] = None
    """
    Repository is an optional alternate OCI repository to use for resource bundle reference.
    The repository can be overridden per Attestor or Attestation.
    """


class ExcludeModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel"]:
            return ExcludeModel

        def build(self) -> "ExcludeModel":
            return ExcludeModel(**self._attrs)

        def control_name(
            self,
            value: Literal[
                "HostProcess",
                "Host Namespaces",
                "Privileged Containers",
                "Capabilities",
                "HostPath Volumes",
                "Host Ports",
                "AppArmor",
                "SELinux",
                "/proc Mount Type",
                "Seccomp",
                "Sysctls",
                "Volume Types",
                "Privilege Escalation",
                "Running as Non-root",
                "Running as Non-root user",
            ],
            /,
        ) -> Self:
            """
            ControlName specifies the name of the Pod Security Standard control.
            See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
            """
            return self._set("control_name", value)

        def images(self, value: Optional[List[str]], /) -> Self:
            """
            Images selects matching containers and applies the container level PSS.
            Each image is the image name consisting of the registry address, repository, image, and tag.
            Empty list matches no containers, PSS checks are applied at the pod level only.
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("images", value)

        def restricted_field(self, value: Optional[str], /) -> Self:
            """
            RestrictedField selects the field for the given Pod Security Standard control.
            When not set, all restricted fields for the control are selected.
            """
            return self._set("restricted_field", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Values defines the allowed values that can be excluded.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["ExcludeModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(alias="controlName"),
    ]
    """
    ControlName specifies the name of the Pod Security Standard control.
    See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
    """
    images: Optional[List[str]] = None
    """
    Images selects matching containers and applies the container level PSS.
    Each image is the image name consisting of the registry address, repository, image, and tag.
    Empty list matches no containers, PSS checks are applied at the pod level only.
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    restricted_field: Annotated[Optional[str], Field(alias="restrictedField")] = None
    """
    RestrictedField selects the field for the given Pod Security Standard control.
    When not set, all restricted fields for the control are selected.
    """
    values: Optional[List[str]] = None
    """
    Values defines the allowed values that can be excluded.
    """


class PodSecurity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodSecurity"]:
            return PodSecurity

        def build(self) -> "PodSecurity":
            return PodSecurity(**self._attrs)

        @overload
        def exclude(self, value_or_callback: List[ExcludeModel], /) -> "PodSecurity.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ExcludeModel, ExcludeModel.Builder]],
                GenericListBuilder[ExcludeModel, ExcludeModel.Builder] | List[ExcludeModel],
            ],
            /,
        ) -> "PodSecurity.Builder": ...

        @overload
        def exclude(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ExcludeModel.Builder]: ...

        def exclude(self, value_or_callback=None, /):
            """
            Exclude specifies the Pod Security Standard controls to be excluded.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ExcludeModel.Builder]()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludeModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        def level(
            self, value: Optional[Literal["privileged", "baseline", "restricted"]], /
        ) -> Self:
            """
            Level defines the Pod Security Standard level to be applied to workloads.
            Allowed values are privileged, baseline, and restricted.
            """
            return self._set("level", value)

        def version(
            self,
            value: Optional[
                Literal[
                    "v1.19",
                    "v1.20",
                    "v1.21",
                    "v1.22",
                    "v1.23",
                    "v1.24",
                    "v1.25",
                    "v1.26",
                    "v1.27",
                    "v1.28",
                    "v1.29",
                    "latest",
                ]
            ],
            /,
        ) -> Self:
            """
            Version defines the Pod Security Standard versions that Kubernetes supports.
            Allowed values are v1.19, v1.20, v1.21, v1.22, v1.23, v1.24, v1.25, v1.26, v1.27, v1.28, v1.29, latest. Defaults to latest.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["PodSecurity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodSecurity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodSecurity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodSecurity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodSecurity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exclude: Optional[List[ExcludeModel]] = None
    """
    Exclude specifies the Pod Security Standard controls to be excluded.
    """
    level: Optional[Literal["privileged", "baseline", "restricted"]] = None
    """
    Level defines the Pod Security Standard level to be applied to workloads.
    Allowed values are privileged, baseline, and restricted.
    """
    version: Optional[
        Literal[
            "v1.19",
            "v1.20",
            "v1.21",
            "v1.22",
            "v1.23",
            "v1.24",
            "v1.25",
            "v1.26",
            "v1.27",
            "v1.28",
            "v1.29",
            "latest",
        ]
    ] = None
    """
    Version defines the Pod Security Standard versions that Kubernetes supports.
    Allowed values are v1.19, v1.20, v1.21, v1.22, v1.23, v1.24, v1.25, v1.26, v1.27, v1.28, v1.29, latest. Defaults to latest.
    """


class Validate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Validate"]:
            return Validate

        def build(self) -> "Validate":
            return Validate(**self._attrs)

        def any_pattern(self, value: Optional[Any], /) -> Self:
            """
            AnyPattern specifies list of validation patterns. At least one of the patterns
            must be satisfied for the validation rule to succeed.
            """
            return self._set("any_pattern", value)

        @overload
        def cel(self, value_or_callback: Optional[Cel], /) -> "Validate.Builder": ...

        @overload
        def cel(
            self, value_or_callback: Callable[[Cel.Builder], Cel.Builder | Cel], /
        ) -> "Validate.Builder": ...

        @overload
        def cel(self, value_or_callback: Never = ...) -> "Cel.BuilderContext": ...

        def cel(self, value_or_callback=None, /):
            """
            CEL allows validation checks using the Common Expression Language (https://kubernetes.io/docs/reference/using-api/cel/).
            """
            if self._in_context and value_or_callback is None:
                context = Cel.BuilderContext()
                context._parent_builder = self
                context._field_name = "cel"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cel.builder())
                if isinstance(output, Cel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cel", value)

        @overload
        def deny(self, value_or_callback: Optional[Deny], /) -> "Validate.Builder": ...

        @overload
        def deny(
            self, value_or_callback: Callable[[Deny.Builder], Deny.Builder | Deny], /
        ) -> "Validate.Builder": ...

        @overload
        def deny(self, value_or_callback: Never = ...) -> "Deny.BuilderContext": ...

        def deny(self, value_or_callback=None, /):
            """
            Deny defines conditions used to pass or fail a validation rule.
            """
            if self._in_context and value_or_callback is None:
                context = Deny.BuilderContext()
                context._parent_builder = self
                context._field_name = "deny"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Deny.builder())
                if isinstance(output, Deny.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("deny", value)

        @overload
        def foreach(self, value_or_callback: List[ForeachModel], /) -> "Validate.Builder": ...

        @overload
        def foreach(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ForeachModel, ForeachModel.Builder]],
                GenericListBuilder[ForeachModel, ForeachModel.Builder] | List[ForeachModel],
            ],
            /,
        ) -> "Validate.Builder": ...

        @overload
        def foreach(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ForeachModel.Builder]: ...

        def foreach(self, value_or_callback=None, /):
            """
            ForEach applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ForeachModel.Builder]()
                context._parent_builder = self
                context._field_name = "foreach"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForeachModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("foreach", value)

        @overload
        def manifests(self, value_or_callback: Optional[Manifests], /) -> "Validate.Builder": ...

        @overload
        def manifests(
            self,
            value_or_callback: Callable[[Manifests.Builder], Manifests.Builder | Manifests],
            /,
        ) -> "Validate.Builder": ...

        @overload
        def manifests(self, value_or_callback: Never = ...) -> "Manifests.BuilderContext": ...

        def manifests(self, value_or_callback=None, /):
            """
            Manifest specifies conditions for manifest verification
            """
            if self._in_context and value_or_callback is None:
                context = Manifests.BuilderContext()
                context._parent_builder = self
                context._field_name = "manifests"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Manifests.builder())
                if isinstance(output, Manifests.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("manifests", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message specifies a custom message to be displayed on failure.
            """
            return self._set("message", value)

        def pattern(self, value: Optional[Any], /) -> Self:
            """
            Pattern specifies an overlay-style pattern used to check resources.
            """
            return self._set("pattern", value)

        @overload
        def pod_security(
            self, value_or_callback: Optional[PodSecurity], /
        ) -> "Validate.Builder": ...

        @overload
        def pod_security(
            self,
            value_or_callback: Callable[[PodSecurity.Builder], PodSecurity.Builder | PodSecurity],
            /,
        ) -> "Validate.Builder": ...

        @overload
        def pod_security(self, value_or_callback: Never = ...) -> "PodSecurity.BuilderContext": ...

        def pod_security(self, value_or_callback=None, /):
            """
            PodSecurity applies exemptions for Kubernetes Pod Security admission
            by specifying exclusions for Pod Security Standards controls.
            """
            if self._in_context and value_or_callback is None:
                context = PodSecurity.BuilderContext()
                context._parent_builder = self
                context._field_name = "pod_security"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodSecurity.builder())
                if isinstance(output, PodSecurity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_security", value)

    class BuilderContext(BuilderContextBase["Validate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Validate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Validate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Validate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Validate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any_pattern: Annotated[Optional[Any], Field(alias="anyPattern")] = None
    """
    AnyPattern specifies list of validation patterns. At least one of the patterns
    must be satisfied for the validation rule to succeed.
    """
    cel: Optional[Cel] = None
    """
    CEL allows validation checks using the Common Expression Language (https://kubernetes.io/docs/reference/using-api/cel/).
    """
    deny: Optional[Deny] = None
    """
    Deny defines conditions used to pass or fail a validation rule.
    """
    foreach: Optional[List[ForeachModel]] = None
    """
    ForEach applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
    """
    manifests: Optional[Manifests] = None
    """
    Manifest specifies conditions for manifest verification
    """
    message: Optional[str] = None
    """
    Message specifies a custom message to be displayed on failure.
    """
    pattern: Optional[Any] = None
    """
    Pattern specifies an overlay-style pattern used to check resources.
    """
    pod_security: Annotated[Optional[PodSecurity], Field(alias="podSecurity")] = None
    """
    PodSecurity applies exemptions for Kubernetes Pod Security admission
    by specifying exclusions for Pod Security Standards controls.
    """


class ConditionModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel"]:
            return ConditionModel

        def build(self) -> "ConditionModel":
            return ConditionModel(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel5], /) -> "ConditionModel.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel5, AllModel5.Builder]],
                GenericListBuilder[AllModel5, AllModel5.Builder] | List[AllModel5],
            ],
            /,
        ) -> "ConditionModel.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel5.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel5.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel5.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel6], /) -> "ConditionModel.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel6, AnyModel6.Builder]],
                GenericListBuilder[AnyModel6, AnyModel6.Builder] | List[AnyModel6],
            ],
            /,
        ) -> "ConditionModel.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel6.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel6.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel6.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["ConditionModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel5]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass
    """
    any: Optional[List[AnyModel6]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass
    """


class Attestation(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Attestation"]:
            return Attestation

        def build(self) -> "Attestation":
            return Attestation(**self._attrs)

        @overload
        def attestors(self, value_or_callback: List[Attestor], /) -> "Attestation.Builder": ...

        @overload
        def attestors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestor, Attestor.Builder]],
                GenericListBuilder[Attestor, Attestor.Builder] | List[Attestor],
            ],
            /,
        ) -> "Attestation.Builder": ...

        @overload
        def attestors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestor.Builder]: ...

        def attestors(self, value_or_callback=None, /):
            """
            Attestors specify the required attestors (i.e. authorities).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestor.Builder]()
                context._parent_builder = self
                context._field_name = "attestors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestors", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel], /
        ) -> "Attestation.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel, ConditionModel.Builder]],
                GenericListBuilder[ConditionModel, ConditionModel.Builder] | List[ConditionModel],
            ],
            /,
        ) -> "Attestation.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions are used to verify attributes within a Predicate. If no Conditions are specified
            the attestation check is satisfied as long there are predicates that match the predicate type.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def predicate_type(self, value: Optional[str], /) -> Self:
            """
            Deprecated in favour of 'Type', to be removed soon
            """
            return self._set("predicate_type", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type defines the type of attestation contained within the Statement.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Attestation.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Attestation.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Attestation."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Attestation", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Attestation.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attestors: Optional[List[Attestor]] = None
    """
    Attestors specify the required attestors (i.e. authorities).
    """
    conditions: Optional[List[ConditionModel]] = None
    """
    Conditions are used to verify attributes within a Predicate. If no Conditions are specified
    the attestation check is satisfied as long there are predicates that match the predicate type.
    """
    predicate_type: Annotated[Optional[str], Field(alias="predicateType")] = None
    """
    Deprecated in favour of 'Type', to be removed soon
    """
    type: Optional[str] = None
    """
    Type defines the type of attestation contained within the Statement.
    """


class VerifyImage(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VerifyImage"]:
            return VerifyImage

        def build(self) -> "VerifyImage":
            return VerifyImage(**self._attrs)

        @overload
        def attestations(
            self, value_or_callback: List[Attestation], /
        ) -> "VerifyImage.Builder": ...

        @overload
        def attestations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestation, Attestation.Builder]],
                GenericListBuilder[Attestation, Attestation.Builder] | List[Attestation],
            ],
            /,
        ) -> "VerifyImage.Builder": ...

        @overload
        def attestations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestation.Builder]: ...

        def attestations(self, value_or_callback=None, /):
            """
            Attestations are optional checks for signed in-toto Statements used to verify the image.
            See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
            OCI registry and decodes them into a list of Statement declarations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestation.Builder]()
                context._parent_builder = self
                context._field_name = "attestations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestation.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestations", value)

        @overload
        def attestors(self, value_or_callback: List[Attestor], /) -> "VerifyImage.Builder": ...

        @overload
        def attestors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestor, Attestor.Builder]],
                GenericListBuilder[Attestor, Attestor.Builder] | List[Attestor],
            ],
            /,
        ) -> "VerifyImage.Builder": ...

        @overload
        def attestors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestor.Builder]: ...

        def attestors(self, value_or_callback=None, /):
            """
            Attestors specified the required attestors (i.e. authorities)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestor.Builder]()
                context._parent_builder = self
                context._field_name = "attestors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestors", value)

        def image_references(self, value: Optional[List[str]], /) -> Self:
            """
            ImageReferences is a list of matching image reference patterns. At least one pattern in the
            list must match the image for the rule to apply. Each image reference consists of a registry
            address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("image_references", value)

        @overload
        def image_registry_credentials(
            self, value_or_callback: Optional[ImageRegistryCredentials], /
        ) -> "VerifyImage.Builder": ...

        @overload
        def image_registry_credentials(
            self,
            value_or_callback: Callable[
                [ImageRegistryCredentials.Builder],
                ImageRegistryCredentials.Builder | ImageRegistryCredentials,
            ],
            /,
        ) -> "VerifyImage.Builder": ...

        @overload
        def image_registry_credentials(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistryCredentials.BuilderContext": ...

        def image_registry_credentials(self, value_or_callback=None, /):
            """
            ImageRegistryCredentials provides credentials that will be used for authentication with registry
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistryCredentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry_credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistryCredentials.builder())
                if isinstance(output, ImageRegistryCredentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry_credentials", value)

        def mutate_digest(self, value: Optional[bool], /) -> Self:
            """
            MutateDigest enables replacement of image tags with digests.
            Defaults to true.
            """
            return self._set("mutate_digest", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
            If specified Repository will override the default OCI image repository configured for the installation.
            The repository can also be overridden per Attestor or Attestation.
            """
            return self._set("repository", value)

        def required(self, value: Optional[bool], /) -> Self:
            """
            Required validates that images are verified i.e. have matched passed a signature or attestation check.
            """
            return self._set("required", value)

        def skip_image_references(self, value: Optional[List[str]], /) -> Self:
            """
            SkipImageReferences is a list of matching image reference patterns that should be skipped.
            At least one pattern in the list must match the image for the rule to be skipped. Each image reference
            consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("skip_image_references", value)

        def type(self, value: Optional[Literal["Cosign", "Notary"]], /) -> Self:
            """
            Type specifies the method of signature validation. The allowed options
            are Cosign and Notary. By default Cosign is used if a type is not specified.
            """
            return self._set("type", value)

        def use_cache(self, value: Optional[bool], /) -> Self:
            """
            UseCache enables caching of image verify responses for this rule
            """
            return self._set("use_cache", value)

        def verify_digest(self, value: Optional[bool], /) -> Self:
            """
            VerifyDigest validates that images have a digest.
            """
            return self._set("verify_digest", value)

    class BuilderContext(BuilderContextBase["VerifyImage.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VerifyImage.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VerifyImage."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VerifyImage", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyImage.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attestations: Optional[List[Attestation]] = None
    """
    Attestations are optional checks for signed in-toto Statements used to verify the image.
    See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
    OCI registry and decodes them into a list of Statement declarations.
    """
    attestors: Optional[List[Attestor]] = None
    """
    Attestors specified the required attestors (i.e. authorities)
    """
    image_references: Annotated[Optional[List[str]], Field(alias="imageReferences")] = None
    """
    ImageReferences is a list of matching image reference patterns. At least one pattern in the
    list must match the image for the rule to apply. Each image reference consists of a registry
    address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials], Field(alias="imageRegistryCredentials")
    ] = None
    """
    ImageRegistryCredentials provides credentials that will be used for authentication with registry
    """
    mutate_digest: Annotated[Optional[bool], Field(alias="mutateDigest")] = True
    """
    MutateDigest enables replacement of image tags with digests.
    Defaults to true.
    """
    repository: Optional[str] = None
    """
    Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
    If specified Repository will override the default OCI image repository configured for the installation.
    The repository can also be overridden per Attestor or Attestation.
    """
    required: Optional[bool] = True
    """
    Required validates that images are verified i.e. have matched passed a signature or attestation check.
    """
    skip_image_references: Annotated[Optional[List[str]], Field(alias="skipImageReferences")] = None
    """
    SkipImageReferences is a list of matching image reference patterns that should be skipped.
    At least one pattern in the list must match the image for the rule to be skipped. Each image reference
    consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    type: Optional[Literal["Cosign", "Notary"]] = None
    """
    Type specifies the method of signature validation. The allowed options
    are Cosign and Notary. By default Cosign is used if a type is not specified.
    """
    use_cache: Annotated[Optional[bool], Field(alias="useCache")] = True
    """
    UseCache enables caching of image verify responses for this rule
    """
    verify_digest: Annotated[Optional[bool], Field(alias="verifyDigest")] = True
    """
    VerifyDigest validates that images have a digest.
    """


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        @overload
        def cel_preconditions(
            self, value_or_callback: List[CelPrecondition], /
        ) -> "Rule.Builder": ...

        @overload
        def cel_preconditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CelPrecondition, CelPrecondition.Builder]],
                GenericListBuilder[CelPrecondition, CelPrecondition.Builder]
                | List[CelPrecondition],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def cel_preconditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CelPrecondition.Builder]: ...

        def cel_preconditions(self, value_or_callback=None, /):
            """
            CELPreconditions are used to determine if a policy rule should be applied by evaluating a
            set of CEL conditions. It can only be used with the validate.cel subrule
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CelPrecondition.Builder]()
                context._parent_builder = self
                context._field_name = "cel_preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CelPrecondition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cel_preconditions", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "Rule.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(self, value_or_callback: Optional[Exclude], /) -> "Rule.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[[Exclude.Builder], Exclude.Builder | Exclude],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "Exclude.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when this policy rule should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = Exclude.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exclude.builder())
                if isinstance(output, Exclude.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def generate(self, value_or_callback: Optional[Generate], /) -> "Rule.Builder": ...

        @overload
        def generate(
            self,
            value_or_callback: Callable[[Generate.Builder], Generate.Builder | Generate],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def generate(self, value_or_callback: Never = ...) -> "Generate.BuilderContext": ...

        def generate(self, value_or_callback=None, /):
            """
            Generation is used to create new resources.
            """
            if self._in_context and value_or_callback is None:
                context = Generate.BuilderContext()
                context._parent_builder = self
                context._field_name = "generate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Generate.builder())
                if isinstance(output, Generate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generate", value)

        def image_extractors(self, value: Optional[Dict[str, List[ImageExtractor]]], /) -> Self:
            """
            ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
            This config is only valid for verifyImages rules.
            """
            return self._set("image_extractors", value)

        @overload
        def match(self, value_or_callback: Optional[Match], /) -> "Rule.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "Rule.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when this policy rule should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def mutate(self, value_or_callback: Optional[Mutate], /) -> "Rule.Builder": ...

        @overload
        def mutate(
            self,
            value_or_callback: Callable[[Mutate.Builder], Mutate.Builder | Mutate],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def mutate(self, value_or_callback: Never = ...) -> "Mutate.BuilderContext": ...

        def mutate(self, value_or_callback=None, /):
            """
            Mutation is used to modify matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Mutate.BuilderContext()
                context._parent_builder = self
                context._field_name = "mutate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mutate.builder())
                if isinstance(output, Mutate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mutate", value)

        def name(self, value: str, /) -> Self:
            """
            Name is a label to identify the rule, It must be unique within the policy.
            """
            return self._set("name", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel], /
        ) -> "Rule.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel.Builder],
                PreconditionsModel.Builder | PreconditionsModel,
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            Preconditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel.builder())
                if isinstance(output, PreconditionsModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

        def skip_background_requests(self, value: Optional[bool], /) -> Self:
            """
            SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
            The default value is set to "true", it must be set to "false" to apply
            generate and mutateExisting rules to those requests.
            """
            return self._set("skip_background_requests", value)

        @overload
        def validate_(self, value_or_callback: Optional[Validate], /) -> "Rule.Builder": ...

        @overload
        def validate_(
            self,
            value_or_callback: Callable[[Validate.Builder], Validate.Builder | Validate],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def validate_(self, value_or_callback: Never = ...) -> "Validate.BuilderContext": ...

        def validate_(self, value_or_callback=None, /):
            """
            Validation is used to validate matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Validate.BuilderContext()
                context._parent_builder = self
                context._field_name = "validate_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Validate.builder())
                if isinstance(output, Validate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("validate_", value)

        @overload
        def verify_images(self, value_or_callback: List[VerifyImage], /) -> "Rule.Builder": ...

        @overload
        def verify_images(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VerifyImage, VerifyImage.Builder]],
                GenericListBuilder[VerifyImage, VerifyImage.Builder] | List[VerifyImage],
            ],
            /,
        ) -> "Rule.Builder": ...

        @overload
        def verify_images(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VerifyImage.Builder]: ...

        def verify_images(self, value_or_callback=None, /):
            """
            VerifyImages is used to verify image signatures and mutate them to add a digest
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VerifyImage.Builder]()
                context._parent_builder = self
                context._field_name = "verify_images"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VerifyImage.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify_images", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cel_preconditions: Annotated[
        Optional[List[CelPrecondition]], Field(alias="celPreconditions")
    ] = None
    """
    CELPreconditions are used to determine if a policy rule should be applied by evaluating a
    set of CEL conditions. It can only be used with the validate.cel subrule
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[Exclude] = None
    """
    ExcludeResources defines when this policy rule should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    generate: Optional[Generate] = None
    """
    Generation is used to create new resources.
    """
    image_extractors: Annotated[
        Optional[Dict[str, List[ImageExtractor]]], Field(alias="imageExtractors")
    ] = None
    """
    ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
    This config is only valid for verifyImages rules.
    """
    match: Optional[Match] = None
    """
    MatchResources defines when this policy rule should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    mutate: Optional[Mutate] = None
    """
    Mutation is used to modify matching resources.
    """
    name: Annotated[str, Field(max_length=63)]
    """
    Name is a label to identify the rule, It must be unique within the policy.
    """
    preconditions: Optional[PreconditionsModel] = None
    """
    Preconditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """
    skip_background_requests: Annotated[Optional[bool], Field(alias="skipBackgroundRequests")] = (
        True
    )
    """
    SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
    The default value is set to "true", it must be set to "false" to apply
    generate and mutateExisting rules to those requests.
    """
    validate_: Annotated[Optional[Validate], Field(alias="validate")] = None
    """
    Validation is used to validate matching resources.
    """
    verify_images: Annotated[Optional[List[VerifyImage]], Field(alias="verifyImages")] = None
    """
    VerifyImages is used to verify image signatures and mutate them to add a digest
    """


class ValidationFailureActionOverride(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValidationFailureActionOverride"]:
            return ValidationFailureActionOverride

        def build(self) -> "ValidationFailureActionOverride":
            return ValidationFailureActionOverride(**self._attrs)

        def action(
            self, value: Optional[Literal["audit", "enforce", "Audit", "Enforce"]], /
        ) -> Self:
            """
            ValidationFailureAction defines the policy validation failure action
            """
            return self._set("action", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "ValidationFailureActionOverride.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "ValidationFailureActionOverride.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            A label selector is a label query over a set of resources. The result of matchLabels and
            matchExpressions are ANDed. An empty label selector matches all objects. A null
            label selector matches no objects.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            return self._set("namespaces", value)

    class BuilderContext(BuilderContextBase["ValidationFailureActionOverride.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValidationFailureActionOverride.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValidationFailureActionOverride."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValidationFailureActionOverride", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValidationFailureActionOverride.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    action: Optional[Literal["audit", "enforce", "Audit", "Enforce"]] = None
    """
    ValidationFailureAction defines the policy validation failure action
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    A label selector is a label query over a set of resources. The result of matchLabels and
    matchExpressions are ANDed. An empty label selector matches all objects. A null
    label selector matches no objects.
    """
    namespaces: Optional[List[str]] = None


class MatchCondition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchCondition"]:
            return MatchCondition

        def build(self) -> "MatchCondition":
            return MatchCondition(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
            CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:


            'object' - The object from the incoming request. The value is null for DELETE requests.
            'oldObject' - The existing object. The value is null for CREATE requests.
            'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
            'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
              See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
            'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
              request resource.
            Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/


            Required.
            """
            return self._set("expression", value)

        def name(self, value: str, /) -> Self:
            """
            Name is an identifier for this match condition, used for strategic merging of MatchConditions,
            as well as providing an identifier for logging purposes. A good name should be descriptive of
            the associated expression.
            Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
            must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
            '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
            optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')


            Required.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["MatchCondition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchCondition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchCondition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchCondition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchCondition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
    CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:


    'object' - The object from the incoming request. The value is null for DELETE requests.
    'oldObject' - The existing object. The value is null for CREATE requests.
    'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
    'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
      See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
    'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
      request resource.
    Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/


    Required.
    """
    name: str
    """
    Name is an identifier for this match condition, used for strategic merging of MatchConditions,
    as well as providing an identifier for logging purposes. A good name should be descriptive of
    the associated expression.
    Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
    must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
    '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
    optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')


    Required.
    """


class WebhookConfiguration(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["WebhookConfiguration"]:
            return WebhookConfiguration

        def build(self) -> "WebhookConfiguration":
            return WebhookConfiguration(**self._attrs)

        @overload
        def match_conditions(
            self, value_or_callback: List[MatchCondition], /
        ) -> "WebhookConfiguration.Builder": ...

        @overload
        def match_conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchCondition, MatchCondition.Builder]],
                GenericListBuilder[MatchCondition, MatchCondition.Builder] | List[MatchCondition],
            ],
            /,
        ) -> "WebhookConfiguration.Builder": ...

        @overload
        def match_conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchCondition.Builder]: ...

        def match_conditions(self, value_or_callback=None, /):
            """
            MatchCondition configures admission webhook matchConditions.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchCondition.Builder]()
                context._parent_builder = self
                context._field_name = "match_conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchCondition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_conditions", value)

    class BuilderContext(BuilderContextBase["WebhookConfiguration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WebhookConfiguration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WebhookConfiguration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["WebhookConfiguration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use WebhookConfiguration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_conditions: Annotated[Optional[List[MatchCondition]], Field(alias="matchConditions")] = (
        None
    )
    """
    MatchCondition configures admission webhook matchConditions.
    """


class ClusterPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterPolicySpec"]:
            return ClusterPolicySpec

        def build(self) -> "ClusterPolicySpec":
            return ClusterPolicySpec(**self._attrs)

        def admission(self, value: Optional[bool], /) -> Self:
            """
            Admission controls if rules are applied during admission.
            Optional. Default value is "true".
            """
            return self._set("admission", value)

        def apply_rules(self, value: Optional[Literal["All", "One"]], /) -> Self:
            """
            ApplyRules controls how rules in a policy are applied. Rule are processed in
            the order of declaration. When set to `One` processing stops after a rule has
            been applied i.e. the rule matches and results in a pass, fail, or error. When
            set to `All` all rules in the policy are processed. The default is `All`.
            """
            return self._set("apply_rules", value)

        def background(self, value: Optional[bool], /) -> Self:
            """
            Background controls if rules are applied to existing resources during a background scan.
            Optional. Default value is "true". The value must be set to "false" if the policy rule
            uses variables that are only available in the admission review request (e.g. user name).
            """
            return self._set("background", value)

        def failure_policy(self, value: Optional[Literal["Ignore", "Fail"]], /) -> Self:
            """
            FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
            Rules within the same policy share the same failure behavior.
            Allowed values are Ignore or Fail. Defaults to Fail.
            """
            return self._set("failure_policy", value)

        def generate_existing(self, value: Optional[bool], /) -> Self:
            """
            GenerateExisting controls whether to trigger generate rule in existing resources
            If is set to "true" generate rule will be triggered and applied to existing matched resources.
            Defaults to "false" if not specified.
            """
            return self._set("generate_existing", value)

        def generate_existing_on_policy_update(self, value: Optional[bool], /) -> Self:
            """
            Deprecated, use generateExisting instead
            """
            return self._set("generate_existing_on_policy_update", value)

        def mutate_existing_on_policy_update(self, value: Optional[bool], /) -> Self:
            """
            MutateExistingOnPolicyUpdate controls if a mutateExisting policy is applied on policy events.
            Default value is "false".
            """
            return self._set("mutate_existing_on_policy_update", value)

        @overload
        def rules(self, value_or_callback: List[Rule], /) -> "ClusterPolicySpec.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "ClusterPolicySpec.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            Rules is a list of Rule instances. A Policy contains multiple rules and
            each rule can validate, mutate, or generate resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

        def schema_validation(self, value: Optional[bool], /) -> Self:
            """
            Deprecated.
            """
            return self._set("schema_validation", value)

        def use_server_side_apply(self, value: Optional[bool], /) -> Self:
            """
            UseServerSideApply controls whether to use server-side apply for generate rules
            If is set to "true" create & update for generate rules will use apply instead of create/update.
            Defaults to "false" if not specified.
            """
            return self._set("use_server_side_apply", value)

        def validation_failure_action(
            self, value: Optional[Literal["audit", "enforce", "Audit", "Enforce"]], /
        ) -> Self:
            """
            ValidationFailureAction defines if a validation policy rule violation should block
            the admission review request (enforce), or allow (audit) the admission review request
            and report an error in a policy report. Optional.
            Allowed values are audit or enforce. The default value is "Audit".
            """
            return self._set("validation_failure_action", value)

        @overload
        def validation_failure_action_overrides(
            self, value_or_callback: List[ValidationFailureActionOverride], /
        ) -> "ClusterPolicySpec.Builder": ...

        @overload
        def validation_failure_action_overrides(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ValidationFailureActionOverride,
                        ValidationFailureActionOverride.Builder,
                    ]
                ],
                GenericListBuilder[
                    ValidationFailureActionOverride,
                    ValidationFailureActionOverride.Builder,
                ]
                | List[ValidationFailureActionOverride],
            ],
            /,
        ) -> "ClusterPolicySpec.Builder": ...

        @overload
        def validation_failure_action_overrides(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationFailureActionOverride.Builder]: ...

        def validation_failure_action_overrides(self, value_or_callback=None, /):
            """
            ValidationFailureActionOverrides is a Cluster Policy attribute that specifies ValidationFailureAction
            namespace-wise. It overrides ValidationFailureAction for the specified namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationFailureActionOverride.Builder]()
                context._parent_builder = self
                context._field_name = "validation_failure_action_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationFailureActionOverride.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_failure_action_overrides", value)

        @overload
        def webhook_configuration(
            self, value_or_callback: Optional[WebhookConfiguration], /
        ) -> "ClusterPolicySpec.Builder": ...

        @overload
        def webhook_configuration(
            self,
            value_or_callback: Callable[
                [WebhookConfiguration.Builder],
                WebhookConfiguration.Builder | WebhookConfiguration,
            ],
            /,
        ) -> "ClusterPolicySpec.Builder": ...

        @overload
        def webhook_configuration(
            self, value_or_callback: Never = ...
        ) -> "WebhookConfiguration.BuilderContext": ...

        def webhook_configuration(self, value_or_callback=None, /):
            """
            WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
            Requires Kubernetes 1.27 or later.
            """
            if self._in_context and value_or_callback is None:
                context = WebhookConfiguration.BuilderContext()
                context._parent_builder = self
                context._field_name = "webhook_configuration"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebhookConfiguration.builder())
                if isinstance(output, WebhookConfiguration.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("webhook_configuration", value)

        def webhook_timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            WebhookTimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
            After the configured time expires, the admission request may fail, or may simply ignore the policy results,
            based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
            """
            return self._set("webhook_timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ClusterPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    admission: Optional[bool] = True
    """
    Admission controls if rules are applied during admission.
    Optional. Default value is "true".
    """
    apply_rules: Annotated[Optional[Literal["All", "One"]], Field(alias="applyRules")] = None
    """
    ApplyRules controls how rules in a policy are applied. Rule are processed in
    the order of declaration. When set to `One` processing stops after a rule has
    been applied i.e. the rule matches and results in a pass, fail, or error. When
    set to `All` all rules in the policy are processed. The default is `All`.
    """
    background: Optional[bool] = True
    """
    Background controls if rules are applied to existing resources during a background scan.
    Optional. Default value is "true". The value must be set to "false" if the policy rule
    uses variables that are only available in the admission review request (e.g. user name).
    """
    failure_policy: Annotated[Optional[Literal["Ignore", "Fail"]], Field(alias="failurePolicy")] = (
        None
    )
    """
    FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
    Rules within the same policy share the same failure behavior.
    Allowed values are Ignore or Fail. Defaults to Fail.
    """
    generate_existing: Annotated[Optional[bool], Field(alias="generateExisting")] = None
    """
    GenerateExisting controls whether to trigger generate rule in existing resources
    If is set to "true" generate rule will be triggered and applied to existing matched resources.
    Defaults to "false" if not specified.
    """
    generate_existing_on_policy_update: Annotated[
        Optional[bool], Field(alias="generateExistingOnPolicyUpdate")
    ] = None
    """
    Deprecated, use generateExisting instead
    """
    mutate_existing_on_policy_update: Annotated[
        Optional[bool], Field(alias="mutateExistingOnPolicyUpdate")
    ] = None
    """
    MutateExistingOnPolicyUpdate controls if a mutateExisting policy is applied on policy events.
    Default value is "false".
    """
    rules: Optional[List[Rule]] = None
    """
    Rules is a list of Rule instances. A Policy contains multiple rules and
    each rule can validate, mutate, or generate resources.
    """
    schema_validation: Annotated[Optional[bool], Field(alias="schemaValidation")] = None
    """
    Deprecated.
    """
    use_server_side_apply: Annotated[Optional[bool], Field(alias="useServerSideApply")] = None
    """
    UseServerSideApply controls whether to use server-side apply for generate rules
    If is set to "true" create & update for generate rules will use apply instead of create/update.
    Defaults to "false" if not specified.
    """
    validation_failure_action: Annotated[
        Optional[Literal["audit", "enforce", "Audit", "Enforce"]],
        Field(alias="validationFailureAction"),
    ] = "Audit"
    """
    ValidationFailureAction defines if a validation policy rule violation should block
    the admission review request (enforce), or allow (audit) the admission review request
    and report an error in a policy report. Optional.
    Allowed values are audit or enforce. The default value is "Audit".
    """
    validation_failure_action_overrides: Annotated[
        Optional[List[ValidationFailureActionOverride]],
        Field(alias="validationFailureActionOverrides"),
    ] = None
    """
    ValidationFailureActionOverrides is a Cluster Policy attribute that specifies ValidationFailureAction
    namespace-wise. It overrides ValidationFailureAction for the specified namespaces.
    """
    webhook_configuration: Annotated[
        Optional[WebhookConfiguration], Field(alias="webhookConfiguration")
    ] = None
    """
    WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
    Requires Kubernetes 1.27 or later.
    """
    webhook_timeout_seconds: Annotated[Optional[int], Field(alias="webhookTimeoutSeconds")] = None
    """
    WebhookTimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
    After the configured time expires, the admission request may fail, or may simply ignore the policy results,
    based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
    """


class AllModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel6"]:
            return AllModel6

        def build(self) -> "AllModel6":
            return AllModel6(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel6.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel6.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel6.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel6.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel7"]:
            return AnyModel7

        def build(self) -> "AnyModel7":
            return AnyModel7(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel7.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel7.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel7.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel7.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class ExcludeModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel1"]:
            return ExcludeModel1

        def build(self) -> "ExcludeModel1":
            return ExcludeModel1(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel6], /) -> "ExcludeModel1.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel6, AllModel6.Builder]],
                GenericListBuilder[AllModel6, AllModel6.Builder] | List[AllModel6],
            ],
            /,
        ) -> "ExcludeModel1.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel6.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel6.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel6.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel7], /) -> "ExcludeModel1.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel7, AnyModel7.Builder]],
                GenericListBuilder[AnyModel7, AnyModel7.Builder] | List[AnyModel7],
            ],
            /,
        ) -> "ExcludeModel1.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel7.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel7.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel7.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(
            self, value_or_callback: Optional[Resources], /
        ) -> "ExcludeModel1.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "ExcludeModel1.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            Requires at least one tag to be specified when under MatchResources.
            Specifying ResourceDescription directly under match is being deprecated.
            Please specify under "any" or "all" instead.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "ExcludeModel1.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "ExcludeModel1.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["ExcludeModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel6]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel7]] = None
    """
    Any allows specifying resources which will be ORed
    """
    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    Requires at least one tag to be specified when under MatchResources.
    Specifying ResourceDescription directly under match is being deprecated.
    Please specify under "any" or "all" instead.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class MatchModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel"]:
            return MatchModel

        def build(self) -> "MatchModel":
            return MatchModel(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel6], /) -> "MatchModel.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel6, AllModel6.Builder]],
                GenericListBuilder[AllModel6, AllModel6.Builder] | List[AllModel6],
            ],
            /,
        ) -> "MatchModel.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel6.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel6.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel6.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel7], /) -> "MatchModel.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel7, AnyModel7.Builder]],
                GenericListBuilder[AnyModel7, AnyModel7.Builder] | List[AnyModel7],
            ],
            /,
        ) -> "MatchModel.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel7.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel7.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel7.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "MatchModel.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "MatchModel.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            Requires at least one tag to be specified when under MatchResources.
            Specifying ResourceDescription directly under match is being deprecated.
            Please specify under "any" or "all" instead.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "MatchModel.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "MatchModel.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["MatchModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel6]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel7]] = None
    """
    Any allows specifying resources which will be ORed
    """
    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    Requires at least one tag to be specified when under MatchResources.
    Specifying ResourceDescription directly under match is being deprecated.
    Please specify under "any" or "all" instead.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AllModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel7"]:
            return AllModel7

        def build(self) -> "AllModel7":
            return AllModel7(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel8"]:
            return AnyModel8

        def build(self) -> "AnyModel8":
            return AnyModel8(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class ForeachModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel1"]:
            return ForeachModel1

        def build(self) -> "ForeachModel1":
            return ForeachModel1(**self._attrs)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel1.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel1.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def order(self, value: Optional[Literal["Ascending", "Descending"]], /) -> Self:
            """
            Order defines the iteration order on the list.
            Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
            """
            return self._set("order", value)

        def patch_strategic_merge(self, value: Optional[Any], /) -> Self:
            """
            PatchStrategicMerge is a strategic merge patch used to modify resources.
            See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
            and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
            """
            return self._set("patch_strategic_merge", value)

        def patches_json6902(self, value: Optional[str], /) -> Self:
            """
            PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
            See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
            """
            return self._set("patches_json6902", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel1], /
        ) -> "ForeachModel1.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel1.Builder],
                PreconditionsModel1.Builder | PreconditionsModel1,
            ],
            /,
        ) -> "ForeachModel1.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel1.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel1.builder())
                if isinstance(output, PreconditionsModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    order: Optional[Literal["Ascending", "Descending"]] = None
    """
    Order defines the iteration order on the list.
    Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
    """
    patch_strategic_merge: Annotated[Optional[Any], Field(alias="patchStrategicMerge")] = None
    """
    PatchStrategicMerge is a strategic merge patch used to modify resources.
    See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
    and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
    """
    patches_json6902: Annotated[Optional[str], Field(alias="patchesJson6902")] = None
    """
    PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
    See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
    """
    preconditions: Optional[PreconditionsModel1] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class VariableModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel2"]:
            return VariableModel2

        def build(self) -> "VariableModel2":
            return VariableModel2(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression is the expression that will be evaluated as the value of the variable.
            The CEL expression has access to the same identifiers as the CEL expressions in Validation.
            """
            return self._set("expression", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
            The variable can be accessed in other expressions through `variables`
            For example, if name is "foo", the variable will be available as `variables.foo`
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["VariableModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression is the expression that will be evaluated as the value of the variable.
    The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    """
    name: str
    """
    Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    The variable can be accessed in other expressions through `variables`
    For example, if name is "foo", the variable will be available as `variables.foo`
    """


class VariableModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel3"]:
            return VariableModel3

        def build(self) -> "VariableModel3":
            return VariableModel3(**self._attrs)

        def default(self, value: Optional[Any], /) -> Self:
            """
            Default is an optional arbitrary JSON object that the variable may take if the JMESPath
            expression evaluates to nil
            """
            return self._set("default", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath Expression that can be used to
            transform the variable.
            """
            return self._set("jmes_path", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is any arbitrary JSON object representable in YAML or JSON form.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["VariableModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default: Optional[Any] = None
    """
    Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    expression evaluates to nil
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath Expression that can be used to
    transform the variable.
    """
    value: Optional[Any] = None
    """
    Value is any arbitrary JSON object representable in YAML or JSON form.
    """


class ForeachModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel2"]:
            return ForeachModel2

        def build(self) -> "ForeachModel2":
            return ForeachModel2(**self._attrs)

        def any_pattern(self, value: Optional[Any], /) -> Self:
            """
            AnyPattern specifies list of validation patterns. At least one of the patterns
            must be satisfied for the validation rule to succeed.
            """
            return self._set("any_pattern", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel2.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel2.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def deny(self, value_or_callback: Optional[DenyModel], /) -> "ForeachModel2.Builder": ...

        @overload
        def deny(
            self,
            value_or_callback: Callable[[DenyModel.Builder], DenyModel.Builder | DenyModel],
            /,
        ) -> "ForeachModel2.Builder": ...

        @overload
        def deny(self, value_or_callback: Never = ...) -> "DenyModel.BuilderContext": ...

        def deny(self, value_or_callback=None, /):
            """
            Deny defines conditions used to pass or fail a validation rule.
            """
            if self._in_context and value_or_callback is None:
                context = DenyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "deny"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DenyModel.builder())
                if isinstance(output, DenyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("deny", value)

        def element_scope(self, value: Optional[bool], /) -> Self:
            """
            ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
            When set to "false", "request.object" is used as the validation scope within the foreach
            block to allow referencing other elements in the subtree.
            """
            return self._set("element_scope", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def pattern(self, value: Optional[Any], /) -> Self:
            """
            Pattern specifies an overlay-style pattern used to check resources.
            """
            return self._set("pattern", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel1], /
        ) -> "ForeachModel2.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel1.Builder],
                PreconditionsModel1.Builder | PreconditionsModel1,
            ],
            /,
        ) -> "ForeachModel2.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel1.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel1.builder())
                if isinstance(output, PreconditionsModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any_pattern: Annotated[Optional[Any], Field(alias="anyPattern")] = None
    """
    AnyPattern specifies list of validation patterns. At least one of the patterns
    must be satisfied for the validation rule to succeed.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    deny: Optional[DenyModel] = None
    """
    Deny defines conditions used to pass or fail a validation rule.
    """
    element_scope: Annotated[Optional[bool], Field(alias="elementScope")] = None
    """
    ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
    When set to "false", "request.object" is used as the validation scope within the foreach
    block to allow referencing other elements in the subtree.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    pattern: Optional[Any] = None
    """
    Pattern specifies an overlay-style pattern used to check resources.
    """
    preconditions: Optional[PreconditionsModel1] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class ExcludeModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel2"]:
            return ExcludeModel2

        def build(self) -> "ExcludeModel2":
            return ExcludeModel2(**self._attrs)

        def control_name(
            self,
            value: Literal[
                "HostProcess",
                "Host Namespaces",
                "Privileged Containers",
                "Capabilities",
                "HostPath Volumes",
                "Host Ports",
                "AppArmor",
                "SELinux",
                "/proc Mount Type",
                "Seccomp",
                "Sysctls",
                "Volume Types",
                "Privilege Escalation",
                "Running as Non-root",
                "Running as Non-root user",
            ],
            /,
        ) -> Self:
            """
            ControlName specifies the name of the Pod Security Standard control.
            See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
            """
            return self._set("control_name", value)

        def images(self, value: Optional[List[str]], /) -> Self:
            """
            Images selects matching containers and applies the container level PSS.
            Each image is the image name consisting of the registry address, repository, image, and tag.
            Empty list matches no containers, PSS checks are applied at the pod level only.
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("images", value)

        def restricted_field(self, value: Optional[str], /) -> Self:
            """
            RestrictedField selects the field for the given Pod Security Standard control.
            When not set, all restricted fields for the control are selected.
            """
            return self._set("restricted_field", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Values defines the allowed values that can be excluded.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["ExcludeModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(alias="controlName"),
    ]
    """
    ControlName specifies the name of the Pod Security Standard control.
    See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
    """
    images: Optional[List[str]] = None
    """
    Images selects matching containers and applies the container level PSS.
    Each image is the image name consisting of the registry address, repository, image, and tag.
    Empty list matches no containers, PSS checks are applied at the pod level only.
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    restricted_field: Annotated[Optional[str], Field(alias="restrictedField")] = None
    """
    RestrictedField selects the field for the given Pod Security Standard control.
    When not set, all restricted fields for the control are selected.
    """
    values: Optional[List[str]] = None
    """
    Values defines the allowed values that can be excluded.
    """


class VerifyImageModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VerifyImageModel"]:
            return VerifyImageModel

        def build(self) -> "VerifyImageModel":
            return VerifyImageModel(**self._attrs)

        def additional_extensions(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Deprecated.
            """
            return self._set("additional_extensions", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Deprecated. Use annotations per Attestor instead.
            """
            return self._set("annotations", value)

        @overload
        def attestations(
            self, value_or_callback: List[Attestation], /
        ) -> "VerifyImageModel.Builder": ...

        @overload
        def attestations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestation, Attestation.Builder]],
                GenericListBuilder[Attestation, Attestation.Builder] | List[Attestation],
            ],
            /,
        ) -> "VerifyImageModel.Builder": ...

        @overload
        def attestations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestation.Builder]: ...

        def attestations(self, value_or_callback=None, /):
            """
            Attestations are optional checks for signed in-toto Statements used to verify the image.
            See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
            OCI registry and decodes them into a list of Statement declarations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestation.Builder]()
                context._parent_builder = self
                context._field_name = "attestations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestation.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestations", value)

        @overload
        def attestors(self, value_or_callback: List[Attestor], /) -> "VerifyImageModel.Builder": ...

        @overload
        def attestors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestor, Attestor.Builder]],
                GenericListBuilder[Attestor, Attestor.Builder] | List[Attestor],
            ],
            /,
        ) -> "VerifyImageModel.Builder": ...

        @overload
        def attestors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestor.Builder]: ...

        def attestors(self, value_or_callback=None, /):
            """
            Attestors specified the required attestors (i.e. authorities)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestor.Builder]()
                context._parent_builder = self
                context._field_name = "attestors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestors", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use ImageReferences instead.
            """
            return self._set("image", value)

        def image_references(self, value: Optional[List[str]], /) -> Self:
            """
            ImageReferences is a list of matching image reference patterns. At least one pattern in the
            list must match the image for the rule to apply. Each image reference consists of a registry
            address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("image_references", value)

        @overload
        def image_registry_credentials(
            self, value_or_callback: Optional[ImageRegistryCredentials], /
        ) -> "VerifyImageModel.Builder": ...

        @overload
        def image_registry_credentials(
            self,
            value_or_callback: Callable[
                [ImageRegistryCredentials.Builder],
                ImageRegistryCredentials.Builder | ImageRegistryCredentials,
            ],
            /,
        ) -> "VerifyImageModel.Builder": ...

        @overload
        def image_registry_credentials(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistryCredentials.BuilderContext": ...

        def image_registry_credentials(self, value_or_callback=None, /):
            """
            ImageRegistryCredentials provides credentials that will be used for authentication with registry.
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistryCredentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry_credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistryCredentials.builder())
                if isinstance(output, ImageRegistryCredentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry_credentials", value)

        def issuer(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use KeylessAttestor instead.
            """
            return self._set("issuer", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use StaticKeyAttestor instead.
            """
            return self._set("key", value)

        def mutate_digest(self, value: Optional[bool], /) -> Self:
            """
            MutateDigest enables replacement of image tags with digests.
            Defaults to true.
            """
            return self._set("mutate_digest", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
            If specified Repository will override the default OCI image repository configured for the installation.
            The repository can also be overridden per Attestor or Attestation.
            """
            return self._set("repository", value)

        def required(self, value: Optional[bool], /) -> Self:
            """
            Required validates that images are verified i.e. have matched passed a signature or attestation check.
            """
            return self._set("required", value)

        def roots(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use KeylessAttestor instead.
            """
            return self._set("roots", value)

        def skip_image_references(self, value: Optional[List[str]], /) -> Self:
            """
            SkipImageReferences is a list of matching image reference patterns that should be skipped.
            At least one pattern in the list must match the image for the rule to be skipped. Each image reference
            consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("skip_image_references", value)

        def subject(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use KeylessAttestor instead.
            """
            return self._set("subject", value)

        def type(self, value: Optional[Literal["Cosign", "Notary"]], /) -> Self:
            """
            Type specifies the method of signature validation. The allowed options
            are Cosign and Notary. By default Cosign is used if a type is not specified.
            """
            return self._set("type", value)

        def use_cache(self, value: Optional[bool], /) -> Self:
            """
            UseCache enables caching of image verify responses for this rule.
            """
            return self._set("use_cache", value)

        def verify_digest(self, value: Optional[bool], /) -> Self:
            """
            VerifyDigest validates that images have a digest.
            """
            return self._set("verify_digest", value)

    class BuilderContext(BuilderContextBase["VerifyImageModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VerifyImageModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VerifyImageModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VerifyImageModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyImageModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_extensions: Annotated[
        Optional[Dict[str, str]], Field(alias="additionalExtensions")
    ] = None
    """
    Deprecated.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Deprecated. Use annotations per Attestor instead.
    """
    attestations: Optional[List[Attestation]] = None
    """
    Attestations are optional checks for signed in-toto Statements used to verify the image.
    See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
    OCI registry and decodes them into a list of Statement declarations.
    """
    attestors: Optional[List[Attestor]] = None
    """
    Attestors specified the required attestors (i.e. authorities)
    """
    image: Optional[str] = None
    """
    Deprecated. Use ImageReferences instead.
    """
    image_references: Annotated[Optional[List[str]], Field(alias="imageReferences")] = None
    """
    ImageReferences is a list of matching image reference patterns. At least one pattern in the
    list must match the image for the rule to apply. Each image reference consists of a registry
    address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials], Field(alias="imageRegistryCredentials")
    ] = None
    """
    ImageRegistryCredentials provides credentials that will be used for authentication with registry.
    """
    issuer: Optional[str] = None
    """
    Deprecated. Use KeylessAttestor instead.
    """
    key: Optional[str] = None
    """
    Deprecated. Use StaticKeyAttestor instead.
    """
    mutate_digest: Annotated[Optional[bool], Field(alias="mutateDigest")] = True
    """
    MutateDigest enables replacement of image tags with digests.
    Defaults to true.
    """
    repository: Optional[str] = None
    """
    Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
    If specified Repository will override the default OCI image repository configured for the installation.
    The repository can also be overridden per Attestor or Attestation.
    """
    required: Optional[bool] = True
    """
    Required validates that images are verified i.e. have matched passed a signature or attestation check.
    """
    roots: Optional[str] = None
    """
    Deprecated. Use KeylessAttestor instead.
    """
    skip_image_references: Annotated[Optional[List[str]], Field(alias="skipImageReferences")] = None
    """
    SkipImageReferences is a list of matching image reference patterns that should be skipped.
    At least one pattern in the list must match the image for the rule to be skipped. Each image reference
    consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    subject: Optional[str] = None
    """
    Deprecated. Use KeylessAttestor instead.
    """
    type: Optional[Literal["Cosign", "Notary"]] = None
    """
    Type specifies the method of signature validation. The allowed options
    are Cosign and Notary. By default Cosign is used if a type is not specified.
    """
    use_cache: Annotated[Optional[bool], Field(alias="useCache")] = True
    """
    UseCache enables caching of image verify responses for this rule.
    """
    verify_digest: Annotated[Optional[bool], Field(alias="verifyDigest")] = True
    """
    VerifyDigest validates that images have a digest.
    """


class RuleModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuleModel"]:
            return RuleModel

        def build(self) -> "RuleModel":
            return RuleModel(**self._attrs)

        @overload
        def cel_preconditions(
            self, value_or_callback: List[CelPrecondition], /
        ) -> "RuleModel.Builder": ...

        @overload
        def cel_preconditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CelPrecondition, CelPrecondition.Builder]],
                GenericListBuilder[CelPrecondition, CelPrecondition.Builder]
                | List[CelPrecondition],
            ],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def cel_preconditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CelPrecondition.Builder]: ...

        def cel_preconditions(self, value_or_callback=None, /):
            """
            CELPreconditions are used to determine if a policy rule should be applied by evaluating a
            set of CEL conditions. It can only be used with the validate.cel subrule
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CelPrecondition.Builder]()
                context._parent_builder = self
                context._field_name = "cel_preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CelPrecondition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cel_preconditions", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "RuleModel.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(self, value_or_callback: Optional[ExcludeModel1], /) -> "RuleModel.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[
                [ExcludeModel1.Builder], ExcludeModel1.Builder | ExcludeModel1
            ],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "ExcludeModel1.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when this policy rule should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = ExcludeModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludeModel1.builder())
                if isinstance(output, ExcludeModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def generate(self, value_or_callback: Optional[Generate], /) -> "RuleModel.Builder": ...

        @overload
        def generate(
            self,
            value_or_callback: Callable[[Generate.Builder], Generate.Builder | Generate],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def generate(self, value_or_callback: Never = ...) -> "Generate.BuilderContext": ...

        def generate(self, value_or_callback=None, /):
            """
            Generation is used to create new resources.
            """
            if self._in_context and value_or_callback is None:
                context = Generate.BuilderContext()
                context._parent_builder = self
                context._field_name = "generate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Generate.builder())
                if isinstance(output, Generate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generate", value)

        def image_extractors(self, value: Optional[Dict[str, List[ImageExtractor]]], /) -> Self:
            """
            ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
            This config is only valid for verifyImages rules.
            """
            return self._set("image_extractors", value)

        @overload
        def match(self, value_or_callback: Optional[MatchModel], /) -> "RuleModel.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[[MatchModel.Builder], MatchModel.Builder | MatchModel],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "MatchModel.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when this policy rule should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = MatchModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel.builder())
                if isinstance(output, MatchModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def mutate(self, value_or_callback: Optional[Mutate], /) -> "RuleModel.Builder": ...

        @overload
        def mutate(
            self,
            value_or_callback: Callable[[Mutate.Builder], Mutate.Builder | Mutate],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def mutate(self, value_or_callback: Never = ...) -> "Mutate.BuilderContext": ...

        def mutate(self, value_or_callback=None, /):
            """
            Mutation is used to modify matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Mutate.BuilderContext()
                context._parent_builder = self
                context._field_name = "mutate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mutate.builder())
                if isinstance(output, Mutate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mutate", value)

        def name(self, value: str, /) -> Self:
            """
            Name is a label to identify the rule, It must be unique within the policy.
            """
            return self._set("name", value)

        def preconditions(self, value: Optional[Any], /) -> Self:
            """
            Preconditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
            of conditions (without `any` or `all` statements is supported for backwards compatibility but
            will be deprecated in the next major release.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            return self._set("preconditions", value)

        def skip_background_requests(self, value: Optional[bool], /) -> Self:
            """
            SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
            The default value is set to "true", it must be set to "false" to apply
            generate and mutateExisting rules to those requests.
            """
            return self._set("skip_background_requests", value)

        @overload
        def validate_(self, value_or_callback: Optional[Validate], /) -> "RuleModel.Builder": ...

        @overload
        def validate_(
            self,
            value_or_callback: Callable[[Validate.Builder], Validate.Builder | Validate],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def validate_(self, value_or_callback: Never = ...) -> "Validate.BuilderContext": ...

        def validate_(self, value_or_callback=None, /):
            """
            Validation is used to validate matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Validate.BuilderContext()
                context._parent_builder = self
                context._field_name = "validate_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Validate.builder())
                if isinstance(output, Validate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("validate_", value)

        @overload
        def verify_images(
            self, value_or_callback: List[VerifyImageModel], /
        ) -> "RuleModel.Builder": ...

        @overload
        def verify_images(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VerifyImageModel, VerifyImageModel.Builder]],
                GenericListBuilder[VerifyImageModel, VerifyImageModel.Builder]
                | List[VerifyImageModel],
            ],
            /,
        ) -> "RuleModel.Builder": ...

        @overload
        def verify_images(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VerifyImageModel.Builder]: ...

        def verify_images(self, value_or_callback=None, /):
            """
            VerifyImages is used to verify image signatures and mutate them to add a digest
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VerifyImageModel.Builder]()
                context._parent_builder = self
                context._field_name = "verify_images"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VerifyImageModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify_images", value)

    class BuilderContext(BuilderContextBase["RuleModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuleModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuleModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuleModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuleModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cel_preconditions: Annotated[
        Optional[List[CelPrecondition]], Field(alias="celPreconditions")
    ] = None
    """
    CELPreconditions are used to determine if a policy rule should be applied by evaluating a
    set of CEL conditions. It can only be used with the validate.cel subrule
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[ExcludeModel1] = None
    """
    ExcludeResources defines when this policy rule should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    generate: Optional[Generate] = None
    """
    Generation is used to create new resources.
    """
    image_extractors: Annotated[
        Optional[Dict[str, List[ImageExtractor]]], Field(alias="imageExtractors")
    ] = None
    """
    ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
    This config is only valid for verifyImages rules.
    """
    match: Optional[MatchModel] = None
    """
    MatchResources defines when this policy rule should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    mutate: Optional[Mutate] = None
    """
    Mutation is used to modify matching resources.
    """
    name: Annotated[str, Field(max_length=63)]
    """
    Name is a label to identify the rule, It must be unique within the policy.
    """
    preconditions: Optional[Any] = None
    """
    Preconditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
    of conditions (without `any` or `all` statements is supported for backwards compatibility but
    will be deprecated in the next major release.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """
    skip_background_requests: Annotated[Optional[bool], Field(alias="skipBackgroundRequests")] = (
        True
    )
    """
    SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
    The default value is set to "true", it must be set to "false" to apply
    generate and mutateExisting rules to those requests.
    """
    validate_: Annotated[Optional[Validate], Field(alias="validate")] = None
    """
    Validation is used to validate matching resources.
    """
    verify_images: Annotated[Optional[List[VerifyImageModel]], Field(alias="verifyImages")] = None
    """
    VerifyImages is used to verify image signatures and mutate them to add a digest
    """


class Autogen(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Autogen"]:
            return Autogen

        def build(self) -> "Autogen":
            return Autogen(**self._attrs)

        @overload
        def rules(self, value_or_callback: List[RuleModel], /) -> "Autogen.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RuleModel, RuleModel.Builder]],
                GenericListBuilder[RuleModel, RuleModel.Builder] | List[RuleModel],
            ],
            /,
        ) -> "Autogen.Builder": ...

        @overload
        def rules(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RuleModel.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            Rules is a list of Rule instances. It contains auto generated rules added for pod controllers
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RuleModel.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

    class BuilderContext(BuilderContextBase["Autogen.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Autogen.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Autogen."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Autogen", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Autogen.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    rules: Optional[List[RuleModel]] = None
    """
    Rules is a list of Rule instances. It contains auto generated rules added for pod controllers
    """


class ConditionModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel1"]:
            return ConditionModel1

        def build(self) -> "ConditionModel1":
            return ConditionModel1(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            ---
            Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
            useful (see .node.status.conditions), the ability to deconflict is important.
            The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    ---
    Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
    useful (see .node.status.conditions), the ability to deconflict is important.
    The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    """


class Rulecount(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rulecount"]:
            return Rulecount

        def build(self) -> "Rulecount":
            return Rulecount(**self._attrs)

        def generate(self, value: int, /) -> Self:
            """
            Count for generate rules in policy
            """
            return self._set("generate", value)

        def mutate(self, value: int, /) -> Self:
            """
            Count for mutate rules in policy
            """
            return self._set("mutate", value)

        def validate_(self, value: int, /) -> Self:
            """
            Count for validate rules in policy
            """
            return self._set("validate_", value)

        def verifyimages(self, value: int, /) -> Self:
            """
            Count for verify image rules in policy
            """
            return self._set("verifyimages", value)

    class BuilderContext(BuilderContextBase["Rulecount.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rulecount.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rulecount."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rulecount", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rulecount.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    generate: int
    """
    Count for generate rules in policy
    """
    mutate: int
    """
    Count for mutate rules in policy
    """
    validate_: Annotated[int, Field(alias="validate")]
    """
    Count for validate rules in policy
    """
    verifyimages: int
    """
    Count for verify image rules in policy
    """


class Validatingadmissionpolicy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Validatingadmissionpolicy"]:
            return Validatingadmissionpolicy

        def build(self) -> "Validatingadmissionpolicy":
            return Validatingadmissionpolicy(**self._attrs)

        def generated(self, value: bool, /) -> Self:
            """
            Generated indicates whether a validating admission policy is generated from the policy or not
            """
            return self._set("generated", value)

        def message(self, value: str, /) -> Self:
            """
            Message is a human readable message indicating details about the generation of validating admission policy
            It is an empty string when validating admission policy is successfully generated.
            """
            return self._set("message", value)

    class BuilderContext(BuilderContextBase["Validatingadmissionpolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Validatingadmissionpolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Validatingadmissionpolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Validatingadmissionpolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Validatingadmissionpolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    generated: bool
    """
    Generated indicates whether a validating admission policy is generated from the policy or not
    """
    message: str
    """
    Message is a human readable message indicating details about the generation of validating admission policy
    It is an empty string when validating admission policy is successfully generated.
    """


class ClusterPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterPolicyStatus"]:
            return ClusterPolicyStatus

        def build(self) -> "ClusterPolicyStatus":
            return ClusterPolicyStatus(**self._attrs)

        @overload
        def autogen(
            self, value_or_callback: Optional[Autogen], /
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def autogen(
            self,
            value_or_callback: Callable[[Autogen.Builder], Autogen.Builder | Autogen],
            /,
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def autogen(self, value_or_callback: Never = ...) -> "Autogen.BuilderContext": ...

        def autogen(self, value_or_callback=None, /):
            """
            AutogenStatus contains autogen status information.
            """
            if self._in_context and value_or_callback is None:
                context = Autogen.BuilderContext()
                context._parent_builder = self
                context._field_name = "autogen"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Autogen.builder())
                if isinstance(output, Autogen.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("autogen", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel1], /
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel1, ConditionModel1.Builder]],
                GenericListBuilder[ConditionModel1, ConditionModel1.Builder]
                | List[ConditionModel1],
            ],
            /,
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel1.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel1.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def ready(self, value: bool, /) -> Self:
            """
            Deprecated in favor of Conditions
            """
            return self._set("ready", value)

        @overload
        def rulecount(
            self, value_or_callback: Optional[Rulecount], /
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def rulecount(
            self,
            value_or_callback: Callable[[Rulecount.Builder], Rulecount.Builder | Rulecount],
            /,
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def rulecount(self, value_or_callback: Never = ...) -> "Rulecount.BuilderContext": ...

        def rulecount(self, value_or_callback=None, /):
            """
            RuleCountStatus contains four variables which describes counts for
            validate, generate, mutate and verify images rules
            """
            if self._in_context and value_or_callback is None:
                context = Rulecount.BuilderContext()
                context._parent_builder = self
                context._field_name = "rulecount"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rulecount.builder())
                if isinstance(output, Rulecount.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rulecount", value)

        @overload
        def validatingadmissionpolicy(
            self, value_or_callback: Optional[Validatingadmissionpolicy], /
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def validatingadmissionpolicy(
            self,
            value_or_callback: Callable[
                [Validatingadmissionpolicy.Builder],
                Validatingadmissionpolicy.Builder | Validatingadmissionpolicy,
            ],
            /,
        ) -> "ClusterPolicyStatus.Builder": ...

        @overload
        def validatingadmissionpolicy(
            self, value_or_callback: Never = ...
        ) -> "Validatingadmissionpolicy.BuilderContext": ...

        def validatingadmissionpolicy(self, value_or_callback=None, /):
            """
            ValidatingAdmissionPolicy contains status information
            """
            if self._in_context and value_or_callback is None:
                context = Validatingadmissionpolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "validatingadmissionpolicy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Validatingadmissionpolicy.builder())
                if isinstance(output, Validatingadmissionpolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("validatingadmissionpolicy", value)

    class BuilderContext(BuilderContextBase["ClusterPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    autogen: Optional[Autogen] = None
    """
    AutogenStatus contains autogen status information.
    """
    conditions: Optional[List[ConditionModel1]] = None
    ready: bool
    """
    Deprecated in favor of Conditions
    """
    rulecount: Optional[Rulecount] = None
    """
    RuleCountStatus contains four variables which describes counts for
    validate, generate, mutate and verify images rules
    """
    validatingadmissionpolicy: Optional[Validatingadmissionpolicy] = None
    """
    ValidatingAdmissionPolicy contains status information
    """


class AllModel8(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel8"]:
            return AllModel8

        def build(self) -> "AllModel8":
            return AllModel8(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel8.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel8.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel8.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel8.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel8.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel8.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel8."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel8", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel8.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel9(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel9"]:
            return AnyModel9

        def build(self) -> "AnyModel9":
            return AnyModel9(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel9.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel9.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel9.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel9.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel9.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel9."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel9", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel9.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class ExcludeModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel3"]:
            return ExcludeModel3

        def build(self) -> "ExcludeModel3":
            return ExcludeModel3(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel8], /) -> "ExcludeModel3.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel8, AllModel8.Builder]],
                GenericListBuilder[AllModel8, AllModel8.Builder] | List[AllModel8],
            ],
            /,
        ) -> "ExcludeModel3.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel8.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel8.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel8.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel9], /) -> "ExcludeModel3.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel9, AnyModel9.Builder]],
                GenericListBuilder[AnyModel9, AnyModel9.Builder] | List[AnyModel9],
            ],
            /,
        ) -> "ExcludeModel3.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel9.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel9.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel9.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["ExcludeModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel8]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel9]] = None
    """
    Any allows specifying resources which will be ORed
    """


class MatchModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel1"]:
            return MatchModel1

        def build(self) -> "MatchModel1":
            return MatchModel1(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel8], /) -> "MatchModel1.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel8, AllModel8.Builder]],
                GenericListBuilder[AllModel8, AllModel8.Builder] | List[AllModel8],
            ],
            /,
        ) -> "MatchModel1.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel8.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel8.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel8.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel9], /) -> "MatchModel1.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel9, AnyModel9.Builder]],
                GenericListBuilder[AnyModel9, AnyModel9.Builder] | List[AnyModel9],
            ],
            /,
        ) -> "MatchModel1.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel9.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel9.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel9.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["MatchModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel8]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel9]] = None
    """
    Any allows specifying resources which will be ORed
    """


class AllModel9(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel9"]:
            return AllModel9

        def build(self) -> "AllModel9":
            return AllModel9(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel9.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel9.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel9."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel9", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel9.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel10(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel10"]:
            return AnyModel10

        def build(self) -> "AnyModel10":
            return AnyModel10(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel10.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel10."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel10", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel10.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class ForeachModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel3"]:
            return ForeachModel3

        def build(self) -> "ForeachModel3":
            return ForeachModel3(**self._attrs)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel3.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel3.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def order(self, value: Optional[Literal["Ascending", "Descending"]], /) -> Self:
            """
            Order defines the iteration order on the list.
            Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
            """
            return self._set("order", value)

        def patch_strategic_merge(self, value: Optional[Any], /) -> Self:
            """
            PatchStrategicMerge is a strategic merge patch used to modify resources.
            See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
            and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
            """
            return self._set("patch_strategic_merge", value)

        def patches_json6902(self, value: Optional[str], /) -> Self:
            """
            PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
            See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
            """
            return self._set("patches_json6902", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel1], /
        ) -> "ForeachModel3.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel1.Builder],
                PreconditionsModel1.Builder | PreconditionsModel1,
            ],
            /,
        ) -> "ForeachModel3.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel1.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel1.builder())
                if isinstance(output, PreconditionsModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    order: Optional[Literal["Ascending", "Descending"]] = None
    """
    Order defines the iteration order on the list.
    Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
    """
    patch_strategic_merge: Annotated[Optional[Any], Field(alias="patchStrategicMerge")] = None
    """
    PatchStrategicMerge is a strategic merge patch used to modify resources.
    See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
    and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
    """
    patches_json6902: Annotated[Optional[str], Field(alias="patchesJson6902")] = None
    """
    PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
    See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
    """
    preconditions: Optional[PreconditionsModel1] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class AllModel10(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel10"]:
            return AllModel10

        def build(self) -> "AllModel10":
            return AllModel10(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel10.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel10.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel10."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel10", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel10.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel11(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel11"]:
            return AnyModel11

        def build(self) -> "AnyModel11":
            return AnyModel11(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel11.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel11.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel11."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel11", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel11.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class PreconditionsModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreconditionsModel2"]:
            return PreconditionsModel2

        def build(self) -> "PreconditionsModel2":
            return PreconditionsModel2(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel10], /) -> "PreconditionsModel2.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel10, AllModel10.Builder]],
                GenericListBuilder[AllModel10, AllModel10.Builder] | List[AllModel10],
            ],
            /,
        ) -> "PreconditionsModel2.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel10.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel10.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel10.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel11], /) -> "PreconditionsModel2.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel11, AnyModel11.Builder]],
                GenericListBuilder[AnyModel11, AnyModel11.Builder] | List[AnyModel11],
            ],
            /,
        ) -> "PreconditionsModel2.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel11.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel11.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel11.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["PreconditionsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PreconditionsModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreconditionsModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PreconditionsModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreconditionsModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel10]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass.
    """
    any: Optional[List[AnyModel11]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass.
    """


class VariableModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel4"]:
            return VariableModel4

        def build(self) -> "VariableModel4":
            return VariableModel4(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression is the expression that will be evaluated as the value of the variable.
            The CEL expression has access to the same identifiers as the CEL expressions in Validation.
            """
            return self._set("expression", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
            The variable can be accessed in other expressions through `variables`
            For example, if name is "foo", the variable will be available as `variables.foo`
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["VariableModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression is the expression that will be evaluated as the value of the variable.
    The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    """
    name: str
    """
    Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    The variable can be accessed in other expressions through `variables`
    For example, if name is "foo", the variable will be available as `variables.foo`
    """


class DenyModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DenyModel1"]:
            return DenyModel1

        def build(self) -> "DenyModel1":
            return DenyModel1(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "DenyModel1.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "DenyModel1.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Multiple conditions can be declared under an `any` or `all` statement.
            See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["DenyModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DenyModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DenyModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DenyModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DenyModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Conditions] = None
    """
    Multiple conditions can be declared under an `any` or `all` statement.
    See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
    """


class VariableModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel5"]:
            return VariableModel5

        def build(self) -> "VariableModel5":
            return VariableModel5(**self._attrs)

        def default(self, value: Optional[Any], /) -> Self:
            """
            Default is an optional arbitrary JSON object that the variable may take if the JMESPath
            expression evaluates to nil
            """
            return self._set("default", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath Expression that can be used to
            transform the variable.
            """
            return self._set("jmes_path", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is any arbitrary JSON object representable in YAML or JSON form.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["VariableModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default: Optional[Any] = None
    """
    Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    expression evaluates to nil
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath Expression that can be used to
    transform the variable.
    """
    value: Optional[Any] = None
    """
    Value is any arbitrary JSON object representable in YAML or JSON form.
    """


class DenyModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DenyModel2"]:
            return DenyModel2

        def build(self) -> "DenyModel2":
            return DenyModel2(**self._attrs)

        def conditions(self, value: Optional[Any], /) -> Self:
            """
            Multiple conditions can be declared under an `any` or `all` statement. A direct list
            of conditions (without `any` or `all` statements) is also supported for backwards compatibility
            but will be deprecated in the next major release.
            See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
            """
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["DenyModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DenyModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DenyModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DenyModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DenyModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Any] = None
    """
    Multiple conditions can be declared under an `any` or `all` statement. A direct list
    of conditions (without `any` or `all` statements) is also supported for backwards compatibility
    but will be deprecated in the next major release.
    See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
    """


class AllModel11(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel11"]:
            return AllModel11

        def build(self) -> "AllModel11":
            return AllModel11(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel11.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel11.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel11."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel11", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel11.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel12(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel12"]:
            return AnyModel12

        def build(self) -> "AnyModel12":
            return AnyModel12(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel12.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel12.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel12."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel12", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel12.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class PreconditionsModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PreconditionsModel3"]:
            return PreconditionsModel3

        def build(self) -> "PreconditionsModel3":
            return PreconditionsModel3(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel11], /) -> "PreconditionsModel3.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel11, AllModel11.Builder]],
                GenericListBuilder[AllModel11, AllModel11.Builder] | List[AllModel11],
            ],
            /,
        ) -> "PreconditionsModel3.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel11.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel11.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel11.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel12], /) -> "PreconditionsModel3.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel12, AnyModel12.Builder]],
                GenericListBuilder[AnyModel12, AnyModel12.Builder] | List[AnyModel12],
            ],
            /,
        ) -> "PreconditionsModel3.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel12.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel12.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel12.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["PreconditionsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PreconditionsModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PreconditionsModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PreconditionsModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PreconditionsModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel11]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass
    """
    any: Optional[List[AnyModel12]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass
    """


class ForeachModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel4"]:
            return ForeachModel4

        def build(self) -> "ForeachModel4":
            return ForeachModel4(**self._attrs)

        def any_pattern(self, value: Optional[Any], /) -> Self:
            """
            AnyPattern specifies list of validation patterns. At least one of the patterns
            must be satisfied for the validation rule to succeed.
            """
            return self._set("any_pattern", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel4.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel4.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def deny(self, value_or_callback: Optional[DenyModel2], /) -> "ForeachModel4.Builder": ...

        @overload
        def deny(
            self,
            value_or_callback: Callable[[DenyModel2.Builder], DenyModel2.Builder | DenyModel2],
            /,
        ) -> "ForeachModel4.Builder": ...

        @overload
        def deny(self, value_or_callback: Never = ...) -> "DenyModel2.BuilderContext": ...

        def deny(self, value_or_callback=None, /):
            """
            Deny defines conditions used to pass or fail a validation rule.
            """
            if self._in_context and value_or_callback is None:
                context = DenyModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "deny"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DenyModel2.builder())
                if isinstance(output, DenyModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("deny", value)

        def element_scope(self, value: Optional[bool], /) -> Self:
            """
            ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
            When set to "false", "request.object" is used as the validation scope within the foreach
            block to allow referencing other elements in the subtree.
            """
            return self._set("element_scope", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def pattern(self, value: Optional[Any], /) -> Self:
            """
            Pattern specifies an overlay-style pattern used to check resources.
            """
            return self._set("pattern", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel3], /
        ) -> "ForeachModel4.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel3.Builder],
                PreconditionsModel3.Builder | PreconditionsModel3,
            ],
            /,
        ) -> "ForeachModel4.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel3.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel3.builder())
                if isinstance(output, PreconditionsModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any_pattern: Annotated[Optional[Any], Field(alias="anyPattern")] = None
    """
    AnyPattern specifies list of validation patterns. At least one of the patterns
    must be satisfied for the validation rule to succeed.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    deny: Optional[DenyModel2] = None
    """
    Deny defines conditions used to pass or fail a validation rule.
    """
    element_scope: Annotated[Optional[bool], Field(alias="elementScope")] = None
    """
    ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
    When set to "false", "request.object" is used as the validation scope within the foreach
    block to allow referencing other elements in the subtree.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    pattern: Optional[Any] = None
    """
    Pattern specifies an overlay-style pattern used to check resources.
    """
    preconditions: Optional[PreconditionsModel3] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class ExcludeModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel4"]:
            return ExcludeModel4

        def build(self) -> "ExcludeModel4":
            return ExcludeModel4(**self._attrs)

        def control_name(
            self,
            value: Literal[
                "HostProcess",
                "Host Namespaces",
                "Privileged Containers",
                "Capabilities",
                "HostPath Volumes",
                "Host Ports",
                "AppArmor",
                "SELinux",
                "/proc Mount Type",
                "Seccomp",
                "Sysctls",
                "Volume Types",
                "Privilege Escalation",
                "Running as Non-root",
                "Running as Non-root user",
            ],
            /,
        ) -> Self:
            """
            ControlName specifies the name of the Pod Security Standard control.
            See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
            """
            return self._set("control_name", value)

        def images(self, value: Optional[List[str]], /) -> Self:
            """
            Images selects matching containers and applies the container level PSS.
            Each image is the image name consisting of the registry address, repository, image, and tag.
            Empty list matches no containers, PSS checks are applied at the pod level only.
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("images", value)

        def restricted_field(self, value: Optional[str], /) -> Self:
            """
            RestrictedField selects the field for the given Pod Security Standard control.
            When not set, all restricted fields for the control are selected.
            """
            return self._set("restricted_field", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Values defines the allowed values that can be excluded.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["ExcludeModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(alias="controlName"),
    ]
    """
    ControlName specifies the name of the Pod Security Standard control.
    See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
    """
    images: Optional[List[str]] = None
    """
    Images selects matching containers and applies the container level PSS.
    Each image is the image name consisting of the registry address, repository, image, and tag.
    Empty list matches no containers, PSS checks are applied at the pod level only.
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    restricted_field: Annotated[Optional[str], Field(alias="restrictedField")] = None
    """
    RestrictedField selects the field for the given Pod Security Standard control.
    When not set, all restricted fields for the control are selected.
    """
    values: Optional[List[str]] = None
    """
    Values defines the allowed values that can be excluded.
    """


class ConditionModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel2"]:
            return ConditionModel2

        def build(self) -> "ConditionModel2":
            return ConditionModel2(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel11], /) -> "ConditionModel2.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel11, AllModel11.Builder]],
                GenericListBuilder[AllModel11, AllModel11.Builder] | List[AllModel11],
            ],
            /,
        ) -> "ConditionModel2.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel11.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel11.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel11.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel12], /) -> "ConditionModel2.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel12, AnyModel12.Builder]],
                GenericListBuilder[AnyModel12, AnyModel12.Builder] | List[AnyModel12],
            ],
            /,
        ) -> "ConditionModel2.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel12.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel12.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel12.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["ConditionModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel11]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass
    """
    any: Optional[List[AnyModel12]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass
    """


class VerifyImageModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VerifyImageModel1"]:
            return VerifyImageModel1

        def build(self) -> "VerifyImageModel1":
            return VerifyImageModel1(**self._attrs)

        @overload
        def attestations(
            self, value_or_callback: List[Attestation], /
        ) -> "VerifyImageModel1.Builder": ...

        @overload
        def attestations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestation, Attestation.Builder]],
                GenericListBuilder[Attestation, Attestation.Builder] | List[Attestation],
            ],
            /,
        ) -> "VerifyImageModel1.Builder": ...

        @overload
        def attestations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestation.Builder]: ...

        def attestations(self, value_or_callback=None, /):
            """
            Attestations are optional checks for signed in-toto Statements used to verify the image.
            See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
            OCI registry and decodes them into a list of Statement declarations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestation.Builder]()
                context._parent_builder = self
                context._field_name = "attestations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestation.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestations", value)

        @overload
        def attestors(
            self, value_or_callback: List[Attestor], /
        ) -> "VerifyImageModel1.Builder": ...

        @overload
        def attestors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestor, Attestor.Builder]],
                GenericListBuilder[Attestor, Attestor.Builder] | List[Attestor],
            ],
            /,
        ) -> "VerifyImageModel1.Builder": ...

        @overload
        def attestors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestor.Builder]: ...

        def attestors(self, value_or_callback=None, /):
            """
            Attestors specified the required attestors (i.e. authorities)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestor.Builder]()
                context._parent_builder = self
                context._field_name = "attestors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestors", value)

        def image_references(self, value: Optional[List[str]], /) -> Self:
            """
            ImageReferences is a list of matching image reference patterns. At least one pattern in the
            list must match the image for the rule to apply. Each image reference consists of a registry
            address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("image_references", value)

        @overload
        def image_registry_credentials(
            self, value_or_callback: Optional[ImageRegistryCredentials], /
        ) -> "VerifyImageModel1.Builder": ...

        @overload
        def image_registry_credentials(
            self,
            value_or_callback: Callable[
                [ImageRegistryCredentials.Builder],
                ImageRegistryCredentials.Builder | ImageRegistryCredentials,
            ],
            /,
        ) -> "VerifyImageModel1.Builder": ...

        @overload
        def image_registry_credentials(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistryCredentials.BuilderContext": ...

        def image_registry_credentials(self, value_or_callback=None, /):
            """
            ImageRegistryCredentials provides credentials that will be used for authentication with registry
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistryCredentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry_credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistryCredentials.builder())
                if isinstance(output, ImageRegistryCredentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry_credentials", value)

        def mutate_digest(self, value: Optional[bool], /) -> Self:
            """
            MutateDigest enables replacement of image tags with digests.
            Defaults to true.
            """
            return self._set("mutate_digest", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
            If specified Repository will override the default OCI image repository configured for the installation.
            The repository can also be overridden per Attestor or Attestation.
            """
            return self._set("repository", value)

        def required(self, value: Optional[bool], /) -> Self:
            """
            Required validates that images are verified i.e. have matched passed a signature or attestation check.
            """
            return self._set("required", value)

        def skip_image_references(self, value: Optional[List[str]], /) -> Self:
            """
            SkipImageReferences is a list of matching image reference patterns that should be skipped.
            At least one pattern in the list must match the image for the rule to be skipped. Each image reference
            consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("skip_image_references", value)

        def type(self, value: Optional[Literal["Cosign", "Notary"]], /) -> Self:
            """
            Type specifies the method of signature validation. The allowed options
            are Cosign and Notary. By default Cosign is used if a type is not specified.
            """
            return self._set("type", value)

        def use_cache(self, value: Optional[bool], /) -> Self:
            """
            UseCache enables caching of image verify responses for this rule
            """
            return self._set("use_cache", value)

        def verify_digest(self, value: Optional[bool], /) -> Self:
            """
            VerifyDigest validates that images have a digest.
            """
            return self._set("verify_digest", value)

    class BuilderContext(BuilderContextBase["VerifyImageModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VerifyImageModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VerifyImageModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VerifyImageModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyImageModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attestations: Optional[List[Attestation]] = None
    """
    Attestations are optional checks for signed in-toto Statements used to verify the image.
    See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
    OCI registry and decodes them into a list of Statement declarations.
    """
    attestors: Optional[List[Attestor]] = None
    """
    Attestors specified the required attestors (i.e. authorities)
    """
    image_references: Annotated[Optional[List[str]], Field(alias="imageReferences")] = None
    """
    ImageReferences is a list of matching image reference patterns. At least one pattern in the
    list must match the image for the rule to apply. Each image reference consists of a registry
    address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials], Field(alias="imageRegistryCredentials")
    ] = None
    """
    ImageRegistryCredentials provides credentials that will be used for authentication with registry
    """
    mutate_digest: Annotated[Optional[bool], Field(alias="mutateDigest")] = True
    """
    MutateDigest enables replacement of image tags with digests.
    Defaults to true.
    """
    repository: Optional[str] = None
    """
    Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
    If specified Repository will override the default OCI image repository configured for the installation.
    The repository can also be overridden per Attestor or Attestation.
    """
    required: Optional[bool] = True
    """
    Required validates that images are verified i.e. have matched passed a signature or attestation check.
    """
    skip_image_references: Annotated[Optional[List[str]], Field(alias="skipImageReferences")] = None
    """
    SkipImageReferences is a list of matching image reference patterns that should be skipped.
    At least one pattern in the list must match the image for the rule to be skipped. Each image reference
    consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    type: Optional[Literal["Cosign", "Notary"]] = None
    """
    Type specifies the method of signature validation. The allowed options
    are Cosign and Notary. By default Cosign is used if a type is not specified.
    """
    use_cache: Annotated[Optional[bool], Field(alias="useCache")] = True
    """
    UseCache enables caching of image verify responses for this rule
    """
    verify_digest: Annotated[Optional[bool], Field(alias="verifyDigest")] = True
    """
    VerifyDigest validates that images have a digest.
    """


class RuleModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuleModel1"]:
            return RuleModel1

        def build(self) -> "RuleModel1":
            return RuleModel1(**self._attrs)

        @overload
        def cel_preconditions(
            self, value_or_callback: List[CelPrecondition], /
        ) -> "RuleModel1.Builder": ...

        @overload
        def cel_preconditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CelPrecondition, CelPrecondition.Builder]],
                GenericListBuilder[CelPrecondition, CelPrecondition.Builder]
                | List[CelPrecondition],
            ],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def cel_preconditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CelPrecondition.Builder]: ...

        def cel_preconditions(self, value_or_callback=None, /):
            """
            CELPreconditions are used to determine if a policy rule should be applied by evaluating a
            set of CEL conditions. It can only be used with the validate.cel subrule
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CelPrecondition.Builder]()
                context._parent_builder = self
                context._field_name = "cel_preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CelPrecondition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cel_preconditions", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "RuleModel1.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(
            self, value_or_callback: Optional[ExcludeModel3], /
        ) -> "RuleModel1.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[
                [ExcludeModel3.Builder], ExcludeModel3.Builder | ExcludeModel3
            ],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "ExcludeModel3.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when this policy rule should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = ExcludeModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludeModel3.builder())
                if isinstance(output, ExcludeModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def generate(self, value_or_callback: Optional[Generate], /) -> "RuleModel1.Builder": ...

        @overload
        def generate(
            self,
            value_or_callback: Callable[[Generate.Builder], Generate.Builder | Generate],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def generate(self, value_or_callback: Never = ...) -> "Generate.BuilderContext": ...

        def generate(self, value_or_callback=None, /):
            """
            Generation is used to create new resources.
            """
            if self._in_context and value_or_callback is None:
                context = Generate.BuilderContext()
                context._parent_builder = self
                context._field_name = "generate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Generate.builder())
                if isinstance(output, Generate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generate", value)

        def image_extractors(self, value: Optional[Dict[str, List[ImageExtractor]]], /) -> Self:
            """
            ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
            This config is only valid for verifyImages rules.
            """
            return self._set("image_extractors", value)

        @overload
        def match(self, value_or_callback: Optional[MatchModel1], /) -> "RuleModel1.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[[MatchModel1.Builder], MatchModel1.Builder | MatchModel1],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "MatchModel1.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when this policy rule should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = MatchModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel1.builder())
                if isinstance(output, MatchModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def mutate(self, value_or_callback: Optional[Mutate], /) -> "RuleModel1.Builder": ...

        @overload
        def mutate(
            self,
            value_or_callback: Callable[[Mutate.Builder], Mutate.Builder | Mutate],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def mutate(self, value_or_callback: Never = ...) -> "Mutate.BuilderContext": ...

        def mutate(self, value_or_callback=None, /):
            """
            Mutation is used to modify matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Mutate.BuilderContext()
                context._parent_builder = self
                context._field_name = "mutate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mutate.builder())
                if isinstance(output, Mutate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mutate", value)

        def name(self, value: str, /) -> Self:
            """
            Name is a label to identify the rule, It must be unique within the policy.
            """
            return self._set("name", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel2], /
        ) -> "RuleModel1.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel2.Builder],
                PreconditionsModel2.Builder | PreconditionsModel2,
            ],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel2.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            Preconditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel2.builder())
                if isinstance(output, PreconditionsModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

        def skip_background_requests(self, value: Optional[bool], /) -> Self:
            """
            SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
            The default value is set to "true", it must be set to "false" to apply
            generate and mutateExisting rules to those requests.
            """
            return self._set("skip_background_requests", value)

        @overload
        def validate_(self, value_or_callback: Optional[Validate], /) -> "RuleModel1.Builder": ...

        @overload
        def validate_(
            self,
            value_or_callback: Callable[[Validate.Builder], Validate.Builder | Validate],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def validate_(self, value_or_callback: Never = ...) -> "Validate.BuilderContext": ...

        def validate_(self, value_or_callback=None, /):
            """
            Validation is used to validate matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Validate.BuilderContext()
                context._parent_builder = self
                context._field_name = "validate_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Validate.builder())
                if isinstance(output, Validate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("validate_", value)

        @overload
        def verify_images(
            self, value_or_callback: List[VerifyImageModel1], /
        ) -> "RuleModel1.Builder": ...

        @overload
        def verify_images(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VerifyImageModel1, VerifyImageModel1.Builder]],
                GenericListBuilder[VerifyImageModel1, VerifyImageModel1.Builder]
                | List[VerifyImageModel1],
            ],
            /,
        ) -> "RuleModel1.Builder": ...

        @overload
        def verify_images(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VerifyImageModel1.Builder]: ...

        def verify_images(self, value_or_callback=None, /):
            """
            VerifyImages is used to verify image signatures and mutate them to add a digest
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VerifyImageModel1.Builder]()
                context._parent_builder = self
                context._field_name = "verify_images"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VerifyImageModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify_images", value)

    class BuilderContext(BuilderContextBase["RuleModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuleModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuleModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuleModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuleModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cel_preconditions: Annotated[
        Optional[List[CelPrecondition]], Field(alias="celPreconditions")
    ] = None
    """
    CELPreconditions are used to determine if a policy rule should be applied by evaluating a
    set of CEL conditions. It can only be used with the validate.cel subrule
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[ExcludeModel3] = None
    """
    ExcludeResources defines when this policy rule should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    generate: Optional[Generate] = None
    """
    Generation is used to create new resources.
    """
    image_extractors: Annotated[
        Optional[Dict[str, List[ImageExtractor]]], Field(alias="imageExtractors")
    ] = None
    """
    ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
    This config is only valid for verifyImages rules.
    """
    match: Optional[MatchModel1] = None
    """
    MatchResources defines when this policy rule should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    mutate: Optional[Mutate] = None
    """
    Mutation is used to modify matching resources.
    """
    name: Annotated[str, Field(max_length=63)]
    """
    Name is a label to identify the rule, It must be unique within the policy.
    """
    preconditions: Optional[PreconditionsModel2] = None
    """
    Preconditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """
    skip_background_requests: Annotated[Optional[bool], Field(alias="skipBackgroundRequests")] = (
        True
    )
    """
    SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
    The default value is set to "true", it must be set to "false" to apply
    generate and mutateExisting rules to those requests.
    """
    validate_: Annotated[Optional[Validate], Field(alias="validate")] = None
    """
    Validation is used to validate matching resources.
    """
    verify_images: Annotated[Optional[List[VerifyImageModel1]], Field(alias="verifyImages")] = None
    """
    VerifyImages is used to verify image signatures and mutate them to add a digest
    """


class PolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicySpec"]:
            return PolicySpec

        def build(self) -> "PolicySpec":
            return PolicySpec(**self._attrs)

        def admission(self, value: Optional[bool], /) -> Self:
            """
            Admission controls if rules are applied during admission.
            Optional. Default value is "true".
            """
            return self._set("admission", value)

        def apply_rules(self, value: Optional[Literal["All", "One"]], /) -> Self:
            """
            ApplyRules controls how rules in a policy are applied. Rule are processed in
            the order of declaration. When set to `One` processing stops after a rule has
            been applied i.e. the rule matches and results in a pass, fail, or error. When
            set to `All` all rules in the policy are processed. The default is `All`.
            """
            return self._set("apply_rules", value)

        def background(self, value: Optional[bool], /) -> Self:
            """
            Background controls if rules are applied to existing resources during a background scan.
            Optional. Default value is "true". The value must be set to "false" if the policy rule
            uses variables that are only available in the admission review request (e.g. user name).
            """
            return self._set("background", value)

        def failure_policy(self, value: Optional[Literal["Ignore", "Fail"]], /) -> Self:
            """
            FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
            Rules within the same policy share the same failure behavior.
            Allowed values are Ignore or Fail. Defaults to Fail.
            """
            return self._set("failure_policy", value)

        def generate_existing(self, value: Optional[bool], /) -> Self:
            """
            GenerateExisting controls whether to trigger generate rule in existing resources
            If is set to "true" generate rule will be triggered and applied to existing matched resources.
            Defaults to "false" if not specified.
            """
            return self._set("generate_existing", value)

        def generate_existing_on_policy_update(self, value: Optional[bool], /) -> Self:
            """
            Deprecated, use generateExisting instead
            """
            return self._set("generate_existing_on_policy_update", value)

        def mutate_existing_on_policy_update(self, value: Optional[bool], /) -> Self:
            """
            MutateExistingOnPolicyUpdate controls if a mutateExisting policy is applied on policy events.
            Default value is "false".
            """
            return self._set("mutate_existing_on_policy_update", value)

        @overload
        def rules(self, value_or_callback: List[RuleModel1], /) -> "PolicySpec.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RuleModel1, RuleModel1.Builder]],
                GenericListBuilder[RuleModel1, RuleModel1.Builder] | List[RuleModel1],
            ],
            /,
        ) -> "PolicySpec.Builder": ...

        @overload
        def rules(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RuleModel1.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            Rules is a list of Rule instances. A Policy contains multiple rules and
            each rule can validate, mutate, or generate resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RuleModel1.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RuleModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

        def schema_validation(self, value: Optional[bool], /) -> Self:
            """
            Deprecated.
            """
            return self._set("schema_validation", value)

        def use_server_side_apply(self, value: Optional[bool], /) -> Self:
            """
            UseServerSideApply controls whether to use server-side apply for generate rules
            If is set to "true" create & update for generate rules will use apply instead of create/update.
            Defaults to "false" if not specified.
            """
            return self._set("use_server_side_apply", value)

        def validation_failure_action(
            self, value: Optional[Literal["audit", "enforce", "Audit", "Enforce"]], /
        ) -> Self:
            """
            ValidationFailureAction defines if a validation policy rule violation should block
            the admission review request (enforce), or allow (audit) the admission review request
            and report an error in a policy report. Optional.
            Allowed values are audit or enforce. The default value is "Audit".
            """
            return self._set("validation_failure_action", value)

        @overload
        def validation_failure_action_overrides(
            self, value_or_callback: List[ValidationFailureActionOverride], /
        ) -> "PolicySpec.Builder": ...

        @overload
        def validation_failure_action_overrides(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ValidationFailureActionOverride,
                        ValidationFailureActionOverride.Builder,
                    ]
                ],
                GenericListBuilder[
                    ValidationFailureActionOverride,
                    ValidationFailureActionOverride.Builder,
                ]
                | List[ValidationFailureActionOverride],
            ],
            /,
        ) -> "PolicySpec.Builder": ...

        @overload
        def validation_failure_action_overrides(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ValidationFailureActionOverride.Builder]: ...

        def validation_failure_action_overrides(self, value_or_callback=None, /):
            """
            ValidationFailureActionOverrides is a Cluster Policy attribute that specifies ValidationFailureAction
            namespace-wise. It overrides ValidationFailureAction for the specified namespaces.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ValidationFailureActionOverride.Builder]()
                context._parent_builder = self
                context._field_name = "validation_failure_action_overrides"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValidationFailureActionOverride.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("validation_failure_action_overrides", value)

        @overload
        def webhook_configuration(
            self, value_or_callback: Optional[WebhookConfiguration], /
        ) -> "PolicySpec.Builder": ...

        @overload
        def webhook_configuration(
            self,
            value_or_callback: Callable[
                [WebhookConfiguration.Builder],
                WebhookConfiguration.Builder | WebhookConfiguration,
            ],
            /,
        ) -> "PolicySpec.Builder": ...

        @overload
        def webhook_configuration(
            self, value_or_callback: Never = ...
        ) -> "WebhookConfiguration.BuilderContext": ...

        def webhook_configuration(self, value_or_callback=None, /):
            """
            WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
            Requires Kubernetes 1.27 or later.
            """
            if self._in_context and value_or_callback is None:
                context = WebhookConfiguration.BuilderContext()
                context._parent_builder = self
                context._field_name = "webhook_configuration"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(WebhookConfiguration.builder())
                if isinstance(output, WebhookConfiguration.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("webhook_configuration", value)

        def webhook_timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            WebhookTimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
            After the configured time expires, the admission request may fail, or may simply ignore the policy results,
            based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
            """
            return self._set("webhook_timeout_seconds", value)

    class BuilderContext(BuilderContextBase["PolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    admission: Optional[bool] = True
    """
    Admission controls if rules are applied during admission.
    Optional. Default value is "true".
    """
    apply_rules: Annotated[Optional[Literal["All", "One"]], Field(alias="applyRules")] = None
    """
    ApplyRules controls how rules in a policy are applied. Rule are processed in
    the order of declaration. When set to `One` processing stops after a rule has
    been applied i.e. the rule matches and results in a pass, fail, or error. When
    set to `All` all rules in the policy are processed. The default is `All`.
    """
    background: Optional[bool] = True
    """
    Background controls if rules are applied to existing resources during a background scan.
    Optional. Default value is "true". The value must be set to "false" if the policy rule
    uses variables that are only available in the admission review request (e.g. user name).
    """
    failure_policy: Annotated[Optional[Literal["Ignore", "Fail"]], Field(alias="failurePolicy")] = (
        None
    )
    """
    FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled.
    Rules within the same policy share the same failure behavior.
    Allowed values are Ignore or Fail. Defaults to Fail.
    """
    generate_existing: Annotated[Optional[bool], Field(alias="generateExisting")] = None
    """
    GenerateExisting controls whether to trigger generate rule in existing resources
    If is set to "true" generate rule will be triggered and applied to existing matched resources.
    Defaults to "false" if not specified.
    """
    generate_existing_on_policy_update: Annotated[
        Optional[bool], Field(alias="generateExistingOnPolicyUpdate")
    ] = None
    """
    Deprecated, use generateExisting instead
    """
    mutate_existing_on_policy_update: Annotated[
        Optional[bool], Field(alias="mutateExistingOnPolicyUpdate")
    ] = None
    """
    MutateExistingOnPolicyUpdate controls if a mutateExisting policy is applied on policy events.
    Default value is "false".
    """
    rules: Optional[List[RuleModel1]] = None
    """
    Rules is a list of Rule instances. A Policy contains multiple rules and
    each rule can validate, mutate, or generate resources.
    """
    schema_validation: Annotated[Optional[bool], Field(alias="schemaValidation")] = None
    """
    Deprecated.
    """
    use_server_side_apply: Annotated[Optional[bool], Field(alias="useServerSideApply")] = None
    """
    UseServerSideApply controls whether to use server-side apply for generate rules
    If is set to "true" create & update for generate rules will use apply instead of create/update.
    Defaults to "false" if not specified.
    """
    validation_failure_action: Annotated[
        Optional[Literal["audit", "enforce", "Audit", "Enforce"]],
        Field(alias="validationFailureAction"),
    ] = "Audit"
    """
    ValidationFailureAction defines if a validation policy rule violation should block
    the admission review request (enforce), or allow (audit) the admission review request
    and report an error in a policy report. Optional.
    Allowed values are audit or enforce. The default value is "Audit".
    """
    validation_failure_action_overrides: Annotated[
        Optional[List[ValidationFailureActionOverride]],
        Field(alias="validationFailureActionOverrides"),
    ] = None
    """
    ValidationFailureActionOverrides is a Cluster Policy attribute that specifies ValidationFailureAction
    namespace-wise. It overrides ValidationFailureAction for the specified namespaces.
    """
    webhook_configuration: Annotated[
        Optional[WebhookConfiguration], Field(alias="webhookConfiguration")
    ] = None
    """
    WebhookConfiguration specifies the custom configuration for Kubernetes admission webhookconfiguration.
    Requires Kubernetes 1.27 or later.
    """
    webhook_timeout_seconds: Annotated[Optional[int], Field(alias="webhookTimeoutSeconds")] = None
    """
    WebhookTimeoutSeconds specifies the maximum time in seconds allowed to apply this policy.
    After the configured time expires, the admission request may fail, or may simply ignore the policy results,
    based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
    """


class AllModel12(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel12"]:
            return AllModel12

        def build(self) -> "AllModel12":
            return AllModel12(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel12.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel12.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel12.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel12.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel12.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel12.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel12."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel12", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel12.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel13(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel13"]:
            return AnyModel13

        def build(self) -> "AnyModel13":
            return AnyModel13(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel13.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel13.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel13.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel13.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel13.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel13.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel13."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel13", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel13.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class ExcludeModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel5"]:
            return ExcludeModel5

        def build(self) -> "ExcludeModel5":
            return ExcludeModel5(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel12], /) -> "ExcludeModel5.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel12, AllModel12.Builder]],
                GenericListBuilder[AllModel12, AllModel12.Builder] | List[AllModel12],
            ],
            /,
        ) -> "ExcludeModel5.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel12.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel12.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel12.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel13], /) -> "ExcludeModel5.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel13, AnyModel13.Builder]],
                GenericListBuilder[AnyModel13, AnyModel13.Builder] | List[AnyModel13],
            ],
            /,
        ) -> "ExcludeModel5.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel13.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel13.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel13.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(
            self, value_or_callback: Optional[Resources], /
        ) -> "ExcludeModel5.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "ExcludeModel5.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            Requires at least one tag to be specified when under MatchResources.
            Specifying ResourceDescription directly under match is being deprecated.
            Please specify under "any" or "all" instead.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "ExcludeModel5.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "ExcludeModel5.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["ExcludeModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel12]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel13]] = None
    """
    Any allows specifying resources which will be ORed
    """
    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    Requires at least one tag to be specified when under MatchResources.
    Specifying ResourceDescription directly under match is being deprecated.
    Please specify under "any" or "all" instead.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class MatchModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel2"]:
            return MatchModel2

        def build(self) -> "MatchModel2":
            return MatchModel2(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel12], /) -> "MatchModel2.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel12, AllModel12.Builder]],
                GenericListBuilder[AllModel12, AllModel12.Builder] | List[AllModel12],
            ],
            /,
        ) -> "MatchModel2.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel12.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel12.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel12.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel13], /) -> "MatchModel2.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel13, AnyModel13.Builder]],
                GenericListBuilder[AnyModel13, AnyModel13.Builder] | List[AnyModel13],
            ],
            /,
        ) -> "MatchModel2.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel13.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel13.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel13.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "MatchModel2.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "MatchModel2.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            Requires at least one tag to be specified when under MatchResources.
            Specifying ResourceDescription directly under match is being deprecated.
            Please specify under "any" or "all" instead.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "MatchModel2.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "MatchModel2.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["MatchModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel12]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel13]] = None
    """
    Any allows specifying resources which will be ORed
    """
    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    Requires at least one tag to be specified when under MatchResources.
    Specifying ResourceDescription directly under match is being deprecated.
    Please specify under "any" or "all" instead.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AllModel13(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel13"]:
            return AllModel13

        def build(self) -> "AllModel13":
            return AllModel13(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel13.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel13.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel13."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel13", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel13.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel14(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel14"]:
            return AnyModel14

        def build(self) -> "AnyModel14":
            return AnyModel14(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "In",
                    "AnyIn",
                    "AllIn",
                    "NotIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel14.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel14.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel14."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel14", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel14.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "In",
            "AnyIn",
            "AllIn",
            "NotIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class ForeachModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel5"]:
            return ForeachModel5

        def build(self) -> "ForeachModel5":
            return ForeachModel5(**self._attrs)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel5.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel5.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def order(self, value: Optional[Literal["Ascending", "Descending"]], /) -> Self:
            """
            Order defines the iteration order on the list.
            Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
            """
            return self._set("order", value)

        def patch_strategic_merge(self, value: Optional[Any], /) -> Self:
            """
            PatchStrategicMerge is a strategic merge patch used to modify resources.
            See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
            and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
            """
            return self._set("patch_strategic_merge", value)

        def patches_json6902(self, value: Optional[str], /) -> Self:
            """
            PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
            See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
            """
            return self._set("patches_json6902", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel3], /
        ) -> "ForeachModel5.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel3.Builder],
                PreconditionsModel3.Builder | PreconditionsModel3,
            ],
            /,
        ) -> "ForeachModel5.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel3.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel3.builder())
                if isinstance(output, PreconditionsModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    order: Optional[Literal["Ascending", "Descending"]] = None
    """
    Order defines the iteration order on the list.
    Can be Ascending to iterate from first to last element or Descending to iterate in from last to first element.
    """
    patch_strategic_merge: Annotated[Optional[Any], Field(alias="patchStrategicMerge")] = None
    """
    PatchStrategicMerge is a strategic merge patch used to modify resources.
    See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/
    and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
    """
    patches_json6902: Annotated[Optional[str], Field(alias="patchesJson6902")] = None
    """
    PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources.
    See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
    """
    preconditions: Optional[PreconditionsModel3] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class VariableModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel6"]:
            return VariableModel6

        def build(self) -> "VariableModel6":
            return VariableModel6(**self._attrs)

        def expression(self, value: str, /) -> Self:
            """
            Expression is the expression that will be evaluated as the value of the variable.
            The CEL expression has access to the same identifiers as the CEL expressions in Validation.
            """
            return self._set("expression", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
            The variable can be accessed in other expressions through `variables`
            For example, if name is "foo", the variable will be available as `variables.foo`
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["VariableModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    expression: str
    """
    Expression is the expression that will be evaluated as the value of the variable.
    The CEL expression has access to the same identifiers as the CEL expressions in Validation.
    """
    name: str
    """
    Name is the name of the variable. The name must be a valid CEL identifier and unique among all variables.
    The variable can be accessed in other expressions through `variables`
    For example, if name is "foo", the variable will be available as `variables.foo`
    """


class VariableModel7(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VariableModel7"]:
            return VariableModel7

        def build(self) -> "VariableModel7":
            return VariableModel7(**self._attrs)

        def default(self, value: Optional[Any], /) -> Self:
            """
            Default is an optional arbitrary JSON object that the variable may take if the JMESPath
            expression evaluates to nil
            """
            return self._set("default", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath Expression that can be used to
            transform the variable.
            """
            return self._set("jmes_path", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is any arbitrary JSON object representable in YAML or JSON form.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["VariableModel7.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VariableModel7.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VariableModel7."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VariableModel7", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VariableModel7.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default: Optional[Any] = None
    """
    Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    expression evaluates to nil
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath Expression that can be used to
    transform the variable.
    """
    value: Optional[Any] = None
    """
    Value is any arbitrary JSON object representable in YAML or JSON form.
    """


class ForeachModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForeachModel6"]:
            return ForeachModel6

        def build(self) -> "ForeachModel6":
            return ForeachModel6(**self._attrs)

        def any_pattern(self, value: Optional[Any], /) -> Self:
            """
            AnyPattern specifies list of validation patterns. At least one of the patterns
            must be satisfied for the validation rule to succeed.
            """
            return self._set("any_pattern", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "ForeachModel6.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ForeachModel6.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def deny(self, value_or_callback: Optional[DenyModel2], /) -> "ForeachModel6.Builder": ...

        @overload
        def deny(
            self,
            value_or_callback: Callable[[DenyModel2.Builder], DenyModel2.Builder | DenyModel2],
            /,
        ) -> "ForeachModel6.Builder": ...

        @overload
        def deny(self, value_or_callback: Never = ...) -> "DenyModel2.BuilderContext": ...

        def deny(self, value_or_callback=None, /):
            """
            Deny defines conditions used to pass or fail a validation rule.
            """
            if self._in_context and value_or_callback is None:
                context = DenyModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "deny"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DenyModel2.builder())
                if isinstance(output, DenyModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("deny", value)

        def element_scope(self, value: Optional[bool], /) -> Self:
            """
            ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
            When set to "false", "request.object" is used as the validation scope within the foreach
            block to allow referencing other elements in the subtree.
            """
            return self._set("element_scope", value)

        def foreach(self, value: Optional[Any], /) -> Self:
            """
            Foreach declares a nested foreach iterator
            """
            return self._set("foreach", value)

        def list(self, value: Optional[str], /) -> Self:
            """
            List specifies a JMESPath expression that results in one or more elements
            to which the validation logic is applied.
            """
            return self._set("list", value)

        def pattern(self, value: Optional[Any], /) -> Self:
            """
            Pattern specifies an overlay-style pattern used to check resources.
            """
            return self._set("pattern", value)

        @overload
        def preconditions(
            self, value_or_callback: Optional[PreconditionsModel3], /
        ) -> "ForeachModel6.Builder": ...

        @overload
        def preconditions(
            self,
            value_or_callback: Callable[
                [PreconditionsModel3.Builder],
                PreconditionsModel3.Builder | PreconditionsModel3,
            ],
            /,
        ) -> "ForeachModel6.Builder": ...

        @overload
        def preconditions(
            self, value_or_callback: Never = ...
        ) -> "PreconditionsModel3.BuilderContext": ...

        def preconditions(self, value_or_callback=None, /):
            """
            AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            if self._in_context and value_or_callback is None:
                context = PreconditionsModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PreconditionsModel3.builder())
                if isinstance(output, PreconditionsModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("preconditions", value)

    class BuilderContext(BuilderContextBase["ForeachModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForeachModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForeachModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForeachModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForeachModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    any_pattern: Annotated[Optional[Any], Field(alias="anyPattern")] = None
    """
    AnyPattern specifies list of validation patterns. At least one of the patterns
    must be satisfied for the validation rule to succeed.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    deny: Optional[DenyModel2] = None
    """
    Deny defines conditions used to pass or fail a validation rule.
    """
    element_scope: Annotated[Optional[bool], Field(alias="elementScope")] = None
    """
    ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified.
    When set to "false", "request.object" is used as the validation scope within the foreach
    block to allow referencing other elements in the subtree.
    """
    foreach: Optional[Any] = None
    """
    Foreach declares a nested foreach iterator
    """
    list: Optional[str] = None
    """
    List specifies a JMESPath expression that results in one or more elements
    to which the validation logic is applied.
    """
    pattern: Optional[Any] = None
    """
    Pattern specifies an overlay-style pattern used to check resources.
    """
    preconditions: Optional[PreconditionsModel3] = None
    """
    AnyAllConditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """


class ExcludeModel6(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ExcludeModel6"]:
            return ExcludeModel6

        def build(self) -> "ExcludeModel6":
            return ExcludeModel6(**self._attrs)

        def control_name(
            self,
            value: Literal[
                "HostProcess",
                "Host Namespaces",
                "Privileged Containers",
                "Capabilities",
                "HostPath Volumes",
                "Host Ports",
                "AppArmor",
                "SELinux",
                "/proc Mount Type",
                "Seccomp",
                "Sysctls",
                "Volume Types",
                "Privilege Escalation",
                "Running as Non-root",
                "Running as Non-root user",
            ],
            /,
        ) -> Self:
            """
            ControlName specifies the name of the Pod Security Standard control.
            See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
            """
            return self._set("control_name", value)

        def images(self, value: Optional[List[str]], /) -> Self:
            """
            Images selects matching containers and applies the container level PSS.
            Each image is the image name consisting of the registry address, repository, image, and tag.
            Empty list matches no containers, PSS checks are applied at the pod level only.
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("images", value)

        def restricted_field(self, value: Optional[str], /) -> Self:
            """
            RestrictedField selects the field for the given Pod Security Standard control.
            When not set, all restricted fields for the control are selected.
            """
            return self._set("restricted_field", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Values defines the allowed values that can be excluded.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["ExcludeModel6.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ExcludeModel6.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ExcludeModel6."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ExcludeModel6", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ExcludeModel6.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(alias="controlName"),
    ]
    """
    ControlName specifies the name of the Pod Security Standard control.
    See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
    """
    images: Optional[List[str]] = None
    """
    Images selects matching containers and applies the container level PSS.
    Each image is the image name consisting of the registry address, repository, image, and tag.
    Empty list matches no containers, PSS checks are applied at the pod level only.
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    restricted_field: Annotated[Optional[str], Field(alias="restrictedField")] = None
    """
    RestrictedField selects the field for the given Pod Security Standard control.
    When not set, all restricted fields for the control are selected.
    """
    values: Optional[List[str]] = None
    """
    Values defines the allowed values that can be excluded.
    """


class VerifyImageModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VerifyImageModel2"]:
            return VerifyImageModel2

        def build(self) -> "VerifyImageModel2":
            return VerifyImageModel2(**self._attrs)

        def additional_extensions(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Deprecated.
            """
            return self._set("additional_extensions", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Deprecated. Use annotations per Attestor instead.
            """
            return self._set("annotations", value)

        @overload
        def attestations(
            self, value_or_callback: List[Attestation], /
        ) -> "VerifyImageModel2.Builder": ...

        @overload
        def attestations(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestation, Attestation.Builder]],
                GenericListBuilder[Attestation, Attestation.Builder] | List[Attestation],
            ],
            /,
        ) -> "VerifyImageModel2.Builder": ...

        @overload
        def attestations(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestation.Builder]: ...

        def attestations(self, value_or_callback=None, /):
            """
            Attestations are optional checks for signed in-toto Statements used to verify the image.
            See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
            OCI registry and decodes them into a list of Statement declarations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestation.Builder]()
                context._parent_builder = self
                context._field_name = "attestations"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestation.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestations", value)

        @overload
        def attestors(
            self, value_or_callback: List[Attestor], /
        ) -> "VerifyImageModel2.Builder": ...

        @overload
        def attestors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Attestor, Attestor.Builder]],
                GenericListBuilder[Attestor, Attestor.Builder] | List[Attestor],
            ],
            /,
        ) -> "VerifyImageModel2.Builder": ...

        @overload
        def attestors(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Attestor.Builder]: ...

        def attestors(self, value_or_callback=None, /):
            """
            Attestors specified the required attestors (i.e. authorities)
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Attestor.Builder]()
                context._parent_builder = self
                context._field_name = "attestors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Attestor.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attestors", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use ImageReferences instead.
            """
            return self._set("image", value)

        def image_references(self, value: Optional[List[str]], /) -> Self:
            """
            ImageReferences is a list of matching image reference patterns. At least one pattern in the
            list must match the image for the rule to apply. Each image reference consists of a registry
            address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("image_references", value)

        @overload
        def image_registry_credentials(
            self, value_or_callback: Optional[ImageRegistryCredentials], /
        ) -> "VerifyImageModel2.Builder": ...

        @overload
        def image_registry_credentials(
            self,
            value_or_callback: Callable[
                [ImageRegistryCredentials.Builder],
                ImageRegistryCredentials.Builder | ImageRegistryCredentials,
            ],
            /,
        ) -> "VerifyImageModel2.Builder": ...

        @overload
        def image_registry_credentials(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistryCredentials.BuilderContext": ...

        def image_registry_credentials(self, value_or_callback=None, /):
            """
            ImageRegistryCredentials provides credentials that will be used for authentication with registry.
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistryCredentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry_credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistryCredentials.builder())
                if isinstance(output, ImageRegistryCredentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry_credentials", value)

        def issuer(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use KeylessAttestor instead.
            """
            return self._set("issuer", value)

        def key(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use StaticKeyAttestor instead.
            """
            return self._set("key", value)

        def mutate_digest(self, value: Optional[bool], /) -> Self:
            """
            MutateDigest enables replacement of image tags with digests.
            Defaults to true.
            """
            return self._set("mutate_digest", value)

        def repository(self, value: Optional[str], /) -> Self:
            """
            Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
            If specified Repository will override the default OCI image repository configured for the installation.
            The repository can also be overridden per Attestor or Attestation.
            """
            return self._set("repository", value)

        def required(self, value: Optional[bool], /) -> Self:
            """
            Required validates that images are verified i.e. have matched passed a signature or attestation check.
            """
            return self._set("required", value)

        def roots(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use KeylessAttestor instead.
            """
            return self._set("roots", value)

        def skip_image_references(self, value: Optional[List[str]], /) -> Self:
            """
            SkipImageReferences is a list of matching image reference patterns that should be skipped.
            At least one pattern in the list must match the image for the rule to be skipped. Each image reference
            consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("skip_image_references", value)

        def subject(self, value: Optional[str], /) -> Self:
            """
            Deprecated. Use KeylessAttestor instead.
            """
            return self._set("subject", value)

        def type(self, value: Optional[Literal["Cosign", "Notary"]], /) -> Self:
            """
            Type specifies the method of signature validation. The allowed options
            are Cosign and Notary. By default Cosign is used if a type is not specified.
            """
            return self._set("type", value)

        def use_cache(self, value: Optional[bool], /) -> Self:
            """
            UseCache enables caching of image verify responses for this rule.
            """
            return self._set("use_cache", value)

        def verify_digest(self, value: Optional[bool], /) -> Self:
            """
            VerifyDigest validates that images have a digest.
            """
            return self._set("verify_digest", value)

    class BuilderContext(BuilderContextBase["VerifyImageModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VerifyImageModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VerifyImageModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VerifyImageModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyImageModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_extensions: Annotated[
        Optional[Dict[str, str]], Field(alias="additionalExtensions")
    ] = None
    """
    Deprecated.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Deprecated. Use annotations per Attestor instead.
    """
    attestations: Optional[List[Attestation]] = None
    """
    Attestations are optional checks for signed in-toto Statements used to verify the image.
    See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the
    OCI registry and decodes them into a list of Statement declarations.
    """
    attestors: Optional[List[Attestor]] = None
    """
    Attestors specified the required attestors (i.e. authorities)
    """
    image: Optional[str] = None
    """
    Deprecated. Use ImageReferences instead.
    """
    image_references: Annotated[Optional[List[str]], Field(alias="imageReferences")] = None
    """
    ImageReferences is a list of matching image reference patterns. At least one pattern in the
    list must match the image for the rule to apply. Each image reference consists of a registry
    address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials], Field(alias="imageRegistryCredentials")
    ] = None
    """
    ImageRegistryCredentials provides credentials that will be used for authentication with registry.
    """
    issuer: Optional[str] = None
    """
    Deprecated. Use KeylessAttestor instead.
    """
    key: Optional[str] = None
    """
    Deprecated. Use StaticKeyAttestor instead.
    """
    mutate_digest: Annotated[Optional[bool], Field(alias="mutateDigest")] = True
    """
    MutateDigest enables replacement of image tags with digests.
    Defaults to true.
    """
    repository: Optional[str] = None
    """
    Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule.
    If specified Repository will override the default OCI image repository configured for the installation.
    The repository can also be overridden per Attestor or Attestation.
    """
    required: Optional[bool] = True
    """
    Required validates that images are verified i.e. have matched passed a signature or attestation check.
    """
    roots: Optional[str] = None
    """
    Deprecated. Use KeylessAttestor instead.
    """
    skip_image_references: Annotated[Optional[List[str]], Field(alias="skipImageReferences")] = None
    """
    SkipImageReferences is a list of matching image reference patterns that should be skipped.
    At least one pattern in the list must match the image for the rule to be skipped. Each image reference
    consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest).
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    subject: Optional[str] = None
    """
    Deprecated. Use KeylessAttestor instead.
    """
    type: Optional[Literal["Cosign", "Notary"]] = None
    """
    Type specifies the method of signature validation. The allowed options
    are Cosign and Notary. By default Cosign is used if a type is not specified.
    """
    use_cache: Annotated[Optional[bool], Field(alias="useCache")] = True
    """
    UseCache enables caching of image verify responses for this rule.
    """
    verify_digest: Annotated[Optional[bool], Field(alias="verifyDigest")] = True
    """
    VerifyDigest validates that images have a digest.
    """


class RuleModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RuleModel2"]:
            return RuleModel2

        def build(self) -> "RuleModel2":
            return RuleModel2(**self._attrs)

        @overload
        def cel_preconditions(
            self, value_or_callback: List[CelPrecondition], /
        ) -> "RuleModel2.Builder": ...

        @overload
        def cel_preconditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[CelPrecondition, CelPrecondition.Builder]],
                GenericListBuilder[CelPrecondition, CelPrecondition.Builder]
                | List[CelPrecondition],
            ],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def cel_preconditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[CelPrecondition.Builder]: ...

        def cel_preconditions(self, value_or_callback=None, /):
            """
            CELPreconditions are used to determine if a policy rule should be applied by evaluating a
            set of CEL conditions. It can only be used with the validate.cel subrule
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[CelPrecondition.Builder]()
                context._parent_builder = self
                context._field_name = "cel_preconditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CelPrecondition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("cel_preconditions", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "RuleModel2.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(
            self, value_or_callback: Optional[ExcludeModel5], /
        ) -> "RuleModel2.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[
                [ExcludeModel5.Builder], ExcludeModel5.Builder | ExcludeModel5
            ],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "ExcludeModel5.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when this policy rule should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = ExcludeModel5.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ExcludeModel5.builder())
                if isinstance(output, ExcludeModel5.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def generate(self, value_or_callback: Optional[Generate], /) -> "RuleModel2.Builder": ...

        @overload
        def generate(
            self,
            value_or_callback: Callable[[Generate.Builder], Generate.Builder | Generate],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def generate(self, value_or_callback: Never = ...) -> "Generate.BuilderContext": ...

        def generate(self, value_or_callback=None, /):
            """
            Generation is used to create new resources.
            """
            if self._in_context and value_or_callback is None:
                context = Generate.BuilderContext()
                context._parent_builder = self
                context._field_name = "generate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Generate.builder())
                if isinstance(output, Generate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generate", value)

        def image_extractors(self, value: Optional[Dict[str, List[ImageExtractor]]], /) -> Self:
            """
            ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
            This config is only valid for verifyImages rules.
            """
            return self._set("image_extractors", value)

        @overload
        def match(self, value_or_callback: Optional[MatchModel2], /) -> "RuleModel2.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[[MatchModel2.Builder], MatchModel2.Builder | MatchModel2],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "MatchModel2.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when this policy rule should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = MatchModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel2.builder())
                if isinstance(output, MatchModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def mutate(self, value_or_callback: Optional[Mutate], /) -> "RuleModel2.Builder": ...

        @overload
        def mutate(
            self,
            value_or_callback: Callable[[Mutate.Builder], Mutate.Builder | Mutate],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def mutate(self, value_or_callback: Never = ...) -> "Mutate.BuilderContext": ...

        def mutate(self, value_or_callback=None, /):
            """
            Mutation is used to modify matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Mutate.BuilderContext()
                context._parent_builder = self
                context._field_name = "mutate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mutate.builder())
                if isinstance(output, Mutate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mutate", value)

        def name(self, value: str, /) -> Self:
            """
            Name is a label to identify the rule, It must be unique within the policy.
            """
            return self._set("name", value)

        def preconditions(self, value: Optional[Any], /) -> Self:
            """
            Preconditions are used to determine if a policy rule should be applied by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
            of conditions (without `any` or `all` statements is supported for backwards compatibility but
            will be deprecated in the next major release.
            See: https://kyverno.io/docs/writing-policies/preconditions/
            """
            return self._set("preconditions", value)

        def skip_background_requests(self, value: Optional[bool], /) -> Self:
            """
            SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
            The default value is set to "true", it must be set to "false" to apply
            generate and mutateExisting rules to those requests.
            """
            return self._set("skip_background_requests", value)

        @overload
        def validate_(self, value_or_callback: Optional[Validate], /) -> "RuleModel2.Builder": ...

        @overload
        def validate_(
            self,
            value_or_callback: Callable[[Validate.Builder], Validate.Builder | Validate],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def validate_(self, value_or_callback: Never = ...) -> "Validate.BuilderContext": ...

        def validate_(self, value_or_callback=None, /):
            """
            Validation is used to validate matching resources.
            """
            if self._in_context and value_or_callback is None:
                context = Validate.BuilderContext()
                context._parent_builder = self
                context._field_name = "validate_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Validate.builder())
                if isinstance(output, Validate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("validate_", value)

        @overload
        def verify_images(
            self, value_or_callback: List[VerifyImageModel2], /
        ) -> "RuleModel2.Builder": ...

        @overload
        def verify_images(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VerifyImageModel2, VerifyImageModel2.Builder]],
                GenericListBuilder[VerifyImageModel2, VerifyImageModel2.Builder]
                | List[VerifyImageModel2],
            ],
            /,
        ) -> "RuleModel2.Builder": ...

        @overload
        def verify_images(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VerifyImageModel2.Builder]: ...

        def verify_images(self, value_or_callback=None, /):
            """
            VerifyImages is used to verify image signatures and mutate them to add a digest
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VerifyImageModel2.Builder]()
                context._parent_builder = self
                context._field_name = "verify_images"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VerifyImageModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify_images", value)

    class BuilderContext(BuilderContextBase["RuleModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RuleModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RuleModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RuleModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RuleModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cel_preconditions: Annotated[
        Optional[List[CelPrecondition]], Field(alias="celPreconditions")
    ] = None
    """
    CELPreconditions are used to determine if a policy rule should be applied by evaluating a
    set of CEL conditions. It can only be used with the validate.cel subrule
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[ExcludeModel5] = None
    """
    ExcludeResources defines when this policy rule should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    generate: Optional[Generate] = None
    """
    Generation is used to create new resources.
    """
    image_extractors: Annotated[
        Optional[Dict[str, List[ImageExtractor]]], Field(alias="imageExtractors")
    ] = None
    """
    ImageExtractors defines a mapping from kinds to ImageExtractorConfigs.
    This config is only valid for verifyImages rules.
    """
    match: Optional[MatchModel2] = None
    """
    MatchResources defines when this policy rule should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    mutate: Optional[Mutate] = None
    """
    Mutation is used to modify matching resources.
    """
    name: Annotated[str, Field(max_length=63)]
    """
    Name is a label to identify the rule, It must be unique within the policy.
    """
    preconditions: Optional[Any] = None
    """
    Preconditions are used to determine if a policy rule should be applied by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements. A direct list
    of conditions (without `any` or `all` statements is supported for backwards compatibility but
    will be deprecated in the next major release.
    See: https://kyverno.io/docs/writing-policies/preconditions/
    """
    skip_background_requests: Annotated[Optional[bool], Field(alias="skipBackgroundRequests")] = (
        True
    )
    """
    SkipBackgroundRequests bypasses admission requests that are sent by the background controller.
    The default value is set to "true", it must be set to "false" to apply
    generate and mutateExisting rules to those requests.
    """
    validate_: Annotated[Optional[Validate], Field(alias="validate")] = None
    """
    Validation is used to validate matching resources.
    """
    verify_images: Annotated[Optional[List[VerifyImageModel2]], Field(alias="verifyImages")] = None
    """
    VerifyImages is used to verify image signatures and mutate them to add a digest
    """


class ConditionModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConditionModel3"]:
            return ConditionModel3

        def build(self) -> "ConditionModel3":
            return ConditionModel3(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            ---
            Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
            useful (see .node.status.conditions), the ability to deconflict is important.
            The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ConditionModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConditionModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConditionModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConditionModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConditionModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    ---
    Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
    useful (see .node.status.conditions), the ability to deconflict is important.
    The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    """


class PolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyStatus"]:
            return PolicyStatus

        def build(self) -> "PolicyStatus":
            return PolicyStatus(**self._attrs)

        @overload
        def autogen(self, value_or_callback: Optional[Autogen], /) -> "PolicyStatus.Builder": ...

        @overload
        def autogen(
            self,
            value_or_callback: Callable[[Autogen.Builder], Autogen.Builder | Autogen],
            /,
        ) -> "PolicyStatus.Builder": ...

        @overload
        def autogen(self, value_or_callback: Never = ...) -> "Autogen.BuilderContext": ...

        def autogen(self, value_or_callback=None, /):
            """
            AutogenStatus contains autogen status information.
            """
            if self._in_context and value_or_callback is None:
                context = Autogen.BuilderContext()
                context._parent_builder = self
                context._field_name = "autogen"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Autogen.builder())
                if isinstance(output, Autogen.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("autogen", value)

        @overload
        def conditions(
            self, value_or_callback: List[ConditionModel3], /
        ) -> "PolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConditionModel3, ConditionModel3.Builder]],
                GenericListBuilder[ConditionModel3, ConditionModel3.Builder]
                | List[ConditionModel3],
            ],
            /,
        ) -> "PolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConditionModel3.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConditionModel3.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConditionModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def ready(self, value: bool, /) -> Self:
            """
            Deprecated in favor of Conditions
            """
            return self._set("ready", value)

        @overload
        def rulecount(
            self, value_or_callback: Optional[Rulecount], /
        ) -> "PolicyStatus.Builder": ...

        @overload
        def rulecount(
            self,
            value_or_callback: Callable[[Rulecount.Builder], Rulecount.Builder | Rulecount],
            /,
        ) -> "PolicyStatus.Builder": ...

        @overload
        def rulecount(self, value_or_callback: Never = ...) -> "Rulecount.BuilderContext": ...

        def rulecount(self, value_or_callback=None, /):
            """
            RuleCountStatus contains four variables which describes counts for
            validate, generate, mutate and verify images rules
            """
            if self._in_context and value_or_callback is None:
                context = Rulecount.BuilderContext()
                context._parent_builder = self
                context._field_name = "rulecount"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rulecount.builder())
                if isinstance(output, Rulecount.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rulecount", value)

        @overload
        def validatingadmissionpolicy(
            self, value_or_callback: Optional[Validatingadmissionpolicy], /
        ) -> "PolicyStatus.Builder": ...

        @overload
        def validatingadmissionpolicy(
            self,
            value_or_callback: Callable[
                [Validatingadmissionpolicy.Builder],
                Validatingadmissionpolicy.Builder | Validatingadmissionpolicy,
            ],
            /,
        ) -> "PolicyStatus.Builder": ...

        @overload
        def validatingadmissionpolicy(
            self, value_or_callback: Never = ...
        ) -> "Validatingadmissionpolicy.BuilderContext": ...

        def validatingadmissionpolicy(self, value_or_callback=None, /):
            """
            ValidatingAdmissionPolicy contains status information
            """
            if self._in_context and value_or_callback is None:
                context = Validatingadmissionpolicy.BuilderContext()
                context._parent_builder = self
                context._field_name = "validatingadmissionpolicy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Validatingadmissionpolicy.builder())
                if isinstance(output, Validatingadmissionpolicy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("validatingadmissionpolicy", value)

    class BuilderContext(BuilderContextBase["PolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    autogen: Optional[Autogen] = None
    """
    AutogenStatus contains autogen status information.
    """
    conditions: Optional[List[ConditionModel3]] = None
    ready: bool
    """
    Deprecated in favor of Conditions
    """
    rulecount: Optional[Rulecount] = None
    """
    RuleCountStatus contains four variables which describes counts for
    validate, generate, mutate and verify images rules
    """
    validatingadmissionpolicy: Optional[Validatingadmissionpolicy] = None
    """
    ValidatingAdmissionPolicy contains status information
    """


class AllModel14(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel14"]:
            return AllModel14

        def build(self) -> "AllModel14":
            return AllModel14(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel14.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel14.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel14."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel14", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel14.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel15(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel15"]:
            return AnyModel15

        def build(self) -> "AnyModel15":
            return AnyModel15(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel15.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel15.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel15."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel15", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel15.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class Exception(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exception"]:
            return Exception

        def build(self) -> "Exception":
            return Exception(**self._attrs)

        def policy_name(self, value: str, /) -> Self:
            """
            PolicyName identifies the policy to which the exception is applied.
            The policy name uses the format <namespace>/<name> unless it
            references a ClusterPolicy.
            """
            return self._set("policy_name", value)

        def rule_names(self, value: List[str], /) -> Self:
            """
            RuleNames identifies the rules to which the exception is applied.
            """
            return self._set("rule_names", value)

    class BuilderContext(BuilderContextBase["Exception.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exception.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exception."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exception", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exception.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    policy_name: Annotated[str, Field(alias="policyName")]
    """
    PolicyName identifies the policy to which the exception is applied.
    The policy name uses the format <namespace>/<name> unless it
    references a ClusterPolicy.
    """
    rule_names: Annotated[List[str], Field(alias="ruleNames")]
    """
    RuleNames identifies the rules to which the exception is applied.
    """


class AllModel15(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel15"]:
            return AllModel15

        def build(self) -> "AllModel15":
            return AllModel15(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel15.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel15.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel15.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel15.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel15.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel15.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel15."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel15", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel15.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel16(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel16"]:
            return AnyModel16

        def build(self) -> "AnyModel16":
            return AnyModel16(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel16.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel16.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel16.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel16.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel16.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel16.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel16."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel16", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel16.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class MatchModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchModel3"]:
            return MatchModel3

        def build(self) -> "MatchModel3":
            return MatchModel3(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel15], /) -> "MatchModel3.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel15, AllModel15.Builder]],
                GenericListBuilder[AllModel15, AllModel15.Builder] | List[AllModel15],
            ],
            /,
        ) -> "MatchModel3.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel15.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel15.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel15.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel16], /) -> "MatchModel3.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel16, AnyModel16.Builder]],
                GenericListBuilder[AnyModel16, AnyModel16.Builder] | List[AnyModel16],
            ],
            /,
        ) -> "MatchModel3.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel16.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel16.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel16.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["MatchModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel15]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel16]] = None
    """
    Any allows specifying resources which will be ORed
    """


class PodSecurityModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodSecurityModel"]:
            return PodSecurityModel

        def build(self) -> "PodSecurityModel":
            return PodSecurityModel(**self._attrs)

        def control_name(
            self,
            value: Literal[
                "HostProcess",
                "Host Namespaces",
                "Privileged Containers",
                "Capabilities",
                "HostPath Volumes",
                "Host Ports",
                "AppArmor",
                "SELinux",
                "/proc Mount Type",
                "Seccomp",
                "Sysctls",
                "Volume Types",
                "Privilege Escalation",
                "Running as Non-root",
                "Running as Non-root user",
            ],
            /,
        ) -> Self:
            """
            ControlName specifies the name of the Pod Security Standard control.
            See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
            """
            return self._set("control_name", value)

        def images(self, value: Optional[List[str]], /) -> Self:
            """
            Images selects matching containers and applies the container level PSS.
            Each image is the image name consisting of the registry address, repository, image, and tag.
            Empty list matches no containers, PSS checks are applied at the pod level only.
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("images", value)

        def restricted_field(self, value: Optional[str], /) -> Self:
            """
            RestrictedField selects the field for the given Pod Security Standard control.
            When not set, all restricted fields for the control are selected.
            """
            return self._set("restricted_field", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Values defines the allowed values that can be excluded.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["PodSecurityModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodSecurityModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodSecurityModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodSecurityModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodSecurityModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(alias="controlName"),
    ]
    """
    ControlName specifies the name of the Pod Security Standard control.
    See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
    """
    images: Optional[List[str]] = None
    """
    Images selects matching containers and applies the container level PSS.
    Each image is the image name consisting of the registry address, repository, image, and tag.
    Empty list matches no containers, PSS checks are applied at the pod level only.
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    restricted_field: Annotated[Optional[str], Field(alias="restrictedField")] = None
    """
    RestrictedField selects the field for the given Pod Security Standard control.
    When not set, all restricted fields for the control are selected.
    """
    values: Optional[List[str]] = None
    """
    Values defines the allowed values that can be excluded.
    """


class PolicyExceptionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyExceptionSpec"]:
            return PolicyExceptionSpec

        def build(self) -> "PolicyExceptionSpec":
            return PolicyExceptionSpec(**self._attrs)

        def background(self, value: Optional[bool], /) -> Self:
            """
            Background controls if exceptions are applied to existing policies during a background scan.
            Optional. Default value is "true". The value must be set to "false" if the policy rule
            uses variables that are only available in the admission review request (e.g. user name).
            """
            return self._set("background", value)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions are used to determine if a resource applies to the exception by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def exceptions(
            self, value_or_callback: List[Exception], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def exceptions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Exception, Exception.Builder]],
                GenericListBuilder[Exception, Exception.Builder] | List[Exception],
            ],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def exceptions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Exception.Builder]: ...

        def exceptions(self, value_or_callback=None, /):
            """
            Exceptions is a list policy/rules to be excluded
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Exception.Builder]()
                context._parent_builder = self
                context._field_name = "exceptions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exception.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("exceptions", value)

        @overload
        def match(self, value_or_callback: MatchModel3, /) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def match(
            self,
            value_or_callback: Callable[[MatchModel3.Builder], MatchModel3.Builder | MatchModel3],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "MatchModel3.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            Match defines match clause used to check if a resource applies to the exception
            """
            if self._in_context and value_or_callback is None:
                context = MatchModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchModel3.builder())
                if isinstance(output, MatchModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def pod_security(
            self, value_or_callback: List[PodSecurityModel], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def pod_security(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PodSecurityModel, PodSecurityModel.Builder]],
                GenericListBuilder[PodSecurityModel, PodSecurityModel.Builder]
                | List[PodSecurityModel],
            ],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def pod_security(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PodSecurityModel.Builder]: ...

        def pod_security(self, value_or_callback=None, /):
            """
            PodSecurity specifies the Pod Security Standard controls to be excluded.
            Applicable only to policies that have validate.podSecurity subrule.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PodSecurityModel.Builder]()
                context._parent_builder = self
                context._field_name = "pod_security"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodSecurityModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_security", value)

    class BuilderContext(BuilderContextBase["PolicyExceptionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyExceptionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyExceptionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyExceptionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyExceptionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    background: Optional[bool] = None
    """
    Background controls if exceptions are applied to existing policies during a background scan.
    Optional. Default value is "true". The value must be set to "false" if the policy rule
    uses variables that are only available in the admission review request (e.g. user name).
    """
    conditions: Optional[Conditions] = None
    """
    Conditions are used to determine if a resource applies to the exception by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    """
    exceptions: List[Exception]
    """
    Exceptions is a list policy/rules to be excluded
    """
    match: MatchModel3
    """
    Match defines match clause used to check if a resource applies to the exception
    """
    pod_security: Annotated[Optional[List[PodSecurityModel]], Field(alias="podSecurity")] = None
    """
    PodSecurity specifies the Pod Security Standard controls to be excluded.
    Applicable only to policies that have validate.podSecurity subrule.
    """


class CleanupPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CleanupPolicy"]:
            return CleanupPolicy

        def build(self) -> "CleanupPolicy":
            return CleanupPolicy(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["CleanupPolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: CleanupPolicySpec, /) -> "CleanupPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CleanupPolicySpec.Builder],
                CleanupPolicySpec.Builder | CleanupPolicySpec,
            ],
            /,
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CleanupPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CleanupPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CleanupPolicySpec.builder())
                if isinstance(output, CleanupPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CleanupPolicyStatus], /
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CleanupPolicyStatus.Builder],
                CleanupPolicyStatus.Builder | CleanupPolicyStatus,
            ],
            /,
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "CleanupPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CleanupPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CleanupPolicyStatus.builder())
                if isinstance(output, CleanupPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["CleanupPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CleanupPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CleanupPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CleanupPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CleanupPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2beta1"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2beta1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["CleanupPolicy"]] = "CleanupPolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: CleanupPolicySpec
    status: Optional[CleanupPolicyStatus] = None


class ClusterCleanupPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCleanupPolicy"]:
            return ClusterCleanupPolicy

        def build(self) -> "ClusterCleanupPolicy":
            return ClusterCleanupPolicy(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterCleanupPolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ClusterCleanupPolicySpec, /
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterCleanupPolicySpec.Builder],
                ClusterCleanupPolicySpec.Builder | ClusterCleanupPolicySpec,
            ],
            /,
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterCleanupPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterCleanupPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterCleanupPolicySpec.builder())
                if isinstance(output, ClusterCleanupPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterCleanupPolicyStatus], /
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterCleanupPolicyStatus.Builder],
                ClusterCleanupPolicyStatus.Builder | ClusterCleanupPolicyStatus,
            ],
            /,
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ClusterCleanupPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterCleanupPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterCleanupPolicyStatus.builder())
                if isinstance(output, ClusterCleanupPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterCleanupPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCleanupPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCleanupPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCleanupPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCleanupPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2beta1"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2beta1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterCleanupPolicy"]] = "ClusterCleanupPolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterCleanupPolicySpec
    status: Optional[ClusterCleanupPolicyStatus] = None


class ClusterPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterPolicy"]:
            return ClusterPolicy

        def build(self) -> "ClusterPolicy":
            return ClusterPolicy(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterPolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ClusterPolicySpec, /) -> "ClusterPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterPolicySpec.Builder],
                ClusterPolicySpec.Builder | ClusterPolicySpec,
            ],
            /,
        ) -> "ClusterPolicy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ClusterPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterPolicySpec.builder())
                if isinstance(output, ClusterPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterPolicyStatus], /
        ) -> "ClusterPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterPolicyStatus.Builder],
                ClusterPolicyStatus.Builder | ClusterPolicyStatus,
            ],
            /,
        ) -> "ClusterPolicy.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ClusterPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterPolicyStatus.builder())
                if isinstance(output, ClusterPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2beta1"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2beta1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterPolicy"]] = "ClusterPolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterPolicySpec
    status: Optional[ClusterPolicyStatus] = None


class Policy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Policy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Policy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PolicySpec, /) -> "Policy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[PolicySpec.Builder], PolicySpec.Builder | PolicySpec],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PolicySpec.builder())
                if isinstance(output, PolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[PolicyStatus], /) -> "Policy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PolicyStatus.Builder], PolicyStatus.Builder | PolicyStatus
            ],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "PolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PolicyStatus.builder())
                if isinstance(output, PolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2beta1"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2beta1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Policy"]] = "Policy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PolicySpec
    status: Optional[PolicyStatus] = None


class PolicyException(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyException"]:
            return PolicyException

        def build(self) -> "PolicyException":
            return PolicyException(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PolicyException"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PolicyException.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PolicyException.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PolicyExceptionSpec, /) -> "PolicyException.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PolicyExceptionSpec.Builder],
                PolicyExceptionSpec.Builder | PolicyExceptionSpec,
            ],
            /,
        ) -> "PolicyException.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PolicyExceptionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PolicyExceptionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PolicyExceptionSpec.builder())
                if isinstance(output, PolicyExceptionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["PolicyException.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyException.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyException."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyException", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyException.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2beta1"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2beta1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PolicyException"]] = "PolicyException"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PolicyExceptionSpec
