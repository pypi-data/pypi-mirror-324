# Generated by cloudcoil-model-codegen v0.4.7
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Owner(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Owner"]:
            return Owner

        def build(self) -> "Owner":
            return Owner(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def block_owner_deletion(self, value: Optional[bool], /) -> Self:
            """
            If true, AND if the owner has the "foregroundDeletion" finalizer, then
            the owner cannot be deleted from the key-value store until this
            reference is removed.
            See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
            for how the garbage collector interacts with this field and enforces the foreground deletion.
            Defaults to false.
            To set this field, a user needs "delete" permission of the owner,
            otherwise 422 (Unprocessable Entity) will be returned.
            """
            return self._set("block_owner_deletion", value)

        def controller(self, value: Optional[bool], /) -> Self:
            """
            If true, this reference points to the managing controller.
            """
            return self._set("controller", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
            """
            return self._set("name", value)

        def uid(self, value: str, /) -> Self:
            """
            UID of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["Owner.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Owner.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Owner."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Owner", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Owner.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    API version of the referent.
    """
    block_owner_deletion: Annotated[Optional[bool], Field(alias="blockOwnerDeletion")] = None
    """
    If true, AND if the owner has the "foregroundDeletion" finalizer, then
    the owner cannot be deleted from the key-value store until this
    reference is removed.
    See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion
    for how the garbage collector interacts with this field and enforces the foreground deletion.
    Defaults to false.
    To set this field, a user needs "delete" permission of the owner,
    otherwise 422 (Unprocessable Entity) will be returned.
    """
    controller: Optional[bool] = None
    """
    If true, this reference points to the managing controller.
    """
    kind: str
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: str
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
    """
    uid: str
    """
    UID of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
    """


class MatchExpression(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchExpression"]:
            return MatchExpression

        def build(self) -> "MatchExpression":
            return MatchExpression(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the label key that the selector applies to.
            """
            return self._set("key", value)

        def operator(self, value: str, /) -> Self:
            """
            operator represents a key's relationship to a set of values.
            Valid operators are In, NotIn, Exists and DoesNotExist.
            """
            return self._set("operator", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            values is an array of string values. If the operator is In or NotIn,
            the values array must be non-empty. If the operator is Exists or DoesNotExist,
            the values array must be empty. This array is replaced during a strategic
            merge patch.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["MatchExpression.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchExpression.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchExpression."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchExpression", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchExpression.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the label key that the selector applies to.
    """
    operator: str
    """
    operator represents a key's relationship to a set of values.
    Valid operators are In, NotIn, Exists and DoesNotExist.
    """
    values: Optional[List[str]] = None
    """
    values is an array of string values. If the operator is In or NotIn,
    the values array must be non-empty. If the operator is Exists or DoesNotExist,
    the values array must be empty. This array is replaced during a strategic
    merge patch.
    """


class ResourceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceSelector"]:
            return ResourceSelector

        def build(self) -> "ResourceSelector":
            return ResourceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "ResourceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "ResourceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["ResourceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string
            should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
            For example, if the object reference is to a container within a pod, this would take on a value like:
            "spec.containers{name}" (where "name" refers to the name of the container that triggered
            the event) or if no container name is specified "spec.containers[2]" (container with
            index 2 in this pod). This syntax is chosen only to have some well-defined way of
            referencing a part of an object.
            TODO: this design is not final and this field is subject to change in the future.
            """
            return self._set("field_path", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string
    should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    For example, if the object reference is to a container within a pod, this would take on a value like:
    "spec.containers{name}" (where "name" refers to the name of the container that triggered
    the event) or if no container name is specified "spec.containers[2]" (container with
    index 2 in this pod). This syntax is chosen only to have some well-defined way of
    referencing a part of an object.
    TODO: this design is not final and this field is subject to change in the future.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """


class Timestamp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Timestamp"]:
            return Timestamp

        def build(self) -> "Timestamp":
            return Timestamp(**self._attrs)

        def nanos(self, value: int, /) -> Self:
            """
            Non-negative fractions of a second at nanosecond resolution. Negative
            second values with fractions must still have non-negative nanos values
            that count forward in time. Must be from 0 to 999,999,999
            inclusive. This field may be limited in precision depending on context.
            """
            return self._set("nanos", value)

        def seconds(self, value: int, /) -> Self:
            """
            Represents seconds of UTC time since Unix epoch
            1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
            9999-12-31T23:59:59Z inclusive.
            """
            return self._set("seconds", value)

    class BuilderContext(BuilderContextBase["Timestamp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Timestamp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Timestamp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Timestamp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Timestamp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    nanos: int
    """
    Non-negative fractions of a second at nanosecond resolution. Negative
    second values with fractions must still have non-negative nanos values
    that count forward in time. Must be from 0 to 999,999,999
    inclusive. This field may be limited in precision depending on context.
    """
    seconds: int
    """
    Represents seconds of UTC time since Unix epoch
    1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    9999-12-31T23:59:59Z inclusive.
    """


class Result(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Result"]:
            return Result

        def build(self) -> "Result":
            return Result(**self._attrs)

        def category(self, value: Optional[str], /) -> Self:
            """
            Category indicates policy category
            """
            return self._set("category", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Description is a short user friendly message for the policy rule
            """
            return self._set("message", value)

        def policy(self, value: str, /) -> Self:
            """
            Policy is the name or identifier of the policy
            """
            return self._set("policy", value)

        def properties(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Properties provides additional information for the policy rule
            """
            return self._set("properties", value)

        @overload
        def resource_selector(
            self, value_or_callback: Optional[ResourceSelector], /
        ) -> "Result.Builder": ...

        @overload
        def resource_selector(
            self,
            value_or_callback: Callable[
                [ResourceSelector.Builder], ResourceSelector.Builder | ResourceSelector
            ],
            /,
        ) -> "Result.Builder": ...

        @overload
        def resource_selector(
            self, value_or_callback: Never = ...
        ) -> "ResourceSelector.BuilderContext": ...

        def resource_selector(self, value_or_callback=None, /):
            """
            SubjectSelector is an optional label selector for checked Kubernetes resources.
            For example, a policy result may apply to all pods that match a label.
            Either a Subject or a SubjectSelector can be specified.
            If neither are provided, the result is assumed to be for the policy report scope.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceSelector.builder())
                if isinstance(output, ResourceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_selector", value)

        @overload
        def resources(self, value_or_callback: List[ResourceModel], /) -> "Result.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "Result.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Subjects is an optional reference to the checked Kubernetes resources
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def result(
            self, value: Optional[Literal["pass", "fail", "warn", "error", "skip"]], /
        ) -> Self:
            """
            Result indicates the outcome of the policy rule execution
            """
            return self._set("result", value)

        def rule(self, value: Optional[str], /) -> Self:
            """
            Rule is the name or identifier of the rule within the policy
            """
            return self._set("rule", value)

        def scored(self, value: Optional[bool], /) -> Self:
            """
            Scored indicates if this result is scored
            """
            return self._set("scored", value)

        def severity(
            self,
            value: Optional[Literal["critical", "high", "low", "medium", "info"]],
            /,
        ) -> Self:
            """
            Severity indicates policy check result criticality
            """
            return self._set("severity", value)

        def source(self, value: Optional[str], /) -> Self:
            """
            Source is an identifier for the policy engine that manages this report
            """
            return self._set("source", value)

        @overload
        def timestamp(self, value_or_callback: Optional[Timestamp], /) -> "Result.Builder": ...

        @overload
        def timestamp(
            self,
            value_or_callback: Callable[[Timestamp.Builder], Timestamp.Builder | Timestamp],
            /,
        ) -> "Result.Builder": ...

        @overload
        def timestamp(self, value_or_callback: Never = ...) -> "Timestamp.BuilderContext": ...

        def timestamp(self, value_or_callback=None, /):
            """
            Timestamp indicates the time the result was found
            """
            if self._in_context and value_or_callback is None:
                context = Timestamp.BuilderContext()
                context._parent_builder = self
                context._field_name = "timestamp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Timestamp.builder())
                if isinstance(output, Timestamp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("timestamp", value)

    class BuilderContext(BuilderContextBase["Result.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Result.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Result."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Result", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Result.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    category: Optional[str] = None
    """
    Category indicates policy category
    """
    message: Optional[str] = None
    """
    Description is a short user friendly message for the policy rule
    """
    policy: str
    """
    Policy is the name or identifier of the policy
    """
    properties: Optional[Dict[str, str]] = None
    """
    Properties provides additional information for the policy rule
    """
    resource_selector: Annotated[Optional[ResourceSelector], Field(alias="resourceSelector")] = None
    """
    SubjectSelector is an optional label selector for checked Kubernetes resources.
    For example, a policy result may apply to all pods that match a label.
    Either a Subject or a SubjectSelector can be specified.
    If neither are provided, the result is assumed to be for the policy report scope.
    """
    resources: Optional[List[ResourceModel]] = None
    """
    Subjects is an optional reference to the checked Kubernetes resources
    """
    result: Optional[Literal["pass", "fail", "warn", "error", "skip"]] = None
    """
    Result indicates the outcome of the policy rule execution
    """
    rule: Optional[str] = None
    """
    Rule is the name or identifier of the rule within the policy
    """
    scored: Optional[bool] = None
    """
    Scored indicates if this result is scored
    """
    severity: Optional[Literal["critical", "high", "low", "medium", "info"]] = None
    """
    Severity indicates policy check result criticality
    """
    source: Optional[str] = None
    """
    Source is an identifier for the policy engine that manages this report
    """
    timestamp: Optional[Timestamp] = None
    """
    Timestamp indicates the time the result was found
    """


class Summary(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Summary"]:
            return Summary

        def build(self) -> "Summary":
            return Summary(**self._attrs)

        def error(self, value: Optional[int], /) -> Self:
            """
            Error provides the count of policies that could not be evaluated
            """
            return self._set("error", value)

        def fail(self, value: Optional[int], /) -> Self:
            """
            Fail provides the count of policies whose requirements were not met
            """
            return self._set("fail", value)

        def pass_(self, value: Optional[int], /) -> Self:
            """
            Pass provides the count of policies whose requirements were met
            """
            return self._set("pass_", value)

        def skip(self, value: Optional[int], /) -> Self:
            """
            Skip indicates the count of policies that were not selected for evaluation
            """
            return self._set("skip", value)

        def warn(self, value: Optional[int], /) -> Self:
            """
            Warn provides the count of non-scored policies whose requirements were not met
            """
            return self._set("warn", value)

    class BuilderContext(BuilderContextBase["Summary.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Summary.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Summary."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Summary", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Summary.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    error: Optional[int] = None
    """
    Error provides the count of policies that could not be evaluated
    """
    fail: Optional[int] = None
    """
    Fail provides the count of policies whose requirements were not met
    """
    pass_: Annotated[Optional[int], Field(alias="pass")] = None
    """
    Pass provides the count of policies whose requirements were met
    """
    skip: Optional[int] = None
    """
    Skip indicates the count of policies that were not selected for evaluation
    """
    warn: Optional[int] = None
    """
    Warn provides the count of non-scored policies whose requirements were not met
    """


class AdmissionReportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdmissionReportSpec"]:
            return AdmissionReportSpec

        def build(self) -> "AdmissionReportSpec":
            return AdmissionReportSpec(**self._attrs)

        @overload
        def owner(self, value_or_callback: Owner, /) -> "AdmissionReportSpec.Builder": ...

        @overload
        def owner(
            self, value_or_callback: Callable[[Owner.Builder], Owner.Builder | Owner], /
        ) -> "AdmissionReportSpec.Builder": ...

        @overload
        def owner(self, value_or_callback: Never = ...) -> "Owner.BuilderContext": ...

        def owner(self, value_or_callback=None, /):
            """
            Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
            """
            if self._in_context and value_or_callback is None:
                context = Owner.BuilderContext()
                context._parent_builder = self
                context._field_name = "owner"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Owner.builder())
                if isinstance(output, Owner.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("owner", value)

        @overload
        def results(self, value_or_callback: List[Result], /) -> "AdmissionReportSpec.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Result, Result.Builder]],
                GenericListBuilder[Result, Result.Builder] | List[Result],
            ],
            /,
        ) -> "AdmissionReportSpec.Builder": ...

        @overload
        def results(self, value_or_callback: Never = ...) -> ListBuilderContext[Result.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            PolicyReportResult provides result details
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Result.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Result.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def summary(
            self, value_or_callback: Optional[Summary], /
        ) -> "AdmissionReportSpec.Builder": ...

        @overload
        def summary(
            self,
            value_or_callback: Callable[[Summary.Builder], Summary.Builder | Summary],
            /,
        ) -> "AdmissionReportSpec.Builder": ...

        @overload
        def summary(self, value_or_callback: Never = ...) -> "Summary.BuilderContext": ...

        def summary(self, value_or_callback=None, /):
            """
            PolicyReportSummary provides a summary of results
            """
            if self._in_context and value_or_callback is None:
                context = Summary.BuilderContext()
                context._parent_builder = self
                context._field_name = "summary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Summary.builder())
                if isinstance(output, Summary.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("summary", value)

    class BuilderContext(BuilderContextBase["AdmissionReportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdmissionReportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdmissionReportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdmissionReportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdmissionReportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    owner: Owner
    """
    Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
    """
    results: Optional[List[Result]] = None
    """
    PolicyReportResult provides result details
    """
    summary: Optional[Summary] = None
    """
    PolicyReportSummary provides a summary of results
    """


class BackgroundScanReportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackgroundScanReportSpec"]:
            return BackgroundScanReportSpec

        def build(self) -> "BackgroundScanReportSpec":
            return BackgroundScanReportSpec(**self._attrs)

        @overload
        def results(
            self, value_or_callback: List[Result], /
        ) -> "BackgroundScanReportSpec.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Result, Result.Builder]],
                GenericListBuilder[Result, Result.Builder] | List[Result],
            ],
            /,
        ) -> "BackgroundScanReportSpec.Builder": ...

        @overload
        def results(self, value_or_callback: Never = ...) -> ListBuilderContext[Result.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            PolicyReportResult provides result details
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Result.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Result.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def summary(
            self, value_or_callback: Optional[Summary], /
        ) -> "BackgroundScanReportSpec.Builder": ...

        @overload
        def summary(
            self,
            value_or_callback: Callable[[Summary.Builder], Summary.Builder | Summary],
            /,
        ) -> "BackgroundScanReportSpec.Builder": ...

        @overload
        def summary(self, value_or_callback: Never = ...) -> "Summary.BuilderContext": ...

        def summary(self, value_or_callback=None, /):
            """
            PolicyReportSummary provides a summary of results
            """
            if self._in_context and value_or_callback is None:
                context = Summary.BuilderContext()
                context._parent_builder = self
                context._field_name = "summary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Summary.builder())
                if isinstance(output, Summary.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("summary", value)

    class BuilderContext(BuilderContextBase["BackgroundScanReportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackgroundScanReportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackgroundScanReportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackgroundScanReportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackgroundScanReportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    results: Optional[List[Result]] = None
    """
    PolicyReportResult provides result details
    """
    summary: Optional[Summary] = None
    """
    PolicyReportSummary provides a summary of results
    """


class All(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["All"]:
            return All

        def build(self) -> "All":
            return All(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["All.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = All.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for All."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["All", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use All.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel"]:
            return AnyModel

        def build(self) -> "AnyModel":
            return AnyModel(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class Conditions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Conditions"]:
            return Conditions

        def build(self) -> "Conditions":
            return Conditions(**self._attrs)

        @overload
        def all(self, value_or_callback: List[All], /) -> "Conditions.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[All, All.Builder]],
                GenericListBuilder[All, All.Builder] | List[All],
            ],
            /,
        ) -> "Conditions.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[All.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            AllConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, all of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[All.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(All.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel], /) -> "Conditions.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel, AnyModel.Builder]],
                GenericListBuilder[AnyModel, AnyModel.Builder] | List[AnyModel],
            ],
            /,
        ) -> "Conditions.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            AnyConditions enable variable-based conditional rule execution. This is useful for
            finer control of when an rule is applied. A condition can reference object data
            using JMESPath notation.
            Here, at least one of the conditions need to pass.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Conditions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Conditions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Conditions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Conditions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Conditions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[All]] = None
    """
    AllConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, all of the conditions need to pass.
    """
    any: Optional[List[AnyModel]] = None
    """
    AnyConditions enable variable-based conditional rule execution. This is useful for
    finer control of when an rule is applied. A condition can reference object data
    using JMESPath notation.
    Here, at least one of the conditions need to pass.
    """


class Datum(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Datum"]:
            return Datum

        def build(self) -> "Datum":
            return Datum(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            Key is a unique identifier for the data value
            """
            return self._set("key", value)

        def value(self, value: Any, /) -> Self:
            """
            Value is the data value
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Datum.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Datum.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Datum."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Datum", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Datum.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    Key is a unique identifier for the data value
    """
    value: Any
    """
    Value is the data value
    """


class Service(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

        def ca_bundle(self, value: Optional[str], /) -> Self:
            """
            CABundle is a PEM encoded CA bundle which will be used to validate
            the server certificate.
            """
            return self._set("ca_bundle", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the JSON web service URL. A typical form is
            `https://{service}.{namespace}:{port}/{path}`.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_bundle: Annotated[Optional[str], Field(alias="caBundle")] = None
    """
    CABundle is a PEM encoded CA bundle which will be used to validate
    the server certificate.
    """
    url: str
    """
    URL is the JSON web service URL. A typical form is
    `https://{service}.{namespace}:{port}/{path}`.
    """


class ApiCall(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ApiCall"]:
            return ApiCall

        def build(self) -> "ApiCall":
            return ApiCall(**self._attrs)

        @overload
        def data(self, value_or_callback: List[Datum], /) -> "ApiCall.Builder": ...

        @overload
        def data(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Datum, Datum.Builder]],
                GenericListBuilder[Datum, Datum.Builder] | List[Datum],
            ],
            /,
        ) -> "ApiCall.Builder": ...

        @overload
        def data(self, value_or_callback: Never = ...) -> ListBuilderContext[Datum.Builder]: ...

        def data(self, value_or_callback=None, /):
            """
            The data object specifies the POST data sent to the server.
            Only applicable when the method field is set to POST.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Datum.Builder]()
                context._parent_builder = self
                context._field_name = "data"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Datum.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("data", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JSON Match Expression that can be used to
            transform the JSON response returned from the server. For example
            a JMESPath of "items | length(@)" applied to the API server response
            for the URLPath "/apis/apps/v1/deployments" will return the total count
            of deployments across all namespaces.
            """
            return self._set("jmes_path", value)

        def method(self, value: Optional[Literal["GET", "POST"]], /) -> Self:
            """
            Method is the HTTP request type (GET or POST).
            """
            return self._set("method", value)

        @overload
        def service(self, value_or_callback: Optional[Service], /) -> "ApiCall.Builder": ...

        @overload
        def service(
            self,
            value_or_callback: Callable[[Service.Builder], Service.Builder | Service],
            /,
        ) -> "ApiCall.Builder": ...

        @overload
        def service(self, value_or_callback: Never = ...) -> "Service.BuilderContext": ...

        def service(self, value_or_callback=None, /):
            """
            Service is an API call to a JSON web service.
            This is used for non-Kubernetes API server calls.
            It's mutually exclusive with the URLPath field.
            """
            if self._in_context and value_or_callback is None:
                context = Service.BuilderContext()
                context._parent_builder = self
                context._field_name = "service"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Service.builder())
                if isinstance(output, Service.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service", value)

        def url_path(self, value: Optional[str], /) -> Self:
            """
            URLPath is the URL path to be used in the HTTP GET or POST request to the
            Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
            The format required is the same format used by the `kubectl get --raw` command.
            See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
            for details.
            It's mutually exclusive with the Service field.
            """
            return self._set("url_path", value)

    class BuilderContext(BuilderContextBase["ApiCall.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ApiCall.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ApiCall."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ApiCall", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ApiCall.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[List[Datum]] = None
    """
    The data object specifies the POST data sent to the server.
    Only applicable when the method field is set to POST.
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JSON Match Expression that can be used to
    transform the JSON response returned from the server. For example
    a JMESPath of "items | length(@)" applied to the API server response
    for the URLPath "/apis/apps/v1/deployments" will return the total count
    of deployments across all namespaces.
    """
    method: Optional[Literal["GET", "POST"]] = "GET"
    """
    Method is the HTTP request type (GET or POST).
    """
    service: Optional[Service] = None
    """
    Service is an API call to a JSON web service.
    This is used for non-Kubernetes API server calls.
    It's mutually exclusive with the URLPath field.
    """
    url_path: Annotated[Optional[str], Field(alias="urlPath")] = None
    """
    URLPath is the URL path to be used in the HTTP GET or POST request to the
    Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments").
    The format required is the same format used by the `kubectl get --raw` command.
    See https://kyverno.io/docs/writing-policies/external-data-sources/#variables-from-kubernetes-api-server-calls
    for details.
    It's mutually exclusive with the Service field.
    """


class ConfigMap(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMap"]:
            return ConfigMap

        def build(self) -> "ConfigMap":
            return ConfigMap(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is the ConfigMap name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace is the ConfigMap namespace.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ConfigMap.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMap.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMap."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMap", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMap.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name is the ConfigMap name.
    """
    namespace: Optional[str] = None
    """
    Namespace is the ConfigMap namespace.
    """


class GlobalReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GlobalReference"]:
            return GlobalReference

        def build(self) -> "GlobalReference":
            return GlobalReference(**self._attrs)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JSON Match Expression that can be used to
            transform the JSON response returned from the server. For example
            a JMESPath of "items | length(@)" applied to the API server response
            for the URLPath "/apis/apps/v1/deployments" will return the total count
            of deployments across all namespaces.
            """
            return self._set("jmes_path", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the global context entry
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["GlobalReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GlobalReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GlobalReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GlobalReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GlobalReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JSON Match Expression that can be used to
    transform the JSON response returned from the server. For example
    a JMESPath of "items | length(@)" applied to the API server response
    for the URLPath "/apis/apps/v1/deployments" will return the total count
    of deployments across all namespaces.
    """
    name: Optional[str] = None
    """
    Name of the global context entry
    """


class ImageRegistryCredentials(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRegistryCredentials"]:
            return ImageRegistryCredentials

        def build(self) -> "ImageRegistryCredentials":
            return ImageRegistryCredentials(**self._attrs)

        def allow_insecure_registry(self, value: Optional[bool], /) -> Self:
            """
            AllowInsecureRegistry allows insecure access to a registry.
            """
            return self._set("allow_insecure_registry", value)

        def providers(
            self,
            value: Optional[List[Literal["default", "amazon", "azure", "google", "github"]]],
            /,
        ) -> Self:
            """
            Providers specifies a list of OCI Registry names, whose authentication providers are provided.
            It can be of one of these values: default,google,azure,amazon,github.
            """
            return self._set("providers", value)

        def secrets(self, value: Optional[List[str]], /) -> Self:
            """
            Secrets specifies a list of secrets that are provided for credentials.
            Secrets must live in the Kyverno namespace.
            """
            return self._set("secrets", value)

    class BuilderContext(BuilderContextBase["ImageRegistryCredentials.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRegistryCredentials.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRegistryCredentials."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRegistryCredentials", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRegistryCredentials.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_insecure_registry: Annotated[Optional[bool], Field(alias="allowInsecureRegistry")] = None
    """
    AllowInsecureRegistry allows insecure access to a registry.
    """
    providers: Optional[List[Literal["default", "amazon", "azure", "google", "github"]]] = None
    """
    Providers specifies a list of OCI Registry names, whose authentication providers are provided.
    It can be of one of these values: default,google,azure,amazon,github.
    """
    secrets: Optional[List[str]] = None
    """
    Secrets specifies a list of secrets that are provided for credentials.
    Secrets must live in the Kyverno namespace.
    """


class ImageRegistry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImageRegistry"]:
            return ImageRegistry

        def build(self) -> "ImageRegistry":
            return ImageRegistry(**self._attrs)

        @overload
        def image_registry_credentials(
            self, value_or_callback: Optional[ImageRegistryCredentials], /
        ) -> "ImageRegistry.Builder": ...

        @overload
        def image_registry_credentials(
            self,
            value_or_callback: Callable[
                [ImageRegistryCredentials.Builder],
                ImageRegistryCredentials.Builder | ImageRegistryCredentials,
            ],
            /,
        ) -> "ImageRegistry.Builder": ...

        @overload
        def image_registry_credentials(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistryCredentials.BuilderContext": ...

        def image_registry_credentials(self, value_or_callback=None, /):
            """
            ImageRegistryCredentials provides credentials that will be used for authentication with registry
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistryCredentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry_credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistryCredentials.builder())
                if isinstance(output, ImageRegistryCredentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry_credentials", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JSON Match Expression that can be used to
            transform the ImageData struct returned as a result of processing
            the image reference.
            """
            return self._set("jmes_path", value)

        def reference(self, value: str, /) -> Self:
            """
            Reference is image reference to a container image in the registry.
            Example: ghcr.io/kyverno/kyverno:latest
            """
            return self._set("reference", value)

    class BuilderContext(BuilderContextBase["ImageRegistry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImageRegistry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImageRegistry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImageRegistry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImageRegistry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image_registry_credentials: Annotated[
        Optional[ImageRegistryCredentials], Field(alias="imageRegistryCredentials")
    ] = None
    """
    ImageRegistryCredentials provides credentials that will be used for authentication with registry
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JSON Match Expression that can be used to
    transform the ImageData struct returned as a result of processing
    the image reference.
    """
    reference: str
    """
    Reference is image reference to a container image in the registry.
    Example: ghcr.io/kyverno/kyverno:latest
    """


class Variable(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Variable"]:
            return Variable

        def build(self) -> "Variable":
            return Variable(**self._attrs)

        def default(self, value: Optional[Any], /) -> Self:
            """
            Default is an optional arbitrary JSON object that the variable may take if the JMESPath
            expression evaluates to nil
            """
            return self._set("default", value)

        def jmes_path(self, value: Optional[str], /) -> Self:
            """
            JMESPath is an optional JMESPath Expression that can be used to
            transform the variable.
            """
            return self._set("jmes_path", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is any arbitrary JSON object representable in YAML or JSON form.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["Variable.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Variable.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Variable."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Variable", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Variable.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default: Optional[Any] = None
    """
    Default is an optional arbitrary JSON object that the variable may take if the JMESPath
    expression evaluates to nil
    """
    jmes_path: Annotated[Optional[str], Field(alias="jmesPath")] = None
    """
    JMESPath is an optional JMESPath Expression that can be used to
    transform the variable.
    """
    value: Optional[Any] = None
    """
    Value is any arbitrary JSON object representable in YAML or JSON form.
    """


class Context(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Context"]:
            return Context

        def build(self) -> "Context":
            return Context(**self._attrs)

        @overload
        def api_call(self, value_or_callback: Optional[ApiCall], /) -> "Context.Builder": ...

        @overload
        def api_call(
            self,
            value_or_callback: Callable[[ApiCall.Builder], ApiCall.Builder | ApiCall],
            /,
        ) -> "Context.Builder": ...

        @overload
        def api_call(self, value_or_callback: Never = ...) -> "ApiCall.BuilderContext": ...

        def api_call(self, value_or_callback=None, /):
            """
            APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
            The data returned is stored in the context with the name for the context entry.
            """
            if self._in_context and value_or_callback is None:
                context = ApiCall.BuilderContext()
                context._parent_builder = self
                context._field_name = "api_call"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ApiCall.builder())
                if isinstance(output, ApiCall.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("api_call", value)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Context.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Context.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            ConfigMap is the ConfigMap reference.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def global_reference(
            self, value_or_callback: Optional[GlobalReference], /
        ) -> "Context.Builder": ...

        @overload
        def global_reference(
            self,
            value_or_callback: Callable[
                [GlobalReference.Builder], GlobalReference.Builder | GlobalReference
            ],
            /,
        ) -> "Context.Builder": ...

        @overload
        def global_reference(
            self, value_or_callback: Never = ...
        ) -> "GlobalReference.BuilderContext": ...

        def global_reference(self, value_or_callback=None, /):
            """
            GlobalContextEntryReference is a reference to a cached global context entry.
            """
            if self._in_context and value_or_callback is None:
                context = GlobalReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "global_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GlobalReference.builder())
                if isinstance(output, GlobalReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("global_reference", value)

        @overload
        def image_registry(
            self, value_or_callback: Optional[ImageRegistry], /
        ) -> "Context.Builder": ...

        @overload
        def image_registry(
            self,
            value_or_callback: Callable[
                [ImageRegistry.Builder], ImageRegistry.Builder | ImageRegistry
            ],
            /,
        ) -> "Context.Builder": ...

        @overload
        def image_registry(
            self, value_or_callback: Never = ...
        ) -> "ImageRegistry.BuilderContext": ...

        def image_registry(self, value_or_callback=None, /):
            """
            ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
            details.
            """
            if self._in_context and value_or_callback is None:
                context = ImageRegistry.BuilderContext()
                context._parent_builder = self
                context._field_name = "image_registry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImageRegistry.builder())
                if isinstance(output, ImageRegistry.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_registry", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the variable name.
            """
            return self._set("name", value)

        @overload
        def variable(self, value_or_callback: Optional[Variable], /) -> "Context.Builder": ...

        @overload
        def variable(
            self,
            value_or_callback: Callable[[Variable.Builder], Variable.Builder | Variable],
            /,
        ) -> "Context.Builder": ...

        @overload
        def variable(self, value_or_callback: Never = ...) -> "Variable.BuilderContext": ...

        def variable(self, value_or_callback=None, /):
            """
            Variable defines an arbitrary JMESPath context variable that can be defined inline.
            """
            if self._in_context and value_or_callback is None:
                context = Variable.BuilderContext()
                context._parent_builder = self
                context._field_name = "variable"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Variable.builder())
                if isinstance(output, Variable.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("variable", value)

    class BuilderContext(BuilderContextBase["Context.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Context.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Context."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Context", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Context.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_call: Annotated[Optional[ApiCall], Field(alias="apiCall")] = None
    """
    APICall is an HTTP request to the Kubernetes API server, or other JSON web service.
    The data returned is stored in the context with the name for the context entry.
    """
    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    ConfigMap is the ConfigMap reference.
    """
    global_reference: Annotated[Optional[GlobalReference], Field(alias="globalReference")] = None
    """
    GlobalContextEntryReference is a reference to a cached global context entry.
    """
    image_registry: Annotated[Optional[ImageRegistry], Field(alias="imageRegistry")] = None
    """
    ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image
    details.
    """
    name: Optional[str] = None
    """
    Name is the variable name.
    """
    variable: Optional[Variable] = None
    """
    Variable defines an arbitrary JMESPath context variable that can be defined inline.
    """


class NamespaceSelector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamespaceSelector"]:
            return NamespaceSelector

        def build(self) -> "NamespaceSelector":
            return NamespaceSelector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "NamespaceSelector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["NamespaceSelector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamespaceSelector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamespaceSelector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamespaceSelector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamespaceSelector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        @overload
        def match_expressions(
            self, value_or_callback: List[MatchExpression], /
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchExpression, MatchExpression.Builder]],
                GenericListBuilder[MatchExpression, MatchExpression.Builder]
                | List[MatchExpression],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_expressions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchExpression.Builder]: ...

        def match_expressions(self, value_or_callback=None, /):
            """
            matchExpressions is a list of label selector requirements. The requirements are ANDed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchExpression.Builder]()
                context._parent_builder = self
                context._field_name = "match_expressions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchExpression.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_expressions", value)

        def match_labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
            map is equivalent to an element of matchExpressions, whose key field is "key", the
            operator is "In", and the values array contains only "value". The requirements are ANDed.
            """
            return self._set("match_labels", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_expressions: Annotated[
        Optional[List[MatchExpression]], Field(alias="matchExpressions")
    ] = None
    """
    matchExpressions is a list of label selector requirements. The requirements are ANDed.
    """
    match_labels: Annotated[Optional[Dict[str, str]], Field(alias="matchLabels")] = None
    """
    matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
    map is equivalent to an element of matchExpressions, whose key field is "key", the
    operator is "In", and the values array contains only "value". The requirements are ANDed.
    """


class Resources(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Resources"]:
            return Resources

        def build(self) -> "Resources":
            return Resources(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
            and values support the wildcard characters "*" (matches zero or many characters) and
            "?" (matches at least one character).
            """
            return self._set("annotations", value)

        def kinds(self, value: Optional[List[str]], /) -> Self:
            """
            Kinds is a list of resource kinds.
            """
            return self._set("kinds", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the name of the resource. The name supports wildcard characters
            "*" (matches zero or many characters) and "?" (at least one character).
            NOTE: "Name" is being deprecated in favor of "Names".
            """
            return self._set("name", value)

        def names(self, value: Optional[List[str]], /) -> Self:
            """
            Names are the names of the resources. Each name supports wildcard characters
            "*" (matches zero or many characters) and "?" (at least one character).
            """
            return self._set("names", value)

        @overload
        def namespace_selector(
            self, value_or_callback: Optional[NamespaceSelector], /
        ) -> "Resources.Builder": ...

        @overload
        def namespace_selector(
            self,
            value_or_callback: Callable[
                [NamespaceSelector.Builder],
                NamespaceSelector.Builder | NamespaceSelector,
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def namespace_selector(
            self, value_or_callback: Never = ...
        ) -> "NamespaceSelector.BuilderContext": ...

        def namespace_selector(self, value_or_callback=None, /):
            """
            NamespaceSelector is a label selector for the resource namespace. Label keys and values
            in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
            and `?` (matches one character).Wildcards allows writing label selectors like
            ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
            does not match an empty label set.
            """
            if self._in_context and value_or_callback is None:
                context = NamespaceSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "namespace_selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamespaceSelector.builder())
                if isinstance(output, NamespaceSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("namespace_selector", value)

        def namespaces(self, value: Optional[List[str]], /) -> Self:
            """
            Namespaces is a list of namespaces names. Each name supports wildcard characters
            "*" (matches zero or many characters) and "?" (at least one character).
            """
            return self._set("namespaces", value)

        def operations(
            self,
            value: Optional[List[Literal["CREATE", "CONNECT", "UPDATE", "DELETE"]]],
            /,
        ) -> Self:
            """
            Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
            """
            return self._set("operations", value)

        @overload
        def selector(self, value_or_callback: Optional[Selector], /) -> "Resources.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
            characters `*` (matches zero or many characters) and `?` (matches one character).
            Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
            using ["*" : "*"] matches any key and value but does not match an empty label set.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["Resources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Resources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Resources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Resources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Resources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is a  map of annotations (key-value pairs of type string). Annotation keys
    and values support the wildcard characters "*" (matches zero or many characters) and
    "?" (matches at least one character).
    """
    kinds: Optional[List[str]] = None
    """
    Kinds is a list of resource kinds.
    """
    name: Optional[str] = None
    """
    Name is the name of the resource. The name supports wildcard characters
    "*" (matches zero or many characters) and "?" (at least one character).
    NOTE: "Name" is being deprecated in favor of "Names".
    """
    names: Optional[List[str]] = None
    """
    Names are the names of the resources. Each name supports wildcard characters
    "*" (matches zero or many characters) and "?" (at least one character).
    """
    namespace_selector: Annotated[Optional[NamespaceSelector], Field(alias="namespaceSelector")] = (
        None
    )
    """
    NamespaceSelector is a label selector for the resource namespace. Label keys and values
    in `matchLabels` support the wildcard characters `*` (matches zero or many characters)
    and `?` (matches one character).Wildcards allows writing label selectors like
    ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but
    does not match an empty label set.
    """
    namespaces: Optional[List[str]] = None
    """
    Namespaces is a list of namespaces names. Each name supports wildcard characters
    "*" (matches zero or many characters) and "?" (at least one character).
    """
    operations: Optional[List[Literal["CREATE", "CONNECT", "UPDATE", "DELETE"]]] = None
    """
    Operations can contain values ["CREATE, "UPDATE", "CONNECT", "DELETE"], which are used to match a specific action.
    """
    selector: Optional[Selector] = None
    """
    Selector is a label selector. Label keys and values in `matchLabels` support the wildcard
    characters `*` (matches zero or many characters) and `?` (matches one character).
    Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that
    using ["*" : "*"] matches any key and value but does not match an empty label set.
    """


class Subject(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subject"]:
            return Subject

        def build(self) -> "Subject":
            return Subject(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup holds the API group of the referenced subject.
            Defaults to "" for ServiceAccount subjects.
            Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
            If the Authorizer does not recognized the kind value, the Authorizer should report an error.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the object being referenced.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
            the Authorizer should report an error.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Subject.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subject.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subject."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subject", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subject.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup holds the API group of the referenced subject.
    Defaults to "" for ServiceAccount subjects.
    Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
    """
    kind: str
    """
    Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
    If the Authorizer does not recognized the kind value, the Authorizer should report an error.
    """
    name: str
    """
    Name of the object being referenced.
    """
    namespace: Optional[str] = None
    """
    Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
    the Authorizer should report an error.
    """


class AllModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel"]:
            return AllModel

        def build(self) -> "AllModel":
            return AllModel(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel1"]:
            return AnyModel1

        def build(self) -> "AnyModel1":
            return AnyModel1(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel1.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel1.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel1.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel1.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class Exclude(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exclude"]:
            return Exclude

        def build(self) -> "Exclude":
            return Exclude(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel], /) -> "Exclude.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel, AllModel.Builder]],
                GenericListBuilder[AllModel, AllModel.Builder] | List[AllModel],
            ],
            /,
        ) -> "Exclude.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel1], /) -> "Exclude.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel1, AnyModel1.Builder]],
                GenericListBuilder[AnyModel1, AnyModel1.Builder] | List[AnyModel1],
            ],
            /,
        ) -> "Exclude.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel1.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel1.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Exclude.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exclude.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exclude."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exclude", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exclude.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel1]] = None
    """
    Any allows specifying resources which will be ORed
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        @overload
        def all(self, value_or_callback: List[AllModel], /) -> "Match.Builder": ...

        @overload
        def all(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AllModel, AllModel.Builder]],
                GenericListBuilder[AllModel, AllModel.Builder] | List[AllModel],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def all(self, value_or_callback: Never = ...) -> ListBuilderContext[AllModel.Builder]: ...

        def all(self, value_or_callback=None, /):
            """
            All allows specifying resources which will be ANDed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AllModel.Builder]()
                context._parent_builder = self
                context._field_name = "all"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("all", value)

        @overload
        def any(self, value_or_callback: List[AnyModel1], /) -> "Match.Builder": ...

        @overload
        def any(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AnyModel1, AnyModel1.Builder]],
                GenericListBuilder[AnyModel1, AnyModel1.Builder] | List[AnyModel1],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def any(self, value_or_callback: Never = ...) -> ListBuilderContext[AnyModel1.Builder]: ...

        def any(self, value_or_callback=None, /):
            """
            Any allows specifying resources which will be ORed
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AnyModel1.Builder]()
                context._parent_builder = self
                context._field_name = "any"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AnyModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("any", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    all: Optional[List[AllModel]] = None
    """
    All allows specifying resources which will be ANDed
    """
    any: Optional[List[AnyModel1]] = None
    """
    Any allows specifying resources which will be ORed
    """


class CleanupPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CleanupPolicySpec"]:
            return CleanupPolicySpec

        def build(self) -> "CleanupPolicySpec":
            return CleanupPolicySpec(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions defines the conditions used to select the resources which will be cleaned up.
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def context(self, value_or_callback: List[Context], /) -> "CleanupPolicySpec.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(
            self, value_or_callback: Optional[Exclude], /
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[[Exclude.Builder], Exclude.Builder | Exclude],
            /,
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "Exclude.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when cleanuppolicy should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = Exclude.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exclude.builder())
                if isinstance(output, Exclude.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def match(self, value_or_callback: Optional[Match], /) -> "CleanupPolicySpec.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "CleanupPolicySpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when cleanuppolicy should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        def schedule(self, value: str, /) -> Self:
            """
            The schedule in Cron format
            """
            return self._set("schedule", value)

    class BuilderContext(BuilderContextBase["CleanupPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CleanupPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CleanupPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CleanupPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CleanupPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Conditions] = None
    """
    Conditions defines the conditions used to select the resources which will be cleaned up.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[Exclude] = None
    """
    ExcludeResources defines when cleanuppolicy should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    match: Optional[Match] = None
    """
    MatchResources defines when cleanuppolicy should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    schedule: str
    """
    The schedule in Cron format
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            ---
            Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
            useful (see .node.status.conditions), the ability to deconflict is important.
            The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    ---
    Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be
    useful (see .node.status.conditions), the ability to deconflict is important.
    The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    """


class CleanupPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CleanupPolicyStatus"]:
            return CleanupPolicyStatus

        def build(self) -> "CleanupPolicyStatus":
            return CleanupPolicyStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_execution_time(self, value: Optional[datetime], /) -> Self:
            return self._set("last_execution_time", value)

    class BuilderContext(BuilderContextBase["CleanupPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CleanupPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CleanupPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CleanupPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CleanupPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_execution_time: Annotated[Optional[datetime], Field(alias="lastExecutionTime")] = None


class ClusterAdmissionReportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterAdmissionReportSpec"]:
            return ClusterAdmissionReportSpec

        def build(self) -> "ClusterAdmissionReportSpec":
            return ClusterAdmissionReportSpec(**self._attrs)

        @overload
        def owner(self, value_or_callback: Owner, /) -> "ClusterAdmissionReportSpec.Builder": ...

        @overload
        def owner(
            self, value_or_callback: Callable[[Owner.Builder], Owner.Builder | Owner], /
        ) -> "ClusterAdmissionReportSpec.Builder": ...

        @overload
        def owner(self, value_or_callback: Never = ...) -> "Owner.BuilderContext": ...

        def owner(self, value_or_callback=None, /):
            """
            Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
            """
            if self._in_context and value_or_callback is None:
                context = Owner.BuilderContext()
                context._parent_builder = self
                context._field_name = "owner"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Owner.builder())
                if isinstance(output, Owner.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("owner", value)

        @overload
        def results(
            self, value_or_callback: List[Result], /
        ) -> "ClusterAdmissionReportSpec.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Result, Result.Builder]],
                GenericListBuilder[Result, Result.Builder] | List[Result],
            ],
            /,
        ) -> "ClusterAdmissionReportSpec.Builder": ...

        @overload
        def results(self, value_or_callback: Never = ...) -> ListBuilderContext[Result.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            PolicyReportResult provides result details
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Result.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Result.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def summary(
            self, value_or_callback: Optional[Summary], /
        ) -> "ClusterAdmissionReportSpec.Builder": ...

        @overload
        def summary(
            self,
            value_or_callback: Callable[[Summary.Builder], Summary.Builder | Summary],
            /,
        ) -> "ClusterAdmissionReportSpec.Builder": ...

        @overload
        def summary(self, value_or_callback: Never = ...) -> "Summary.BuilderContext": ...

        def summary(self, value_or_callback=None, /):
            """
            PolicyReportSummary provides a summary of results
            """
            if self._in_context and value_or_callback is None:
                context = Summary.BuilderContext()
                context._parent_builder = self
                context._field_name = "summary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Summary.builder())
                if isinstance(output, Summary.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("summary", value)

    class BuilderContext(BuilderContextBase["ClusterAdmissionReportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterAdmissionReportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterAdmissionReportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterAdmissionReportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterAdmissionReportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    owner: Owner
    """
    Owner is a reference to the report owner (e.g. a Deployment, Namespace, or Node)
    """
    results: Optional[List[Result]] = None
    """
    PolicyReportResult provides result details
    """
    summary: Optional[Summary] = None
    """
    PolicyReportSummary provides a summary of results
    """


class ClusterBackgroundScanReportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBackgroundScanReportSpec"]:
            return ClusterBackgroundScanReportSpec

        def build(self) -> "ClusterBackgroundScanReportSpec":
            return ClusterBackgroundScanReportSpec(**self._attrs)

        @overload
        def results(
            self, value_or_callback: List[Result], /
        ) -> "ClusterBackgroundScanReportSpec.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Result, Result.Builder]],
                GenericListBuilder[Result, Result.Builder] | List[Result],
            ],
            /,
        ) -> "ClusterBackgroundScanReportSpec.Builder": ...

        @overload
        def results(self, value_or_callback: Never = ...) -> ListBuilderContext[Result.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            PolicyReportResult provides result details
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Result.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Result.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def summary(
            self, value_or_callback: Optional[Summary], /
        ) -> "ClusterBackgroundScanReportSpec.Builder": ...

        @overload
        def summary(
            self,
            value_or_callback: Callable[[Summary.Builder], Summary.Builder | Summary],
            /,
        ) -> "ClusterBackgroundScanReportSpec.Builder": ...

        @overload
        def summary(self, value_or_callback: Never = ...) -> "Summary.BuilderContext": ...

        def summary(self, value_or_callback=None, /):
            """
            PolicyReportSummary provides a summary of results
            """
            if self._in_context and value_or_callback is None:
                context = Summary.BuilderContext()
                context._parent_builder = self
                context._field_name = "summary"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Summary.builder())
                if isinstance(output, Summary.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("summary", value)

    class BuilderContext(BuilderContextBase["ClusterBackgroundScanReportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBackgroundScanReportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBackgroundScanReportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBackgroundScanReportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBackgroundScanReportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    results: Optional[List[Result]] = None
    """
    PolicyReportResult provides result details
    """
    summary: Optional[Summary] = None
    """
    PolicyReportSummary provides a summary of results
    """


class AllModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel1"]:
            return AllModel1

        def build(self) -> "AllModel1":
            return AllModel1(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel2"]:
            return AnyModel2

        def build(self) -> "AnyModel2":
            return AnyModel2(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AllModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel2"]:
            return AllModel2

        def build(self) -> "AllModel2":
            return AllModel2(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel2.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel2.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel2.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel2.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel3"]:
            return AnyModel3

        def build(self) -> "AnyModel3":
            return AnyModel3(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel3.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel3.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel3.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel3.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class ClusterCleanupPolicySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCleanupPolicySpec"]:
            return ClusterCleanupPolicySpec

        def build(self) -> "ClusterCleanupPolicySpec":
            return ClusterCleanupPolicySpec(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions defines the conditions used to select the resources which will be cleaned up.
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def context(
            self, value_or_callback: List[Context], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Context, Context.Builder]],
                GenericListBuilder[Context, Context.Builder] | List[Context],
            ],
            /,
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def context(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Context.Builder]: ...

        def context(self, value_or_callback=None, /):
            """
            Context defines variables and data sources that can be used during rule execution.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Context.Builder]()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Context.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        @overload
        def exclude(
            self, value_or_callback: Optional[Exclude], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def exclude(
            self,
            value_or_callback: Callable[[Exclude.Builder], Exclude.Builder | Exclude],
            /,
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def exclude(self, value_or_callback: Never = ...) -> "Exclude.BuilderContext": ...

        def exclude(self, value_or_callback=None, /):
            """
            ExcludeResources defines when cleanuppolicy should not be applied. The exclude
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the name or role.
            """
            if self._in_context and value_or_callback is None:
                context = Exclude.BuilderContext()
                context._parent_builder = self
                context._field_name = "exclude"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exclude.builder())
                if isinstance(output, Exclude.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exclude", value)

        @overload
        def match(
            self, value_or_callback: Optional[Match], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "ClusterCleanupPolicySpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            MatchResources defines when cleanuppolicy should be applied. The match
            criteria can include resource information (e.g. kind, name, namespace, labels)
            and admission review request information like the user name or role.
            At least one kind is required.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        def schedule(self, value: str, /) -> Self:
            """
            The schedule in Cron format
            """
            return self._set("schedule", value)

    class BuilderContext(BuilderContextBase["ClusterCleanupPolicySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCleanupPolicySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCleanupPolicySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCleanupPolicySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCleanupPolicySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[Conditions] = None
    """
    Conditions defines the conditions used to select the resources which will be cleaned up.
    """
    context: Optional[List[Context]] = None
    """
    Context defines variables and data sources that can be used during rule execution.
    """
    exclude: Optional[Exclude] = None
    """
    ExcludeResources defines when cleanuppolicy should not be applied. The exclude
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the name or role.
    """
    match: Optional[Match] = None
    """
    MatchResources defines when cleanuppolicy should be applied. The match
    criteria can include resource information (e.g. kind, name, namespace, labels)
    and admission review request information like the user name or role.
    At least one kind is required.
    """
    schedule: str
    """
    The schedule in Cron format
    """


class ClusterCleanupPolicyStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCleanupPolicyStatus"]:
            return ClusterCleanupPolicyStatus

        def build(self) -> "ClusterCleanupPolicyStatus":
            return ClusterCleanupPolicyStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ClusterCleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ClusterCleanupPolicyStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_execution_time(self, value: Optional[datetime], /) -> Self:
            return self._set("last_execution_time", value)

    class BuilderContext(BuilderContextBase["ClusterCleanupPolicyStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCleanupPolicyStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCleanupPolicyStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCleanupPolicyStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCleanupPolicyStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    last_execution_time: Annotated[Optional[datetime], Field(alias="lastExecutionTime")] = None


class AllModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel3"]:
            return AllModel3

        def build(self) -> "AllModel3":
            return AllModel3(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AllModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class AnyModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel4"]:
            return AnyModel4

        def build(self) -> "AnyModel4":
            return AnyModel4(**self._attrs)

        def key(self, value: Optional[Any], /) -> Self:
            """
            Key is the context entry (using JMESPath) for conditional rule evaluation.
            """
            return self._set("key", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Message is an optional display message
            """
            return self._set("message", value)

        def operator(
            self,
            value: Optional[
                Literal[
                    "Equals",
                    "NotEquals",
                    "AnyIn",
                    "AllIn",
                    "AnyNotIn",
                    "AllNotIn",
                    "GreaterThanOrEquals",
                    "GreaterThan",
                    "LessThanOrEquals",
                    "LessThan",
                    "DurationGreaterThanOrEquals",
                    "DurationGreaterThan",
                    "DurationLessThanOrEquals",
                    "DurationLessThan",
                ]
            ],
            /,
        ) -> Self:
            """
            Operator is the conditional operation to perform. Valid operators are:
            Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
            GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
            DurationLessThanOrEquals, DurationLessThan
            """
            return self._set("operator", value)

        def value(self, value: Optional[Any], /) -> Self:
            """
            Value is the conditional value, or set of values. The values can be fixed set
            or can be variables declared using JMESPath.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["AnyModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: Optional[Any] = None
    """
    Key is the context entry (using JMESPath) for conditional rule evaluation.
    """
    message: Optional[str] = None
    """
    Message is an optional display message
    """
    operator: Optional[
        Literal[
            "Equals",
            "NotEquals",
            "AnyIn",
            "AllIn",
            "AnyNotIn",
            "AllNotIn",
            "GreaterThanOrEquals",
            "GreaterThan",
            "LessThanOrEquals",
            "LessThan",
            "DurationGreaterThanOrEquals",
            "DurationGreaterThan",
            "DurationLessThanOrEquals",
            "DurationLessThan",
        ]
    ] = None
    """
    Operator is the conditional operation to perform. Valid operators are:
    Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals,
    GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan,
    DurationLessThanOrEquals, DurationLessThan
    """
    value: Optional[Any] = None
    """
    Value is the conditional value, or set of values. The values can be fixed set
    or can be variables declared using JMESPath.
    """


class Exception(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exception"]:
            return Exception

        def build(self) -> "Exception":
            return Exception(**self._attrs)

        def policy_name(self, value: str, /) -> Self:
            """
            PolicyName identifies the policy to which the exception is applied.
            The policy name uses the format <namespace>/<name> unless it
            references a ClusterPolicy.
            """
            return self._set("policy_name", value)

        def rule_names(self, value: List[str], /) -> Self:
            """
            RuleNames identifies the rules to which the exception is applied.
            """
            return self._set("rule_names", value)

    class BuilderContext(BuilderContextBase["Exception.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exception.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exception."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exception", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exception.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    policy_name: Annotated[str, Field(alias="policyName")]
    """
    PolicyName identifies the policy to which the exception is applied.
    The policy name uses the format <namespace>/<name> unless it
    references a ClusterPolicy.
    """
    rule_names: Annotated[List[str], Field(alias="ruleNames")]
    """
    RuleNames identifies the rules to which the exception is applied.
    """


class AllModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllModel4"]:
            return AllModel4

        def build(self) -> "AllModel4":
            return AllModel4(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AllModel4.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AllModel4.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AllModel4.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AllModel4.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AllModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class AnyModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AnyModel5"]:
            return AnyModel5

        def build(self) -> "AnyModel5":
            return AnyModel5(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is the list of cluster-wide role names for the user.
            """
            return self._set("cluster_roles", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "AnyModel5.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "AnyModel5.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            ResourceDescription contains information about the resource being created or modified.
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is the list of namespaced role names for the user.
            """
            return self._set("roles", value)

        @overload
        def subjects(self, value_or_callback: List[Subject], /) -> "AnyModel5.Builder": ...

        @overload
        def subjects(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Subject, Subject.Builder]],
                GenericListBuilder[Subject, Subject.Builder] | List[Subject],
            ],
            /,
        ) -> "AnyModel5.Builder": ...

        @overload
        def subjects(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Subject.Builder]: ...

        def subjects(self, value_or_callback=None, /):
            """
            Subjects is the list of subject names like users, user groups, and service accounts.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Subject.Builder]()
                context._parent_builder = self
                context._field_name = "subjects"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("subjects", value)

    class BuilderContext(BuilderContextBase["AnyModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AnyModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AnyModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AnyModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AnyModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is the list of cluster-wide role names for the user.
    """
    resources: Optional[Resources] = None
    """
    ResourceDescription contains information about the resource being created or modified.
    """
    roles: Optional[List[str]] = None
    """
    Roles is the list of namespaced role names for the user.
    """
    subjects: Optional[List[Subject]] = None
    """
    Subjects is the list of subject names like users, user groups, and service accounts.
    """


class PodSecurity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodSecurity"]:
            return PodSecurity

        def build(self) -> "PodSecurity":
            return PodSecurity(**self._attrs)

        def control_name(
            self,
            value: Literal[
                "HostProcess",
                "Host Namespaces",
                "Privileged Containers",
                "Capabilities",
                "HostPath Volumes",
                "Host Ports",
                "AppArmor",
                "SELinux",
                "/proc Mount Type",
                "Seccomp",
                "Sysctls",
                "Volume Types",
                "Privilege Escalation",
                "Running as Non-root",
                "Running as Non-root user",
            ],
            /,
        ) -> Self:
            """
            ControlName specifies the name of the Pod Security Standard control.
            See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
            """
            return self._set("control_name", value)

        def images(self, value: Optional[List[str]], /) -> Self:
            """
            Images selects matching containers and applies the container level PSS.
            Each image is the image name consisting of the registry address, repository, image, and tag.
            Empty list matches no containers, PSS checks are applied at the pod level only.
            Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
            """
            return self._set("images", value)

        def restricted_field(self, value: Optional[str], /) -> Self:
            """
            RestrictedField selects the field for the given Pod Security Standard control.
            When not set, all restricted fields for the control are selected.
            """
            return self._set("restricted_field", value)

        def values(self, value: Optional[List[str]], /) -> Self:
            """
            Values defines the allowed values that can be excluded.
            """
            return self._set("values", value)

    class BuilderContext(BuilderContextBase["PodSecurity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodSecurity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodSecurity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodSecurity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodSecurity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    control_name: Annotated[
        Literal[
            "HostProcess",
            "Host Namespaces",
            "Privileged Containers",
            "Capabilities",
            "HostPath Volumes",
            "Host Ports",
            "AppArmor",
            "SELinux",
            "/proc Mount Type",
            "Seccomp",
            "Sysctls",
            "Volume Types",
            "Privilege Escalation",
            "Running as Non-root",
            "Running as Non-root user",
        ],
        Field(alias="controlName"),
    ]
    """
    ControlName specifies the name of the Pod Security Standard control.
    See: https://kubernetes.io/docs/concepts/security/pod-security-standards/
    """
    images: Optional[List[str]] = None
    """
    Images selects matching containers and applies the container level PSS.
    Each image is the image name consisting of the registry address, repository, image, and tag.
    Empty list matches no containers, PSS checks are applied at the pod level only.
    Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
    """
    restricted_field: Annotated[Optional[str], Field(alias="restrictedField")] = None
    """
    RestrictedField selects the field for the given Pod Security Standard control.
    When not set, all restricted fields for the control are selected.
    """
    values: Optional[List[str]] = None
    """
    Values defines the allowed values that can be excluded.
    """


class PolicyExceptionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyExceptionSpec"]:
            return PolicyExceptionSpec

        def build(self) -> "PolicyExceptionSpec":
            return PolicyExceptionSpec(**self._attrs)

        def background(self, value: Optional[bool], /) -> Self:
            """
            Background controls if exceptions are applied to existing policies during a background scan.
            Optional. Default value is "true". The value must be set to "false" if the policy rule
            uses variables that are only available in the admission review request (e.g. user name).
            """
            return self._set("background", value)

        @overload
        def conditions(
            self, value_or_callback: Optional[Conditions], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[[Conditions.Builder], Conditions.Builder | Conditions],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def conditions(self, value_or_callback: Never = ...) -> "Conditions.BuilderContext": ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions are used to determine if a resource applies to the exception by evaluating a
            set of conditions. The declaration can contain nested `any` or `all` statements.
            """
            if self._in_context and value_or_callback is None:
                context = Conditions.BuilderContext()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conditions.builder())
                if isinstance(output, Conditions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def exceptions(
            self, value_or_callback: List[Exception], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def exceptions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Exception, Exception.Builder]],
                GenericListBuilder[Exception, Exception.Builder] | List[Exception],
            ],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def exceptions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Exception.Builder]: ...

        def exceptions(self, value_or_callback=None, /):
            """
            Exceptions is a list policy/rules to be excluded
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Exception.Builder]()
                context._parent_builder = self
                context._field_name = "exceptions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exception.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("exceptions", value)

        @overload
        def match(self, value_or_callback: Match, /) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            Match defines match clause used to check if a resource applies to the exception
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def pod_security(
            self, value_or_callback: List[PodSecurity], /
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def pod_security(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PodSecurity, PodSecurity.Builder]],
                GenericListBuilder[PodSecurity, PodSecurity.Builder] | List[PodSecurity],
            ],
            /,
        ) -> "PolicyExceptionSpec.Builder": ...

        @overload
        def pod_security(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PodSecurity.Builder]: ...

        def pod_security(self, value_or_callback=None, /):
            """
            PodSecurity specifies the Pod Security Standard controls to be excluded.
            Applicable only to policies that have validate.podSecurity subrule.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PodSecurity.Builder]()
                context._parent_builder = self
                context._field_name = "pod_security"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodSecurity.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pod_security", value)

    class BuilderContext(BuilderContextBase["PolicyExceptionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyExceptionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyExceptionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyExceptionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyExceptionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    background: Optional[bool] = None
    """
    Background controls if exceptions are applied to existing policies during a background scan.
    Optional. Default value is "true". The value must be set to "false" if the policy rule
    uses variables that are only available in the admission review request (e.g. user name).
    """
    conditions: Optional[Conditions] = None
    """
    Conditions are used to determine if a resource applies to the exception by evaluating a
    set of conditions. The declaration can contain nested `any` or `all` statements.
    """
    exceptions: List[Exception]
    """
    Exceptions is a list policy/rules to be excluded
    """
    match: Match
    """
    Match defines match clause used to check if a resource applies to the exception
    """
    pod_security: Annotated[Optional[List[PodSecurity]], Field(alias="podSecurity")] = None
    """
    PodSecurity specifies the Pod Security Standard controls to be excluded.
    Applicable only to policies that have validate.podSecurity subrule.
    """


class Kind(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Kind"]:
            return Kind

        def build(self) -> "Kind":
            return Kind(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            return self._set("kind", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["Kind.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Kind.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Kind."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Kind", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Kind.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    kind: str
    version: str


class RequestKind(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestKind"]:
            return RequestKind

        def build(self) -> "RequestKind":
            return RequestKind(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            return self._set("kind", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["RequestKind.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestKind.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestKind."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestKind", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestKind.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    kind: str
    version: str


class RequestResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RequestResource"]:
            return RequestResource

        def build(self) -> "RequestResource":
            return RequestResource(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def resource(self, value: str, /) -> Self:
            return self._set("resource", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["RequestResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RequestResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RequestResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    resource: str
    version: str


class ResourceModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel1"]:
            return ResourceModel1

        def build(self) -> "ResourceModel1":
            return ResourceModel1(**self._attrs)

        def group(self, value: str, /) -> Self:
            return self._set("group", value)

        def resource(self, value: str, /) -> Self:
            return self._set("resource", value)

        def version(self, value: str, /) -> Self:
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["ResourceModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: str
    resource: str
    version: str


class UserInfo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserInfo"]:
            return UserInfo

        def build(self) -> "UserInfo":
            return UserInfo(**self._attrs)

        def extra(self, value: Optional[Dict[str, List[str]]], /) -> Self:
            """
            Any additional information provided by the authenticator.
            """
            return self._set("extra", value)

        def groups(self, value: Optional[List[str]], /) -> Self:
            """
            The names of groups this user is a part of.
            """
            return self._set("groups", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            A unique value that identifies this user across time. If this user is
            deleted and another user by the same name is added, they will have
            different UIDs.
            """
            return self._set("uid", value)

        def username(self, value: Optional[str], /) -> Self:
            """
            The name that uniquely identifies this user among all active users.
            """
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["UserInfo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserInfo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserInfo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserInfo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserInfo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    extra: Optional[Dict[str, List[str]]] = None
    """
    Any additional information provided by the authenticator.
    """
    groups: Optional[List[str]] = None
    """
    The names of groups this user is a part of.
    """
    uid: Optional[str] = None
    """
    A unique value that identifies this user across time. If this user is
    deleted and another user by the same name is added, they will have
    different UIDs.
    """
    username: Optional[str] = None
    """
    The name that uniquely identifies this user among all active users.
    """


class AdmissionRequest(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdmissionRequest"]:
            return AdmissionRequest

        def build(self) -> "AdmissionRequest":
            return AdmissionRequest(**self._attrs)

        def dry_run(self, value: Optional[bool], /) -> Self:
            """
            DryRun indicates that modifications will definitely not be persisted for this request.
            Defaults to false.
            """
            return self._set("dry_run", value)

        @overload
        def kind(self, value_or_callback: Kind, /) -> "AdmissionRequest.Builder": ...

        @overload
        def kind(
            self, value_or_callback: Callable[[Kind.Builder], Kind.Builder | Kind], /
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def kind(self, value_or_callback: Never = ...) -> "Kind.BuilderContext": ...

        def kind(self, value_or_callback=None, /):
            """
            Kind is the fully-qualified type of object being submitted (for example, v1.Pod or autoscaling.v1.Scale)
            """
            if self._in_context and value_or_callback is None:
                context = Kind.BuilderContext()
                context._parent_builder = self
                context._field_name = "kind"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Kind.builder())
                if isinstance(output, Kind.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the name of the object as presented in the request.  On a CREATE operation, the client may omit name and
            rely on the server to generate the name.  If that is the case, this field will contain an empty string.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace is the namespace associated with the request (if any).
            """
            return self._set("namespace", value)

        def object(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Object is the object from the incoming request.
            """
            return self._set("object", value)

        def old_object(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            OldObject is the existing object. Only populated for DELETE and UPDATE requests.
            """
            return self._set("old_object", value)

        def operation(self, value: str, /) -> Self:
            """
            Operation is the operation being performed. This may be different than the operation
            requested. e.g. a patch can result in either a CREATE or UPDATE Operation.
            """
            return self._set("operation", value)

        def options(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Options is the operation option structure of the operation being performed.
            e.g. `meta.k8s.io/v1.DeleteOptions` or `meta.k8s.io/v1.CreateOptions`. This may be
            different than the options the caller provided. e.g. for a patch request the performed
            Operation might be a CREATE, in which case the Options will a
            `meta.k8s.io/v1.CreateOptions` even though the caller provided `meta.k8s.io/v1.PatchOptions`.
            """
            return self._set("options", value)

        @overload
        def request_kind(
            self, value_or_callback: Optional[RequestKind], /
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_kind(
            self,
            value_or_callback: Callable[[RequestKind.Builder], RequestKind.Builder | RequestKind],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_kind(self, value_or_callback: Never = ...) -> "RequestKind.BuilderContext": ...

        def request_kind(self, value_or_callback=None, /):
            """
            RequestKind is the fully-qualified type of the original API request (for example, v1.Pod or autoscaling.v1.Scale).
            If this is specified and differs from the value in "kind", an equivalent match and conversion was performed.


            For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
            `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
            an API request to apps/v1beta1 deployments would be converted and sent to the webhook
            with `kind: {group:"apps", version:"v1", kind:"Deployment"}` (matching the rule the webhook registered for),
            and `requestKind: {group:"apps", version:"v1beta1", kind:"Deployment"}` (indicating the kind of the original API request).


            See documentation for the "matchPolicy" field in the webhook configuration type for more details.
            """
            if self._in_context and value_or_callback is None:
                context = RequestKind.BuilderContext()
                context._parent_builder = self
                context._field_name = "request_kind"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestKind.builder())
                if isinstance(output, RequestKind.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("request_kind", value)

        @overload
        def request_resource(
            self, value_or_callback: Optional[RequestResource], /
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_resource(
            self,
            value_or_callback: Callable[
                [RequestResource.Builder], RequestResource.Builder | RequestResource
            ],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def request_resource(
            self, value_or_callback: Never = ...
        ) -> "RequestResource.BuilderContext": ...

        def request_resource(self, value_or_callback=None, /):
            """
            RequestResource is the fully-qualified resource of the original API request (for example, v1.pods).
            If this is specified and differs from the value in "resource", an equivalent match and conversion was performed.


            For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
            `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
            an API request to apps/v1beta1 deployments would be converted and sent to the webhook
            with `resource: {group:"apps", version:"v1", resource:"deployments"}` (matching the resource the webhook registered for),
            and `requestResource: {group:"apps", version:"v1beta1", resource:"deployments"}` (indicating the resource of the original API request).


            See documentation for the "matchPolicy" field in the webhook configuration type.
            """
            if self._in_context and value_or_callback is None:
                context = RequestResource.BuilderContext()
                context._parent_builder = self
                context._field_name = "request_resource"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RequestResource.builder())
                if isinstance(output, RequestResource.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("request_resource", value)

        def request_sub_resource(self, value: Optional[str], /) -> Self:
            """
            RequestSubResource is the name of the subresource of the original API request, if any (for example, "status" or "scale")
            If this is specified and differs from the value in "subResource", an equivalent match and conversion was performed.
            See documentation for the "matchPolicy" field in the webhook configuration type.
            """
            return self._set("request_sub_resource", value)

        @overload
        def resource(self, value_or_callback: ResourceModel1, /) -> "AdmissionRequest.Builder": ...

        @overload
        def resource(
            self,
            value_or_callback: Callable[
                [ResourceModel1.Builder], ResourceModel1.Builder | ResourceModel1
            ],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def resource(self, value_or_callback: Never = ...) -> "ResourceModel1.BuilderContext": ...

        def resource(self, value_or_callback=None, /):
            """
            Resource is the fully-qualified resource being requested (for example, v1.pods)
            """
            if self._in_context and value_or_callback is None:
                context = ResourceModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel1.builder())
                if isinstance(output, ResourceModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource", value)

        def sub_resource(self, value: Optional[str], /) -> Self:
            """
            SubResource is the subresource being requested, if any (for example, "status" or "scale")
            """
            return self._set("sub_resource", value)

        def uid(self, value: str, /) -> Self:
            """
            UID is an identifier for the individual request/response. It allows us to distinguish instances of requests which are
            otherwise identical (parallel requests, requests when earlier requests did not modify etc)
            The UID is meant to track the round trip (request/response) between the KAS and the WebHook, not the user request.
            It is suitable for correlating log entries between the webhook and apiserver, for either auditing or debugging.
            """
            return self._set("uid", value)

        @overload
        def user_info(self, value_or_callback: UserInfo, /) -> "AdmissionRequest.Builder": ...

        @overload
        def user_info(
            self,
            value_or_callback: Callable[[UserInfo.Builder], UserInfo.Builder | UserInfo],
            /,
        ) -> "AdmissionRequest.Builder": ...

        @overload
        def user_info(self, value_or_callback: Never = ...) -> "UserInfo.BuilderContext": ...

        def user_info(self, value_or_callback=None, /):
            """
            UserInfo is information about the requesting user
            """
            if self._in_context and value_or_callback is None:
                context = UserInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserInfo.builder())
                if isinstance(output, UserInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_info", value)

    class BuilderContext(BuilderContextBase["AdmissionRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdmissionRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdmissionRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdmissionRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdmissionRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dry_run: Annotated[Optional[bool], Field(alias="dryRun")] = None
    """
    DryRun indicates that modifications will definitely not be persisted for this request.
    Defaults to false.
    """
    kind: Kind
    """
    Kind is the fully-qualified type of object being submitted (for example, v1.Pod or autoscaling.v1.Scale)
    """
    name: Optional[str] = None
    """
    Name is the name of the object as presented in the request.  On a CREATE operation, the client may omit name and
    rely on the server to generate the name.  If that is the case, this field will contain an empty string.
    """
    namespace: Optional[str] = None
    """
    Namespace is the namespace associated with the request (if any).
    """
    object: Optional[Dict[str, Any]] = None
    """
    Object is the object from the incoming request.
    """
    old_object: Annotated[Optional[Dict[str, Any]], Field(alias="oldObject")] = None
    """
    OldObject is the existing object. Only populated for DELETE and UPDATE requests.
    """
    operation: str
    """
    Operation is the operation being performed. This may be different than the operation
    requested. e.g. a patch can result in either a CREATE or UPDATE Operation.
    """
    options: Optional[Dict[str, Any]] = None
    """
    Options is the operation option structure of the operation being performed.
    e.g. `meta.k8s.io/v1.DeleteOptions` or `meta.k8s.io/v1.CreateOptions`. This may be
    different than the options the caller provided. e.g. for a patch request the performed
    Operation might be a CREATE, in which case the Options will a
    `meta.k8s.io/v1.CreateOptions` even though the caller provided `meta.k8s.io/v1.PatchOptions`.
    """
    request_kind: Annotated[Optional[RequestKind], Field(alias="requestKind")] = None
    """
    RequestKind is the fully-qualified type of the original API request (for example, v1.Pod or autoscaling.v1.Scale).
    If this is specified and differs from the value in "kind", an equivalent match and conversion was performed.


    For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
    `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
    an API request to apps/v1beta1 deployments would be converted and sent to the webhook
    with `kind: {group:"apps", version:"v1", kind:"Deployment"}` (matching the rule the webhook registered for),
    and `requestKind: {group:"apps", version:"v1beta1", kind:"Deployment"}` (indicating the kind of the original API request).


    See documentation for the "matchPolicy" field in the webhook configuration type for more details.
    """
    request_resource: Annotated[Optional[RequestResource], Field(alias="requestResource")] = None
    """
    RequestResource is the fully-qualified resource of the original API request (for example, v1.pods).
    If this is specified and differs from the value in "resource", an equivalent match and conversion was performed.


    For example, if deployments can be modified via apps/v1 and apps/v1beta1, and a webhook registered a rule of
    `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]` and `matchPolicy: Equivalent`,
    an API request to apps/v1beta1 deployments would be converted and sent to the webhook
    with `resource: {group:"apps", version:"v1", resource:"deployments"}` (matching the resource the webhook registered for),
    and `requestResource: {group:"apps", version:"v1beta1", resource:"deployments"}` (indicating the resource of the original API request).


    See documentation for the "matchPolicy" field in the webhook configuration type.
    """
    request_sub_resource: Annotated[Optional[str], Field(alias="requestSubResource")] = None
    """
    RequestSubResource is the name of the subresource of the original API request, if any (for example, "status" or "scale")
    If this is specified and differs from the value in "subResource", an equivalent match and conversion was performed.
    See documentation for the "matchPolicy" field in the webhook configuration type.
    """
    resource: ResourceModel1
    """
    Resource is the fully-qualified resource being requested (for example, v1.pods)
    """
    sub_resource: Annotated[Optional[str], Field(alias="subResource")] = None
    """
    SubResource is the subresource being requested, if any (for example, "status" or "scale")
    """
    uid: str
    """
    UID is an identifier for the individual request/response. It allows us to distinguish instances of requests which are
    otherwise identical (parallel requests, requests when earlier requests did not modify etc)
    The UID is meant to track the round trip (request/response) between the KAS and the WebHook, not the user request.
    It is suitable for correlating log entries between the webhook and apiserver, for either auditing or debugging.
    """
    user_info: Annotated[UserInfo, Field(alias="userInfo")]
    """
    UserInfo is information about the requesting user
    """


class AdmissionRequestInfo(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdmissionRequestInfo"]:
            return AdmissionRequestInfo

        def build(self) -> "AdmissionRequestInfo":
            return AdmissionRequestInfo(**self._attrs)

        @overload
        def admission_request(
            self, value_or_callback: Optional[AdmissionRequest], /
        ) -> "AdmissionRequestInfo.Builder": ...

        @overload
        def admission_request(
            self,
            value_or_callback: Callable[
                [AdmissionRequest.Builder], AdmissionRequest.Builder | AdmissionRequest
            ],
            /,
        ) -> "AdmissionRequestInfo.Builder": ...

        @overload
        def admission_request(
            self, value_or_callback: Never = ...
        ) -> "AdmissionRequest.BuilderContext": ...

        def admission_request(self, value_or_callback=None, /):
            """
            AdmissionRequest describes the admission.Attributes for the admission request.
            """
            if self._in_context and value_or_callback is None:
                context = AdmissionRequest.BuilderContext()
                context._parent_builder = self
                context._field_name = "admission_request"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdmissionRequest.builder())
                if isinstance(output, AdmissionRequest.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("admission_request", value)

        def operation(self, value: Optional[str], /) -> Self:
            """
            Operation is the type of resource operation being checked for admission control
            """
            return self._set("operation", value)

    class BuilderContext(BuilderContextBase["AdmissionRequestInfo.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdmissionRequestInfo.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdmissionRequestInfo."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdmissionRequestInfo", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdmissionRequestInfo.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    admission_request: Annotated[Optional[AdmissionRequest], Field(alias="admissionRequest")] = None
    """
    AdmissionRequest describes the admission.Attributes for the admission request.
    """
    operation: Optional[str] = None
    """
    Operation is the type of resource operation being checked for admission control
    """


class UserInfoModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UserInfoModel"]:
            return UserInfoModel

        def build(self) -> "UserInfoModel":
            return UserInfoModel(**self._attrs)

        def cluster_roles(self, value: Optional[List[str]], /) -> Self:
            """
            ClusterRoles is a list of possible clusterRoles send the request.
            """
            return self._set("cluster_roles", value)

        def roles(self, value: Optional[List[str]], /) -> Self:
            """
            Roles is a list of possible role send the request.
            """
            return self._set("roles", value)

        @overload
        def user_info(
            self, value_or_callback: Optional[UserInfo], /
        ) -> "UserInfoModel.Builder": ...

        @overload
        def user_info(
            self,
            value_or_callback: Callable[[UserInfo.Builder], UserInfo.Builder | UserInfo],
            /,
        ) -> "UserInfoModel.Builder": ...

        @overload
        def user_info(self, value_or_callback: Never = ...) -> "UserInfo.BuilderContext": ...

        def user_info(self, value_or_callback=None, /):
            """
            UserInfo is the userInfo carried in the admission request.
            """
            if self._in_context and value_or_callback is None:
                context = UserInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserInfo.builder())
                if isinstance(output, UserInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_info", value)

    class BuilderContext(BuilderContextBase["UserInfoModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UserInfoModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UserInfoModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UserInfoModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UserInfoModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cluster_roles: Annotated[Optional[List[str]], Field(alias="clusterRoles")] = None
    """
    ClusterRoles is a list of possible clusterRoles send the request.
    """
    roles: Optional[List[str]] = None
    """
    Roles is a list of possible role send the request.
    """
    user_info: Annotated[Optional[UserInfo], Field(alias="userInfo")] = None
    """
    UserInfo is the userInfo carried in the admission request.
    """


class ContextModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ContextModel"]:
            return ContextModel

        def build(self) -> "ContextModel":
            return ContextModel(**self._attrs)

        @overload
        def admission_request_info(
            self, value_or_callback: Optional[AdmissionRequestInfo], /
        ) -> "ContextModel.Builder": ...

        @overload
        def admission_request_info(
            self,
            value_or_callback: Callable[
                [AdmissionRequestInfo.Builder],
                AdmissionRequestInfo.Builder | AdmissionRequestInfo,
            ],
            /,
        ) -> "ContextModel.Builder": ...

        @overload
        def admission_request_info(
            self, value_or_callback: Never = ...
        ) -> "AdmissionRequestInfo.BuilderContext": ...

        def admission_request_info(self, value_or_callback=None, /):
            """
            AdmissionRequestInfoObject stores the admission request and operation details
            """
            if self._in_context and value_or_callback is None:
                context = AdmissionRequestInfo.BuilderContext()
                context._parent_builder = self
                context._field_name = "admission_request_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdmissionRequestInfo.builder())
                if isinstance(output, AdmissionRequestInfo.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("admission_request_info", value)

        @overload
        def user_info(
            self, value_or_callback: Optional[UserInfoModel], /
        ) -> "ContextModel.Builder": ...

        @overload
        def user_info(
            self,
            value_or_callback: Callable[
                [UserInfoModel.Builder], UserInfoModel.Builder | UserInfoModel
            ],
            /,
        ) -> "ContextModel.Builder": ...

        @overload
        def user_info(self, value_or_callback: Never = ...) -> "UserInfoModel.BuilderContext": ...

        def user_info(self, value_or_callback=None, /):
            """
            RequestInfo contains permission info carried in an admission request.
            """
            if self._in_context and value_or_callback is None:
                context = UserInfoModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "user_info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UserInfoModel.builder())
                if isinstance(output, UserInfoModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("user_info", value)

    class BuilderContext(BuilderContextBase["ContextModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ContextModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ContextModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ContextModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ContextModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    admission_request_info: Annotated[
        Optional[AdmissionRequestInfo], Field(alias="admissionRequestInfo")
    ] = None
    """
    AdmissionRequestInfoObject stores the admission request and operation details
    """
    user_info: Annotated[Optional[UserInfoModel], Field(alias="userInfo")] = None
    """
    RequestInfo contains permission info carried in an admission request.
    """


class ResourceModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel2"]:
            return ResourceModel2

        def build(self) -> "ResourceModel2":
            return ResourceModel2(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion specifies resource apiVersion.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind specifies resource kind.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the resource name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies resource namespace.
            """
            return self._set("namespace", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID specifies the resource uid.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ResourceModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion specifies resource apiVersion.
    """
    kind: Optional[str] = None
    """
    Kind specifies resource kind.
    """
    name: Optional[str] = None
    """
    Name specifies the resource name.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies resource namespace.
    """
    uid: Optional[str] = None
    """
    UID specifies the resource uid.
    """


class UpdateRequestSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UpdateRequestSpec"]:
            return UpdateRequestSpec

        def build(self) -> "UpdateRequestSpec":
            return UpdateRequestSpec(**self._attrs)

        @overload
        def context(self, value_or_callback: ContextModel, /) -> "UpdateRequestSpec.Builder": ...

        @overload
        def context(
            self,
            value_or_callback: Callable[
                [ContextModel.Builder], ContextModel.Builder | ContextModel
            ],
            /,
        ) -> "UpdateRequestSpec.Builder": ...

        @overload
        def context(self, value_or_callback: Never = ...) -> "ContextModel.BuilderContext": ...

        def context(self, value_or_callback=None, /):
            """
            Context ...
            """
            if self._in_context and value_or_callback is None:
                context = ContextModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ContextModel.builder())
                if isinstance(output, ContextModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("context", value)

        def delete_downstream(self, value: bool, /) -> Self:
            """
            DeleteDownstream represents whether the downstream needs to be deleted.
            """
            return self._set("delete_downstream", value)

        def policy(self, value: str, /) -> Self:
            """
            Specifies the name of the policy.
            """
            return self._set("policy", value)

        def request_type(self, value: Optional[Literal["mutate", "generate"]], /) -> Self:
            """
            Type represents request type for background processing
            """
            return self._set("request_type", value)

        @overload
        def resource(self, value_or_callback: ResourceModel2, /) -> "UpdateRequestSpec.Builder": ...

        @overload
        def resource(
            self,
            value_or_callback: Callable[
                [ResourceModel2.Builder], ResourceModel2.Builder | ResourceModel2
            ],
            /,
        ) -> "UpdateRequestSpec.Builder": ...

        @overload
        def resource(self, value_or_callback: Never = ...) -> "ResourceModel2.BuilderContext": ...

        def resource(self, value_or_callback=None, /):
            """
            ResourceSpec is the information to identify the trigger resource.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel2.builder())
                if isinstance(output, ResourceModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource", value)

        def rule(self, value: str, /) -> Self:
            """
            Rule is the associate rule name of the current UR.
            """
            return self._set("rule", value)

        def synchronize(self, value: Optional[bool], /) -> Self:
            """
            Synchronize represents the sync behavior of the corresponding rule
            Optional. Defaults to "false" if not specified.
            """
            return self._set("synchronize", value)

    class BuilderContext(BuilderContextBase["UpdateRequestSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UpdateRequestSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UpdateRequestSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UpdateRequestSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UpdateRequestSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    context: ContextModel
    """
    Context ...
    """
    delete_downstream: Annotated[bool, Field(alias="deleteDownstream")]
    """
    DeleteDownstream represents whether the downstream needs to be deleted.
    """
    policy: str
    """
    Specifies the name of the policy.
    """
    request_type: Annotated[Optional[Literal["mutate", "generate"]], Field(alias="requestType")] = (
        None
    )
    """
    Type represents request type for background processing
    """
    resource: ResourceModel2
    """
    ResourceSpec is the information to identify the trigger resource.
    """
    rule: str
    """
    Rule is the associate rule name of the current UR.
    """
    synchronize: Optional[bool] = None
    """
    Synchronize represents the sync behavior of the corresponding rule
    Optional. Defaults to "false" if not specified.
    """


class GeneratedResource(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GeneratedResource"]:
            return GeneratedResource

        def build(self) -> "GeneratedResource":
            return GeneratedResource(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion specifies resource apiVersion.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind specifies resource kind.
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name specifies the resource name.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace specifies resource namespace.
            """
            return self._set("namespace", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID specifies the resource uid.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["GeneratedResource.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GeneratedResource.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GeneratedResource."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GeneratedResource", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GeneratedResource.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion specifies resource apiVersion.
    """
    kind: Optional[str] = None
    """
    Kind specifies resource kind.
    """
    name: Optional[str] = None
    """
    Name specifies the resource name.
    """
    namespace: Optional[str] = None
    """
    Namespace specifies resource namespace.
    """
    uid: Optional[str] = None
    """
    UID specifies the resource uid.
    """


class UpdateRequestStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UpdateRequestStatus"]:
            return UpdateRequestStatus

        def build(self) -> "UpdateRequestStatus":
            return UpdateRequestStatus(**self._attrs)

        @overload
        def generated_resources(
            self, value_or_callback: List[GeneratedResource], /
        ) -> "UpdateRequestStatus.Builder": ...

        @overload
        def generated_resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[GeneratedResource, GeneratedResource.Builder]],
                GenericListBuilder[GeneratedResource, GeneratedResource.Builder]
                | List[GeneratedResource],
            ],
            /,
        ) -> "UpdateRequestStatus.Builder": ...

        @overload
        def generated_resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[GeneratedResource.Builder]: ...

        def generated_resources(self, value_or_callback=None, /):
            """
            This will track the resources that are updated by the generate Policy.
            Will be used during clean up resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[GeneratedResource.Builder]()
                context._parent_builder = self
                context._field_name = "generated_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GeneratedResource.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("generated_resources", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            Specifies request status message.
            """
            return self._set("message", value)

        def retry_count(self, value: Optional[int], /) -> Self:
            return self._set("retry_count", value)

        def state(self, value: str, /) -> Self:
            """
            State represents state of the update request.
            """
            return self._set("state", value)

    class BuilderContext(BuilderContextBase["UpdateRequestStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UpdateRequestStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UpdateRequestStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UpdateRequestStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UpdateRequestStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    generated_resources: Annotated[
        Optional[List[GeneratedResource]], Field(alias="generatedResources")
    ] = None
    """
    This will track the resources that are updated by the generate Policy.
    Will be used during clean up resources.
    """
    message: Optional[str] = None
    """
    Specifies request status message.
    """
    retry_count: Annotated[Optional[int], Field(alias="retryCount")] = None
    state: str
    """
    State represents state of the update request.
    """


class AdmissionReport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdmissionReport"]:
            return AdmissionReport

        def build(self) -> "AdmissionReport":
            return AdmissionReport(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["AdmissionReport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "AdmissionReport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "AdmissionReport.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: AdmissionReportSpec, /) -> "AdmissionReport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [AdmissionReportSpec.Builder],
                AdmissionReportSpec.Builder | AdmissionReportSpec,
            ],
            /,
        ) -> "AdmissionReport.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "AdmissionReportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AdmissionReportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdmissionReportSpec.builder())
                if isinstance(output, AdmissionReportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["AdmissionReport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdmissionReport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdmissionReport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdmissionReport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdmissionReport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["AdmissionReport"]] = "AdmissionReport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: AdmissionReportSpec


class BackgroundScanReport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BackgroundScanReport"]:
            return BackgroundScanReport

        def build(self) -> "BackgroundScanReport":
            return BackgroundScanReport(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["BackgroundScanReport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "BackgroundScanReport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "BackgroundScanReport.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: BackgroundScanReportSpec, /
        ) -> "BackgroundScanReport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [BackgroundScanReportSpec.Builder],
                BackgroundScanReportSpec.Builder | BackgroundScanReportSpec,
            ],
            /,
        ) -> "BackgroundScanReport.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "BackgroundScanReportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = BackgroundScanReportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BackgroundScanReportSpec.builder())
                if isinstance(output, BackgroundScanReportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["BackgroundScanReport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BackgroundScanReport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BackgroundScanReport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BackgroundScanReport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BackgroundScanReport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["BackgroundScanReport"]] = "BackgroundScanReport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: BackgroundScanReportSpec


class CleanupPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CleanupPolicy"]:
            return CleanupPolicy

        def build(self) -> "CleanupPolicy":
            return CleanupPolicy(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["CleanupPolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: CleanupPolicySpec, /) -> "CleanupPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CleanupPolicySpec.Builder],
                CleanupPolicySpec.Builder | CleanupPolicySpec,
            ],
            /,
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CleanupPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CleanupPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CleanupPolicySpec.builder())
                if isinstance(output, CleanupPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CleanupPolicyStatus], /
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CleanupPolicyStatus.Builder],
                CleanupPolicyStatus.Builder | CleanupPolicyStatus,
            ],
            /,
        ) -> "CleanupPolicy.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "CleanupPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CleanupPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CleanupPolicyStatus.builder())
                if isinstance(output, CleanupPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["CleanupPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CleanupPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CleanupPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CleanupPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CleanupPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["CleanupPolicy"]] = "CleanupPolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: CleanupPolicySpec
    status: Optional[CleanupPolicyStatus] = None


class ClusterAdmissionReport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterAdmissionReport"]:
            return ClusterAdmissionReport

        def build(self) -> "ClusterAdmissionReport":
            return ClusterAdmissionReport(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterAdmissionReport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterAdmissionReport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterAdmissionReport.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ClusterAdmissionReportSpec, /
        ) -> "ClusterAdmissionReport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterAdmissionReportSpec.Builder],
                ClusterAdmissionReportSpec.Builder | ClusterAdmissionReportSpec,
            ],
            /,
        ) -> "ClusterAdmissionReport.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterAdmissionReportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterAdmissionReportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterAdmissionReportSpec.builder())
                if isinstance(output, ClusterAdmissionReportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ClusterAdmissionReport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterAdmissionReport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterAdmissionReport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterAdmissionReport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterAdmissionReport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterAdmissionReport"]] = "ClusterAdmissionReport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterAdmissionReportSpec


class ClusterBackgroundScanReport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterBackgroundScanReport"]:
            return ClusterBackgroundScanReport

        def build(self) -> "ClusterBackgroundScanReport":
            return ClusterBackgroundScanReport(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterBackgroundScanReport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterBackgroundScanReport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterBackgroundScanReport.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ClusterBackgroundScanReportSpec, /
        ) -> "ClusterBackgroundScanReport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterBackgroundScanReportSpec.Builder],
                ClusterBackgroundScanReportSpec.Builder | ClusterBackgroundScanReportSpec,
            ],
            /,
        ) -> "ClusterBackgroundScanReport.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterBackgroundScanReportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterBackgroundScanReportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterBackgroundScanReportSpec.builder())
                if isinstance(output, ClusterBackgroundScanReportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ClusterBackgroundScanReport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterBackgroundScanReport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterBackgroundScanReport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterBackgroundScanReport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterBackgroundScanReport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterBackgroundScanReport"]] = "ClusterBackgroundScanReport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterBackgroundScanReportSpec


class ClusterCleanupPolicy(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterCleanupPolicy"]:
            return ClusterCleanupPolicy

        def build(self) -> "ClusterCleanupPolicy":
            return ClusterCleanupPolicy(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterCleanupPolicy"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ClusterCleanupPolicySpec, /
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterCleanupPolicySpec.Builder],
                ClusterCleanupPolicySpec.Builder | ClusterCleanupPolicySpec,
            ],
            /,
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterCleanupPolicySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterCleanupPolicySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterCleanupPolicySpec.builder())
                if isinstance(output, ClusterCleanupPolicySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ClusterCleanupPolicyStatus], /
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ClusterCleanupPolicyStatus.Builder],
                ClusterCleanupPolicyStatus.Builder | ClusterCleanupPolicyStatus,
            ],
            /,
        ) -> "ClusterCleanupPolicy.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ClusterCleanupPolicyStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterCleanupPolicyStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterCleanupPolicyStatus.builder())
                if isinstance(output, ClusterCleanupPolicyStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ClusterCleanupPolicy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterCleanupPolicy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterCleanupPolicy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterCleanupPolicy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterCleanupPolicy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterCleanupPolicy"]] = "ClusterCleanupPolicy"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: ClusterCleanupPolicySpec
    status: Optional[ClusterCleanupPolicyStatus] = None


class PolicyException(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyException"]:
            return PolicyException

        def build(self) -> "PolicyException":
            return PolicyException(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PolicyException"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PolicyException.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PolicyException.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: PolicyExceptionSpec, /) -> "PolicyException.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PolicyExceptionSpec.Builder],
                PolicyExceptionSpec.Builder | PolicyExceptionSpec,
            ],
            /,
        ) -> "PolicyException.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PolicyExceptionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PolicyExceptionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PolicyExceptionSpec.builder())
                if isinstance(output, PolicyExceptionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["PolicyException.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyException.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyException."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyException", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyException.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PolicyException"]] = "PolicyException"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: PolicyExceptionSpec


class UpdateRequest(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UpdateRequest"]:
            return UpdateRequest

        def build(self) -> "UpdateRequest":
            return UpdateRequest(**self._attrs)

        def api_version(self, value: Optional[Literal["kyverno.io/v2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["UpdateRequest"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "UpdateRequest.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "UpdateRequest.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[UpdateRequestSpec], /
        ) -> "UpdateRequest.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [UpdateRequestSpec.Builder],
                UpdateRequestSpec.Builder | UpdateRequestSpec,
            ],
            /,
        ) -> "UpdateRequest.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "UpdateRequestSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UpdateRequestSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UpdateRequestSpec.builder())
                if isinstance(output, UpdateRequestSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[UpdateRequestStatus], /
        ) -> "UpdateRequest.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [UpdateRequestStatus.Builder],
                UpdateRequestStatus.Builder | UpdateRequestStatus,
            ],
            /,
        ) -> "UpdateRequest.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "UpdateRequestStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UpdateRequestStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UpdateRequestStatus.builder())
                if isinstance(output, UpdateRequestStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["UpdateRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UpdateRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UpdateRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UpdateRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UpdateRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["kyverno.io/v2"]], Field(alias="apiVersion")] = (
        "kyverno.io/v2"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["UpdateRequest"]] = "UpdateRequest"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[UpdateRequestSpec] = None
    status: Optional[UpdateRequestStatus] = None
