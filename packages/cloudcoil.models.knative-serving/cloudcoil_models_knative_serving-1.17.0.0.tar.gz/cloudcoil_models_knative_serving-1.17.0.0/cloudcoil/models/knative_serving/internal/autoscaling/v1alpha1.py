# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource

from ..... import apimachinery


class MetricSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MetricSpec"]:
            return MetricSpec

        def build(self) -> "MetricSpec":
            return MetricSpec(**self._attrs)

        def panic_window(self, value: int, /) -> Self:
            """
            PanicWindow is the aggregation window for metrics where quick reactions are needed.
            """
            return self._set("panic_window", value)

        def scrape_target(self, value: str, /) -> Self:
            """
            ScrapeTarget is the K8s service that publishes the metric endpoint.
            """
            return self._set("scrape_target", value)

        def stable_window(self, value: int, /) -> Self:
            """
            StableWindow is the aggregation window for metrics in a stable state.
            """
            return self._set("stable_window", value)

    class BuilderContext(BuilderContextBase["MetricSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MetricSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MetricSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MetricSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MetricSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    panic_window: Annotated[int, Field(alias="panicWindow")]
    """
    PanicWindow is the aggregation window for metrics where quick reactions are needed.
    """
    scrape_target: Annotated[str, Field(alias="scrapeTarget")]
    """
    ScrapeTarget is the K8s service that publishes the metric endpoint.
    """
    stable_window: Annotated[int, Field(alias="stableWindow")]
    """
    StableWindow is the aggregation window for metrics in a stable state.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another.
            We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
            differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition.
            When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another.
    We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
    differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition.
    When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class MetricStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MetricStatus"]:
            return MetricStatus

        def build(self) -> "MetricStatus":
            return MetricStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "MetricStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "MetricStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["MetricStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MetricStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MetricStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MetricStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MetricStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """


class ScaleTargetRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ScaleTargetRef"]:
            return ScaleTargetRef

        def build(self) -> "ScaleTargetRef":
            return ScaleTargetRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ScaleTargetRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ScaleTargetRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ScaleTargetRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ScaleTargetRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ScaleTargetRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class PodAutoscalerSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAutoscalerSpec"]:
            return PodAutoscalerSpec

        def build(self) -> "PodAutoscalerSpec":
            return PodAutoscalerSpec(**self._attrs)

        def container_concurrency(self, value: Optional[int], /) -> Self:
            """
            ContainerConcurrency specifies the maximum allowed
            in-flight (concurrent) requests per container of the Revision.
            Defaults to `0` which means unlimited concurrency.
            """
            return self._set("container_concurrency", value)

        def protocol_type(self, value: str, /) -> Self:
            """
            The application-layer protocol. Matches `ProtocolType` inferred from the revision spec.
            """
            return self._set("protocol_type", value)

        def reachability(self, value: Optional[str], /) -> Self:
            """
            Reachability specifies whether or not the `ScaleTargetRef` can be reached (ie. has a route).
            Defaults to `ReachabilityUnknown`
            """
            return self._set("reachability", value)

        @overload
        def scale_target_ref(
            self, value_or_callback: ScaleTargetRef, /
        ) -> "PodAutoscalerSpec.Builder": ...

        @overload
        def scale_target_ref(
            self,
            value_or_callback: Callable[
                [ScaleTargetRef.Builder], ScaleTargetRef.Builder | ScaleTargetRef
            ],
            /,
        ) -> "PodAutoscalerSpec.Builder": ...

        @overload
        def scale_target_ref(
            self, value_or_callback: Never = ...
        ) -> "ScaleTargetRef.BuilderContext": ...

        def scale_target_ref(self, value_or_callback=None, /):
            """
            ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
            is responsible for quickly right-sizing.
            """
            if self._in_context and value_or_callback is None:
                context = ScaleTargetRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "scale_target_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ScaleTargetRef.builder())
                if isinstance(output, ScaleTargetRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("scale_target_ref", value)

    class BuilderContext(BuilderContextBase["PodAutoscalerSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAutoscalerSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAutoscalerSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAutoscalerSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAutoscalerSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_concurrency: Annotated[Optional[int], Field(alias="containerConcurrency")] = None
    """
    ContainerConcurrency specifies the maximum allowed
    in-flight (concurrent) requests per container of the Revision.
    Defaults to `0` which means unlimited concurrency.
    """
    protocol_type: Annotated[str, Field(alias="protocolType")]
    """
    The application-layer protocol. Matches `ProtocolType` inferred from the revision spec.
    """
    reachability: Optional[str] = None
    """
    Reachability specifies whether or not the `ScaleTargetRef` can be reached (ie. has a route).
    Defaults to `ReachabilityUnknown`
    """
    scale_target_ref: Annotated[ScaleTargetRef, Field(alias="scaleTargetRef")]
    """
    ScaleTargetRef defines the /scale-able resource that this PodAutoscaler
    is responsible for quickly right-sizing.
    """


class PodAutoscalerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAutoscalerStatus"]:
            return PodAutoscalerStatus

        def build(self) -> "PodAutoscalerStatus":
            return PodAutoscalerStatus(**self._attrs)

        def actual_scale(self, value: Optional[int], /) -> Self:
            """
            ActualScale shows the actual number of replicas for the revision.
            """
            return self._set("actual_scale", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "PodAutoscalerStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "PodAutoscalerStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def desired_scale(self, value: Optional[int], /) -> Self:
            """
            DesiredScale shows the current desired number of replicas for the revision.
            """
            return self._set("desired_scale", value)

        def metrics_service_name(self, value: str, /) -> Self:
            """
            MetricsServiceName is the K8s Service name that provides revision metrics.
            The service is managed by the PA object.
            """
            return self._set("metrics_service_name", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def service_name(self, value: str, /) -> Self:
            """
            ServiceName is the K8s Service name that serves the revision, scaled by this PA.
            The service is created and owned by the ServerlessService object owned by this PA.
            """
            return self._set("service_name", value)

    class BuilderContext(BuilderContextBase["PodAutoscalerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAutoscalerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAutoscalerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAutoscalerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAutoscalerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    actual_scale: Annotated[Optional[int], Field(alias="actualScale")] = None
    """
    ActualScale shows the actual number of replicas for the revision.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    desired_scale: Annotated[Optional[int], Field(alias="desiredScale")] = None
    """
    DesiredScale shows the current desired number of replicas for the revision.
    """
    metrics_service_name: Annotated[str, Field(alias="metricsServiceName")]
    """
    MetricsServiceName is the K8s Service name that provides revision metrics.
    The service is managed by the PA object.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """
    service_name: Annotated[str, Field(alias="serviceName")]
    """
    ServiceName is the K8s Service name that serves the revision, scaled by this PA.
    The service is created and owned by the ServerlessService object owned by this PA.
    """


class Metric(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metric"]:
            return Metric

        def build(self) -> "Metric":
            return Metric(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["autoscaling.internal.knative.dev/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Metric"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Metric.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Metric.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[MetricSpec], /) -> "Metric.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[MetricSpec.Builder], MetricSpec.Builder | MetricSpec],
            /,
        ) -> "Metric.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "MetricSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MetricSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricSpec.builder())
                if isinstance(output, MetricSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[MetricStatus], /) -> "Metric.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [MetricStatus.Builder], MetricStatus.Builder | MetricStatus
            ],
            /,
        ) -> "Metric.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "MetricStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MetricStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MetricStatus.builder())
                if isinstance(output, MetricStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Metric.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metric.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metric."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metric", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metric.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["autoscaling.internal.knative.dev/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "autoscaling.internal.knative.dev/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Metric"]] = "Metric"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[MetricSpec] = None
    status: Optional[MetricStatus] = None


class PodAutoscaler(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodAutoscaler"]:
            return PodAutoscaler

        def build(self) -> "PodAutoscaler":
            return PodAutoscaler(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["autoscaling.internal.knative.dev/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PodAutoscaler"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PodAutoscaler.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PodAutoscaler.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[PodAutoscalerSpec], /
        ) -> "PodAutoscaler.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PodAutoscalerSpec.Builder],
                PodAutoscalerSpec.Builder | PodAutoscalerSpec,
            ],
            /,
        ) -> "PodAutoscaler.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "PodAutoscalerSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodAutoscalerSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAutoscalerSpec.builder())
                if isinstance(output, PodAutoscalerSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PodAutoscalerStatus], /
        ) -> "PodAutoscaler.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PodAutoscalerStatus.Builder],
                PodAutoscalerStatus.Builder | PodAutoscalerStatus,
            ],
            /,
        ) -> "PodAutoscaler.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "PodAutoscalerStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = PodAutoscalerStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodAutoscalerStatus.builder())
                if isinstance(output, PodAutoscalerStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["PodAutoscaler.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodAutoscaler.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodAutoscaler."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodAutoscaler", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodAutoscaler.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["autoscaling.internal.knative.dev/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "autoscaling.internal.knative.dev/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PodAutoscaler"]] = "PodAutoscaler"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[PodAutoscalerSpec] = None
    status: Optional[PodAutoscalerStatus] = None
