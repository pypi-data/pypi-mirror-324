# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    overload,
)

from pydantic import Field

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource

from ..... import apimachinery


class CertificateSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateSpec"]:
            return CertificateSpec

        def build(self) -> "CertificateSpec":
            return CertificateSpec(**self._attrs)

        def dns_names(self, value: List[str], /) -> Self:
            """
            DNSNames is a list of DNS names the Certificate could support.
            The wildcard format of DNSNames (e.g. *.default.example.com) is supported.
            """
            return self._set("dns_names", value)

        def domain(self, value: Optional[str], /) -> Self:
            """
            Domain is the top level domain of the values for DNSNames.
            """
            return self._set("domain", value)

        def secret_name(self, value: str, /) -> Self:
            """
            SecretName is the name of the secret resource to store the SSL certificate in.
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["CertificateSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dns_names: Annotated[List[str], Field(alias="dnsNames")]
    """
    DNSNames is a list of DNS names the Certificate could support.
    The wildcard format of DNSNames (e.g. *.default.example.com) is supported.
    """
    domain: Optional[str] = None
    """
    Domain is the top level domain of the values for DNSNames.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    SecretName is the name of the secret resource to store the SSL certificate in.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another.
            We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
            differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition.
            When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another.
    We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
    differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition.
    When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class Http01Challenge(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Http01Challenge"]:
            return Http01Challenge

        def build(self) -> "Http01Challenge":
            return Http01Challenge(**self._attrs)

        def service_name(self, value: Optional[str], /) -> Self:
            """
            ServiceName is the name of the service to serve HTTP01 challenge requests.
            """
            return self._set("service_name", value)

        def service_namespace(self, value: Optional[str], /) -> Self:
            """
            ServiceNamespace is the namespace of the service to serve HTTP01 challenge requests.
            """
            return self._set("service_namespace", value)

        def service_port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            ServicePort is the port of the service to serve HTTP01 challenge requests.
            """
            return self._set("service_port", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the URL that the HTTP01 challenge is expected to serve on.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Http01Challenge.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Http01Challenge.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Http01Challenge."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Http01Challenge", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Http01Challenge.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    service_name: Annotated[Optional[str], Field(alias="serviceName")] = None
    """
    ServiceName is the name of the service to serve HTTP01 challenge requests.
    """
    service_namespace: Annotated[Optional[str], Field(alias="serviceNamespace")] = None
    """
    ServiceNamespace is the namespace of the service to serve HTTP01 challenge requests.
    """
    service_port: Annotated[Optional[Union[int, str]], Field(alias="servicePort")] = None
    """
    ServicePort is the port of the service to serve HTTP01 challenge requests.
    """
    url: Optional[str] = None
    """
    URL is the URL that the HTTP01 challenge is expected to serve on.
    """


class CertificateStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CertificateStatus"]:
            return CertificateStatus

        def build(self) -> "CertificateStatus":
            return CertificateStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CertificateStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CertificateStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def http01_challenges(
            self, value_or_callback: List[Http01Challenge], /
        ) -> "CertificateStatus.Builder": ...

        @overload
        def http01_challenges(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Http01Challenge, Http01Challenge.Builder]],
                GenericListBuilder[Http01Challenge, Http01Challenge.Builder]
                | List[Http01Challenge],
            ],
            /,
        ) -> "CertificateStatus.Builder": ...

        @overload
        def http01_challenges(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Http01Challenge.Builder]: ...

        def http01_challenges(self, value_or_callback=None, /):
            """
            HTTP01Challenges is a list of HTTP01 challenges that need to be fulfilled
            in order to get the TLS certificate..
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Http01Challenge.Builder]()
                context._parent_builder = self
                context._field_name = "http01_challenges"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Http01Challenge.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http01_challenges", value)

        def not_after(self, value: Optional[datetime], /) -> Self:
            """
            The expiration time of the TLS certificate stored in the secret named
            by this resource in spec.secretName.
            """
            return self._set("not_after", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["CertificateStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CertificateStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CertificateStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CertificateStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CertificateStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    http01_challenges: Annotated[
        Optional[List[Http01Challenge]], Field(alias="http01Challenges")
    ] = None
    """
    HTTP01Challenges is a list of HTTP01 challenges that need to be fulfilled
    in order to get the TLS certificate..
    """
    not_after: Annotated[Optional[datetime], Field(alias="notAfter")] = None
    """
    The expiration time of the TLS certificate stored in the secret named
    by this resource in spec.secretName.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """


class ClusterDomainClaimSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterDomainClaimSpec"]:
            return ClusterDomainClaimSpec

        def build(self) -> "ClusterDomainClaimSpec":
            return ClusterDomainClaimSpec(**self._attrs)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace is the namespace which is allowed to create a DomainMapping
            using this ClusterDomainClaim's name.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ClusterDomainClaimSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterDomainClaimSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterDomainClaimSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterDomainClaimSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterDomainClaimSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    namespace: str
    """
    Namespace is the namespace which is allowed to create a DomainMapping
    using this ClusterDomainClaim's name.
    """


class Headers(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Headers"]:
            return Headers

        def build(self) -> "Headers":
            return Headers(**self._attrs)

        def exact(self, value: str, /) -> Self:
            return self._set("exact", value)

    class BuilderContext(BuilderContextBase["Headers.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Headers.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Headers."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Headers", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Headers.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exact: str


class Split(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Split"]:
            return Split

        def build(self) -> "Split":
            return Split(**self._attrs)

        def append_headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            AppendHeaders allow specifying additional HTTP headers to add
            before forwarding a request to the destination service.

            NOTE: This differs from K8s Ingress which doesn't allow header appending.
            """
            return self._set("append_headers", value)

        def percent(self, value: Optional[int], /) -> Self:
            """
            Specifies the split percentage, a number between 0 and 100.  If
            only one split is specified, we default to 100.

            NOTE: This differs from K8s Ingress to allow percentage split.
            """
            return self._set("percent", value)

        def service_name(self, value: str, /) -> Self:
            """
            Specifies the name of the referenced service.
            """
            return self._set("service_name", value)

        def service_namespace(self, value: str, /) -> Self:
            """
            Specifies the namespace of the referenced service.

            NOTE: This differs from K8s Ingress to allow routing to different namespaces.
            """
            return self._set("service_namespace", value)

        def service_port(self, value: Union[int, str], /) -> Self:
            """
            Specifies the port of the referenced service.
            """
            return self._set("service_port", value)

    class BuilderContext(BuilderContextBase["Split.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Split.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Split."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Split", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Split.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    append_headers: Annotated[Optional[Dict[str, str]], Field(alias="appendHeaders")] = None
    """
    AppendHeaders allow specifying additional HTTP headers to add
    before forwarding a request to the destination service.

    NOTE: This differs from K8s Ingress which doesn't allow header appending.
    """
    percent: Optional[int] = None
    """
    Specifies the split percentage, a number between 0 and 100.  If
    only one split is specified, we default to 100.

    NOTE: This differs from K8s Ingress to allow percentage split.
    """
    service_name: Annotated[str, Field(alias="serviceName")]
    """
    Specifies the name of the referenced service.
    """
    service_namespace: Annotated[str, Field(alias="serviceNamespace")]
    """
    Specifies the namespace of the referenced service.

    NOTE: This differs from K8s Ingress to allow routing to different namespaces.
    """
    service_port: Annotated[Union[int, str], Field(alias="servicePort")]
    """
    Specifies the port of the referenced service.
    """


class Path(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Path"]:
            return Path

        def build(self) -> "Path":
            return Path(**self._attrs)

        def append_headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            AppendHeaders allow specifying additional HTTP headers to add
            before forwarding a request to the destination service.

            NOTE: This differs from K8s Ingress which doesn't allow header appending.
            """
            return self._set("append_headers", value)

        def headers(self, value: Optional[Dict[str, Headers]], /) -> Self:
            """
            Headers defines header matching rules which is a map from a header name
            to HeaderMatch which specify a matching condition.
            When a request matched with all the header matching rules,
            the request is routed by the corresponding ingress rule.
            If it is empty, the headers are not used for matching
            """
            return self._set("headers", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path represents a literal prefix to which this rule should apply.
            Currently it can contain characters disallowed from the conventional
            "path" part of a URL as defined by RFC 3986. Paths must begin with
            a '/'. If unspecified, the path defaults to a catch all sending
            traffic to the backend.
            """
            return self._set("path", value)

        def rewrite_host(self, value: Optional[str], /) -> Self:
            """
            RewriteHost rewrites the incoming request's host header.

            This field is currently experimental and not supported by all Ingress
            implementations.
            """
            return self._set("rewrite_host", value)

        @overload
        def splits(self, value_or_callback: List[Split], /) -> "Path.Builder": ...

        @overload
        def splits(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Split, Split.Builder]],
                GenericListBuilder[Split, Split.Builder] | List[Split],
            ],
            /,
        ) -> "Path.Builder": ...

        @overload
        def splits(self, value_or_callback: Never = ...) -> ListBuilderContext[Split.Builder]: ...

        def splits(self, value_or_callback=None, /):
            """
            Splits defines the referenced service endpoints to which the traffic
            will be forwarded to.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Split.Builder]()
                context._parent_builder = self
                context._field_name = "splits"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Split.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("splits", value)

    class BuilderContext(BuilderContextBase["Path.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Path.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Path."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Path", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Path.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    append_headers: Annotated[Optional[Dict[str, str]], Field(alias="appendHeaders")] = None
    """
    AppendHeaders allow specifying additional HTTP headers to add
    before forwarding a request to the destination service.

    NOTE: This differs from K8s Ingress which doesn't allow header appending.
    """
    headers: Optional[Dict[str, Headers]] = None
    """
    Headers defines header matching rules which is a map from a header name
    to HeaderMatch which specify a matching condition.
    When a request matched with all the header matching rules,
    the request is routed by the corresponding ingress rule.
    If it is empty, the headers are not used for matching
    """
    path: Optional[str] = None
    """
    Path represents a literal prefix to which this rule should apply.
    Currently it can contain characters disallowed from the conventional
    "path" part of a URL as defined by RFC 3986. Paths must begin with
    a '/'. If unspecified, the path defaults to a catch all sending
    traffic to the backend.
    """
    rewrite_host: Annotated[Optional[str], Field(alias="rewriteHost")] = None
    """
    RewriteHost rewrites the incoming request's host header.

    This field is currently experimental and not supported by all Ingress
    implementations.
    """
    splits: List[Split]
    """
    Splits defines the referenced service endpoints to which the traffic
    will be forwarded to.
    """


class Http(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Http"]:
            return Http

        def build(self) -> "Http":
            return Http(**self._attrs)

        @overload
        def paths(self, value_or_callback: List[Path], /) -> "Http.Builder": ...

        @overload
        def paths(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Path, Path.Builder]],
                GenericListBuilder[Path, Path.Builder] | List[Path],
            ],
            /,
        ) -> "Http.Builder": ...

        @overload
        def paths(self, value_or_callback: Never = ...) -> ListBuilderContext[Path.Builder]: ...

        def paths(self, value_or_callback=None, /):
            """
            A collection of paths that map requests to backends.

            If they are multiple matching paths, the first match takes precedence.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Path.Builder]()
                context._parent_builder = self
                context._field_name = "paths"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Path.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("paths", value)

    class BuilderContext(BuilderContextBase["Http.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Http.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Http."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Http", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Http.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    paths: List[Path]
    """
    A collection of paths that map requests to backends.

    If they are multiple matching paths, the first match takes precedence.
    """


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        def hosts(self, value: Optional[List[str]], /) -> Self:
            """
            Host is the fully qualified domain name of a network host, as defined
            by RFC 3986. Note the following deviations from the "host" part of the
            URI as defined in the RFC:
            1. IPs are not allowed. Currently a rule value can only apply to the
                  IP in the Spec of the parent .
            2. The `:` delimiter is not respected because ports are not allowed.
                  Currently the port of an Ingress is implicitly :80 for http and
                  :443 for https.
            Both these may change in the future.
            If the host is unspecified, the Ingress routes all traffic based on the
            specified IngressRuleValue.
            If multiple matching Hosts were provided, the first rule will take precedent.
            """
            return self._set("hosts", value)

        @overload
        def http(self, value_or_callback: Optional[Http], /) -> "Rule.Builder": ...

        @overload
        def http(
            self, value_or_callback: Callable[[Http.Builder], Http.Builder | Http], /
        ) -> "Rule.Builder": ...

        @overload
        def http(self, value_or_callback: Never = ...) -> "Http.BuilderContext": ...

        def http(self, value_or_callback=None, /):
            """
            HTTP represents a rule to apply against incoming requests. If the
            rule is satisfied, the request is routed to the specified backend.
            """
            if self._in_context and value_or_callback is None:
                context = Http.BuilderContext()
                context._parent_builder = self
                context._field_name = "http"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Http.builder())
                if isinstance(output, Http.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http", value)

        def visibility(self, value: Optional[str], /) -> Self:
            """
            Visibility signifies whether this rule should `ClusterLocal`. If it's not
            specified then it defaults to `ExternalIP`.
            """
            return self._set("visibility", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    hosts: Optional[List[str]] = None
    """
    Host is the fully qualified domain name of a network host, as defined
    by RFC 3986. Note the following deviations from the "host" part of the
    URI as defined in the RFC:
    1. IPs are not allowed. Currently a rule value can only apply to the
          IP in the Spec of the parent .
    2. The `:` delimiter is not respected because ports are not allowed.
          Currently the port of an Ingress is implicitly :80 for http and
          :443 for https.
    Both these may change in the future.
    If the host is unspecified, the Ingress routes all traffic based on the
    specified IngressRuleValue.
    If multiple matching Hosts were provided, the first rule will take precedent.
    """
    http: Optional[Http] = None
    """
    HTTP represents a rule to apply against incoming requests. If the
    rule is satisfied, the request is routed to the specified backend.
    """
    visibility: Optional[str] = None
    """
    Visibility signifies whether this rule should `ClusterLocal`. If it's not
    specified then it defaults to `ExternalIP`.
    """


class Tl(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tl"]:
            return Tl

        def build(self) -> "Tl":
            return Tl(**self._attrs)

        def hosts(self, value: Optional[List[str]], /) -> Self:
            """
            Hosts is a list of hosts included in the TLS certificate. The values in
            this list must match the name/s used in the tlsSecret. Defaults to the
            wildcard host setting for the loadbalancer controller fulfilling this
            Ingress, if left unspecified.
            """
            return self._set("hosts", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            SecretName is the name of the secret used to terminate SSL traffic.
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: Optional[str], /) -> Self:
            """
            SecretNamespace is the namespace of the secret used to terminate SSL traffic.
            If not set the namespace should be assumed to be the same as the Ingress.
            If set the secret should have the same namespace as the Ingress otherwise
            the behaviour is undefined and not supported.
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["Tl.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tl.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tl."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tl", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tl.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    hosts: Optional[List[str]] = None
    """
    Hosts is a list of hosts included in the TLS certificate. The values in
    this list must match the name/s used in the tlsSecret. Defaults to the
    wildcard host setting for the loadbalancer controller fulfilling this
    Ingress, if left unspecified.
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    SecretName is the name of the secret used to terminate SSL traffic.
    """
    secret_namespace: Annotated[Optional[str], Field(alias="secretNamespace")] = None
    """
    SecretNamespace is the namespace of the secret used to terminate SSL traffic.
    If not set the namespace should be assumed to be the same as the Ingress.
    If set the secret should have the same namespace as the Ingress otherwise
    the behaviour is undefined and not supported.
    """


class IngressSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressSpec"]:
            return IngressSpec

        def build(self) -> "IngressSpec":
            return IngressSpec(**self._attrs)

        def http_option(self, value: Optional[str], /) -> Self:
            """
            HTTPOption is the option of HTTP. It has the following two values:
            `HTTPOptionEnabled`, `HTTPOptionRedirected`
            """
            return self._set("http_option", value)

        @overload
        def rules(self, value_or_callback: List[Rule], /) -> "IngressSpec.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "IngressSpec.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            A list of host rules used to configure the Ingress.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

        @overload
        def tls(self, value_or_callback: List[Tl], /) -> "IngressSpec.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Tl, Tl.Builder]],
                GenericListBuilder[Tl, Tl.Builder] | List[Tl],
            ],
            /,
        ) -> "IngressSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> ListBuilderContext[Tl.Builder]: ...

        def tls(self, value_or_callback=None, /):
            """
            TLS configuration. Currently Ingress only supports a single TLS
            port: 443. If multiple members of this list specify different hosts, they
            will be multiplexed on the same port according to the hostname specified
            through the SNI TLS extension, if the ingress controller fulfilling the
            ingress supports SNI.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Tl.Builder]()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tl.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["IngressSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    http_option: Annotated[Optional[str], Field(alias="httpOption")] = None
    """
    HTTPOption is the option of HTTP. It has the following two values:
    `HTTPOptionEnabled`, `HTTPOptionRedirected`
    """
    rules: Optional[List[Rule]] = None
    """
    A list of host rules used to configure the Ingress.
    """
    tls: Optional[List[Tl]] = None
    """
    TLS configuration. Currently Ingress only supports a single TLS
    port: 443. If multiple members of this list specify different hosts, they
    will be multiplexed on the same port according to the hostname specified
    through the SNI TLS extension, if the ingress controller fulfilling the
    ingress supports SNI.
    """


class Ingres(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ingres"]:
            return Ingres

        def build(self) -> "Ingres":
            return Ingres(**self._attrs)

        def domain(self, value: Optional[str], /) -> Self:
            """
            Domain is set for load-balancer ingress points that are DNS based
            (typically AWS load-balancers)
            """
            return self._set("domain", value)

        def domain_internal(self, value: Optional[str], /) -> Self:
            """
            DomainInternal is set if there is a cluster-local DNS name to access the Ingress.

            NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
                  DNS name to allow routing in case of not having a mesh.
            """
            return self._set("domain_internal", value)

        def ip(self, value: Optional[str], /) -> Self:
            """
            IP is set for load-balancer ingress points that are IP based
            (typically GCE or OpenStack load-balancers)
            """
            return self._set("ip", value)

        def mesh_only(self, value: Optional[bool], /) -> Self:
            """
            MeshOnly is set if the Ingress is only load-balanced through a Service mesh.
            """
            return self._set("mesh_only", value)

    class BuilderContext(BuilderContextBase["Ingres.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ingres.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ingres."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ingres", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ingres.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    domain: Optional[str] = None
    """
    Domain is set for load-balancer ingress points that are DNS based
    (typically AWS load-balancers)
    """
    domain_internal: Annotated[Optional[str], Field(alias="domainInternal")] = None
    """
    DomainInternal is set if there is a cluster-local DNS name to access the Ingress.

    NOTE: This differs from K8s Ingress, since we also desire to have a cluster-local
          DNS name to allow routing in case of not having a mesh.
    """
    ip: Optional[str] = None
    """
    IP is set for load-balancer ingress points that are IP based
    (typically GCE or OpenStack load-balancers)
    """
    mesh_only: Annotated[Optional[bool], Field(alias="meshOnly")] = None
    """
    MeshOnly is set if the Ingress is only load-balanced through a Service mesh.
    """


class PrivateLoadBalancer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PrivateLoadBalancer"]:
            return PrivateLoadBalancer

        def build(self) -> "PrivateLoadBalancer":
            return PrivateLoadBalancer(**self._attrs)

        @overload
        def ingress(self, value_or_callback: List[Ingres], /) -> "PrivateLoadBalancer.Builder": ...

        @overload
        def ingress(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Ingres, Ingres.Builder]],
                GenericListBuilder[Ingres, Ingres.Builder] | List[Ingres],
            ],
            /,
        ) -> "PrivateLoadBalancer.Builder": ...

        @overload
        def ingress(self, value_or_callback: Never = ...) -> ListBuilderContext[Ingres.Builder]: ...

        def ingress(self, value_or_callback=None, /):
            """
            Ingress is a list containing ingress points for the load-balancer.
            Traffic intended for the service should be sent to these ingress points.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Ingres.Builder]()
                context._parent_builder = self
                context._field_name = "ingress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ingres.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ingress", value)

    class BuilderContext(BuilderContextBase["PrivateLoadBalancer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PrivateLoadBalancer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PrivateLoadBalancer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PrivateLoadBalancer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PrivateLoadBalancer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ingress: Optional[List[Ingres]] = None
    """
    Ingress is a list containing ingress points for the load-balancer.
    Traffic intended for the service should be sent to these ingress points.
    """


class PublicLoadBalancer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PublicLoadBalancer"]:
            return PublicLoadBalancer

        def build(self) -> "PublicLoadBalancer":
            return PublicLoadBalancer(**self._attrs)

        @overload
        def ingress(self, value_or_callback: List[Ingres], /) -> "PublicLoadBalancer.Builder": ...

        @overload
        def ingress(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Ingres, Ingres.Builder]],
                GenericListBuilder[Ingres, Ingres.Builder] | List[Ingres],
            ],
            /,
        ) -> "PublicLoadBalancer.Builder": ...

        @overload
        def ingress(self, value_or_callback: Never = ...) -> ListBuilderContext[Ingres.Builder]: ...

        def ingress(self, value_or_callback=None, /):
            """
            Ingress is a list containing ingress points for the load-balancer.
            Traffic intended for the service should be sent to these ingress points.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Ingres.Builder]()
                context._parent_builder = self
                context._field_name = "ingress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ingres.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ingress", value)

    class BuilderContext(BuilderContextBase["PublicLoadBalancer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PublicLoadBalancer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PublicLoadBalancer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PublicLoadBalancer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PublicLoadBalancer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ingress: Optional[List[Ingres]] = None
    """
    Ingress is a list containing ingress points for the load-balancer.
    Traffic intended for the service should be sent to these ingress points.
    """


class IngressStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressStatus"]:
            return IngressStatus

        def build(self) -> "IngressStatus":
            return IngressStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "IngressStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "IngressStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def private_load_balancer(
            self, value_or_callback: Optional[PrivateLoadBalancer], /
        ) -> "IngressStatus.Builder": ...

        @overload
        def private_load_balancer(
            self,
            value_or_callback: Callable[
                [PrivateLoadBalancer.Builder],
                PrivateLoadBalancer.Builder | PrivateLoadBalancer,
            ],
            /,
        ) -> "IngressStatus.Builder": ...

        @overload
        def private_load_balancer(
            self, value_or_callback: Never = ...
        ) -> "PrivateLoadBalancer.BuilderContext": ...

        def private_load_balancer(self, value_or_callback=None, /):
            """
            PrivateLoadBalancer contains the current status of the load-balancer.
            """
            if self._in_context and value_or_callback is None:
                context = PrivateLoadBalancer.BuilderContext()
                context._parent_builder = self
                context._field_name = "private_load_balancer"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PrivateLoadBalancer.builder())
                if isinstance(output, PrivateLoadBalancer.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("private_load_balancer", value)

        @overload
        def public_load_balancer(
            self, value_or_callback: Optional[PublicLoadBalancer], /
        ) -> "IngressStatus.Builder": ...

        @overload
        def public_load_balancer(
            self,
            value_or_callback: Callable[
                [PublicLoadBalancer.Builder],
                PublicLoadBalancer.Builder | PublicLoadBalancer,
            ],
            /,
        ) -> "IngressStatus.Builder": ...

        @overload
        def public_load_balancer(
            self, value_or_callback: Never = ...
        ) -> "PublicLoadBalancer.BuilderContext": ...

        def public_load_balancer(self, value_or_callback=None, /):
            """
            PublicLoadBalancer contains the current status of the load-balancer.
            """
            if self._in_context and value_or_callback is None:
                context = PublicLoadBalancer.BuilderContext()
                context._parent_builder = self
                context._field_name = "public_load_balancer"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublicLoadBalancer.builder())
                if isinstance(output, PublicLoadBalancer.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("public_load_balancer", value)

    class BuilderContext(BuilderContextBase["IngressStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """
    private_load_balancer: Annotated[
        Optional[PrivateLoadBalancer], Field(alias="privateLoadBalancer")
    ] = None
    """
    PrivateLoadBalancer contains the current status of the load-balancer.
    """
    public_load_balancer: Annotated[
        Optional[PublicLoadBalancer], Field(alias="publicLoadBalancer")
    ] = None
    """
    PublicLoadBalancer contains the current status of the load-balancer.
    """


class ObjectRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ObjectRef"]:
            return ObjectRef

        def build(self) -> "ObjectRef":
            return ObjectRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            If referring to a piece of an object instead of an entire object, this string
            should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
            For example, if the object reference is to a container within a pod, this would take on a value like:
            "spec.containers{name}" (where "name" refers to the name of the container that triggered
            the event) or if no container name is specified "spec.containers[2]" (container with
            index 2 in this pod). This syntax is chosen only to have some well-defined way of
            referencing a part of an object.
            """
            return self._set("field_path", value)

        def kind(self, value: Optional[str], /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            """
            return self._set("namespace", value)

        def resource_version(self, value: Optional[str], /) -> Self:
            """
            Specific resourceVersion to which this reference is made, if any.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
            """
            return self._set("resource_version", value)

        def uid(self, value: Optional[str], /) -> Self:
            """
            UID of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ObjectRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ObjectRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ObjectRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ObjectRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObjectRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    If referring to a piece of an object instead of an entire object, this string
    should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    For example, if the object reference is to a container within a pod, this would take on a value like:
    "spec.containers{name}" (where "name" refers to the name of the container that triggered
    the event) or if no container name is specified "spec.containers[2]" (container with
    index 2 in this pod). This syntax is chosen only to have some well-defined way of
    referencing a part of an object.
    """
    kind: Optional[str] = None
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: Optional[str] = None
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    """
    resource_version: Annotated[Optional[str], Field(alias="resourceVersion")] = None
    """
    Specific resourceVersion to which this reference is made, if any.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    """
    uid: Optional[str] = None
    """
    UID of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    """


class ServerlessServiceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServerlessServiceSpec"]:
            return ServerlessServiceSpec

        def build(self) -> "ServerlessServiceSpec":
            return ServerlessServiceSpec(**self._attrs)

        def mode(self, value: Optional[str], /) -> Self:
            """
            Mode describes the mode of operation of the ServerlessService.
            """
            return self._set("mode", value)

        def num_activators(self, value: Optional[int], /) -> Self:
            """
            NumActivators contains number of Activators that this revision should be
            assigned.
            O means — assign all.
            """
            return self._set("num_activators", value)

        @overload
        def object_ref(
            self, value_or_callback: ObjectRef, /
        ) -> "ServerlessServiceSpec.Builder": ...

        @overload
        def object_ref(
            self,
            value_or_callback: Callable[[ObjectRef.Builder], ObjectRef.Builder | ObjectRef],
            /,
        ) -> "ServerlessServiceSpec.Builder": ...

        @overload
        def object_ref(self, value_or_callback: Never = ...) -> "ObjectRef.BuilderContext": ...

        def object_ref(self, value_or_callback=None, /):
            """
            ObjectRef defines the resource that this ServerlessService
            is responsible for making "serverless".
            """
            if self._in_context and value_or_callback is None:
                context = ObjectRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "object_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObjectRef.builder())
                if isinstance(output, ObjectRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("object_ref", value)

        def protocol_type(self, value: str, /) -> Self:
            """
            The application-layer protocol. Matches `RevisionProtocolType` set on the owning pa/revision.
            serving imports networking, so just use string.
            """
            return self._set("protocol_type", value)

    class BuilderContext(BuilderContextBase["ServerlessServiceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServerlessServiceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServerlessServiceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServerlessServiceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServerlessServiceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[str] = None
    """
    Mode describes the mode of operation of the ServerlessService.
    """
    num_activators: Annotated[Optional[int], Field(alias="numActivators")] = None
    """
    NumActivators contains number of Activators that this revision should be
    assigned.
    O means — assign all.
    """
    object_ref: Annotated[ObjectRef, Field(alias="objectRef")]
    """
    ObjectRef defines the resource that this ServerlessService
    is responsible for making "serverless".
    """
    protocol_type: Annotated[str, Field(alias="protocolType")]
    """
    The application-layer protocol. Matches `RevisionProtocolType` set on the owning pa/revision.
    serving imports networking, so just use string.
    """


class ServerlessServiceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServerlessServiceStatus"]:
            return ServerlessServiceStatus

        def build(self) -> "ServerlessServiceStatus":
            return ServerlessServiceStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ServerlessServiceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ServerlessServiceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def private_service_name(self, value: Optional[str], /) -> Self:
            """
            PrivateServiceName holds the name of a core K8s Service resource that
            load balances over the user service pods backing this Revision.
            """
            return self._set("private_service_name", value)

        def service_name(self, value: Optional[str], /) -> Self:
            """
            ServiceName holds the name of a core K8s Service resource that
            load balances over the pods backing this Revision (activator or revision).
            """
            return self._set("service_name", value)

    class BuilderContext(BuilderContextBase["ServerlessServiceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServerlessServiceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServerlessServiceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServerlessServiceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServerlessServiceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """
    private_service_name: Annotated[Optional[str], Field(alias="privateServiceName")] = None
    """
    PrivateServiceName holds the name of a core K8s Service resource that
    load balances over the user service pods backing this Revision.
    """
    service_name: Annotated[Optional[str], Field(alias="serviceName")] = None
    """
    ServiceName holds the name of a core K8s Service resource that
    load balances over the pods backing this Revision (activator or revision).
    """


class Certificate(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Certificate"]:
            return Certificate

        def build(self) -> "Certificate":
            return Certificate(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Certificate"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Certificate.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Certificate.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[CertificateSpec], /
        ) -> "Certificate.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CertificateSpec.Builder], CertificateSpec.Builder | CertificateSpec
            ],
            /,
        ) -> "Certificate.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CertificateSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CertificateSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateSpec.builder())
                if isinstance(output, CertificateSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CertificateStatus], /
        ) -> "Certificate.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CertificateStatus.Builder],
                CertificateStatus.Builder | CertificateStatus,
            ],
            /,
        ) -> "Certificate.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "CertificateStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CertificateStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CertificateStatus.builder())
                if isinstance(output, CertificateStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Certificate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Certificate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Certificate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Certificate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Certificate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.internal.knative.dev/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Certificate"]] = "Certificate"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[CertificateSpec] = None
    status: Optional[CertificateStatus] = None


class ClusterDomainClaim(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClusterDomainClaim"]:
            return ClusterDomainClaim

        def build(self) -> "ClusterDomainClaim":
            return ClusterDomainClaim(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ClusterDomainClaim"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ClusterDomainClaim.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ClusterDomainClaim.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ClusterDomainClaimSpec], /
        ) -> "ClusterDomainClaim.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ClusterDomainClaimSpec.Builder],
                ClusterDomainClaimSpec.Builder | ClusterDomainClaimSpec,
            ],
            /,
        ) -> "ClusterDomainClaim.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ClusterDomainClaimSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ClusterDomainClaimSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClusterDomainClaimSpec.builder())
                if isinstance(output, ClusterDomainClaimSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ClusterDomainClaim.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClusterDomainClaim.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClusterDomainClaim."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClusterDomainClaim", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClusterDomainClaim.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.internal.knative.dev/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ClusterDomainClaim"]] = "ClusterDomainClaim"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ClusterDomainClaimSpec] = None


class Ingress(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ingress"]:
            return Ingress

        def build(self) -> "Ingress":
            return Ingress(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Ingress"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Ingress.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Ingress.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[IngressSpec], /) -> "Ingress.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[IngressSpec.Builder], IngressSpec.Builder | IngressSpec],
            /,
        ) -> "Ingress.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IngressSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IngressSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IngressSpec.builder())
                if isinstance(output, IngressSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[IngressStatus], /) -> "Ingress.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [IngressStatus.Builder], IngressStatus.Builder | IngressStatus
            ],
            /,
        ) -> "Ingress.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "IngressStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IngressStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IngressStatus.builder())
                if isinstance(output, IngressStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Ingress.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ingress.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ingress."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ingress", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ingress.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.internal.knative.dev/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Ingress"]] = "Ingress"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[IngressSpec] = None
    status: Optional[IngressStatus] = None


class ServerlessService(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServerlessService"]:
            return ServerlessService

        def build(self) -> "ServerlessService":
            return ServerlessService(**self._attrs)

        def api_version(
            self,
            value: Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
            /,
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ServerlessService"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ServerlessService.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ServerlessService.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ServerlessServiceSpec], /
        ) -> "ServerlessService.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ServerlessServiceSpec.Builder],
                ServerlessServiceSpec.Builder | ServerlessServiceSpec,
            ],
            /,
        ) -> "ServerlessService.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ServerlessServiceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServerlessServiceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServerlessServiceSpec.builder())
                if isinstance(output, ServerlessServiceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ServerlessServiceStatus], /
        ) -> "ServerlessService.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ServerlessServiceStatus.Builder],
                ServerlessServiceStatus.Builder | ServerlessServiceStatus,
            ],
            /,
        ) -> "ServerlessService.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ServerlessServiceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServerlessServiceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServerlessServiceStatus.builder())
                if isinstance(output, ServerlessServiceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ServerlessService.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServerlessService.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServerlessService."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServerlessService", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServerlessService.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["networking.internal.knative.dev/v1alpha1"]],
        Field(alias="apiVersion"),
    ] = "networking.internal.knative.dev/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ServerlessService"]] = "ServerlessService"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ServerlessServiceSpec] = None
    status: Optional[ServerlessServiceStatus] = None
