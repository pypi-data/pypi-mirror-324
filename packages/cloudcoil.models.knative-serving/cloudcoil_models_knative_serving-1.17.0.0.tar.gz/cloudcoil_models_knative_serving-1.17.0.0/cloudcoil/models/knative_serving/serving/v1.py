# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    cast,
    overload,
)

from pydantic import Field, RootModel

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseBuilder,
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("annotations", value)

        def finalizers(self, value: Optional[List[str]], /) -> Self:
            return self._set("finalizers", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            return self._set("labels", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    finalizers: Optional[List[str]] = None
    labels: Optional[Dict[str, str]] = None
    name: Optional[str] = None
    namespace: Optional[str] = None


class ConfigMapKeyRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapKeyRef"]:
            return ConfigMapKeyRef

        def build(self) -> "ConfigMapKeyRef":
            return ConfigMapKeyRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key to select.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapKeyRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapKeyRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapKeyRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapKeyRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapKeyRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key to select.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap or its key must be defined
    """


class SecretKeyRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretKeyRef"]:
            return SecretKeyRef

        def build(self) -> "SecretKeyRef":
            return SecretKeyRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The key of the secret to select from.  Must be a valid secret key.
            """
            return self._set("key", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretKeyRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretKeyRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretKeyRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretKeyRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretKeyRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The key of the secret to select from.  Must be a valid secret key.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret or its key must be defined
    """


class ValueFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ValueFrom"]:
            return ValueFrom

        def build(self) -> "ValueFrom":
            return ValueFrom(**self._attrs)

        @overload
        def config_map_key_ref(
            self, value_or_callback: Optional[ConfigMapKeyRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def config_map_key_ref(
            self,
            value_or_callback: Callable[
                [ConfigMapKeyRef.Builder], ConfigMapKeyRef.Builder | ConfigMapKeyRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def config_map_key_ref(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapKeyRef.BuilderContext": ...

        def config_map_key_ref(self, value_or_callback=None, /):
            """
            Selects a key of a ConfigMap.
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapKeyRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map_key_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapKeyRef.builder())
                if isinstance(output, ConfigMapKeyRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map_key_ref", value)

        def field_ref(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-fieldref
            """
            return self._set("field_ref", value)

        def resource_field_ref(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-fieldref
            """
            return self._set("resource_field_ref", value)

        @overload
        def secret_key_ref(
            self, value_or_callback: Optional[SecretKeyRef], /
        ) -> "ValueFrom.Builder": ...

        @overload
        def secret_key_ref(
            self,
            value_or_callback: Callable[
                [SecretKeyRef.Builder], SecretKeyRef.Builder | SecretKeyRef
            ],
            /,
        ) -> "ValueFrom.Builder": ...

        @overload
        def secret_key_ref(
            self, value_or_callback: Never = ...
        ) -> "SecretKeyRef.BuilderContext": ...

        def secret_key_ref(self, value_or_callback=None, /):
            """
            Selects a key of a secret in the pod's namespace
            """
            if self._in_context and value_or_callback is None:
                context = SecretKeyRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_key_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretKeyRef.builder())
                if isinstance(output, SecretKeyRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_key_ref", value)

    class BuilderContext(BuilderContextBase["ValueFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ValueFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ValueFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ValueFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ValueFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_key_ref: Annotated[Optional[ConfigMapKeyRef], Field(alias="configMapKeyRef")] = None
    """
    Selects a key of a ConfigMap.
    """
    field_ref: Annotated[Optional[Dict[str, Any]], Field(alias="fieldRef")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-fieldref
    """
    resource_field_ref: Annotated[Optional[Dict[str, Any]], Field(alias="resourceFieldRef")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-fieldref
    """
    secret_key_ref: Annotated[Optional[SecretKeyRef], Field(alias="secretKeyRef")] = None
    """
    Selects a key of a secret in the pod's namespace
    """


class Env(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Env"]:
            return Env

        def build(self) -> "Env":
            return Env(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the environment variable. Must be a C_IDENTIFIER.
            """
            return self._set("name", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Variable references $(VAR_NAME) are expanded
            using the previously defined environment variables in the container and
            any service environment variables. If a variable cannot be resolved,
            the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
            "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
            Escaped references will never be expanded, regardless of whether the variable
            exists or not.
            Defaults to "".
            """
            return self._set("value", value)

        @overload
        def value_from(self, value_or_callback: Optional[ValueFrom], /) -> "Env.Builder": ...

        @overload
        def value_from(
            self,
            value_or_callback: Callable[[ValueFrom.Builder], ValueFrom.Builder | ValueFrom],
            /,
        ) -> "Env.Builder": ...

        @overload
        def value_from(self, value_or_callback: Never = ...) -> "ValueFrom.BuilderContext": ...

        def value_from(self, value_or_callback=None, /):
            """
            Source for the environment variable's value. Cannot be used if value is not empty.
            """
            if self._in_context and value_or_callback is None:
                context = ValueFrom.BuilderContext()
                context._parent_builder = self
                context._field_name = "value_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ValueFrom.builder())
                if isinstance(output, ValueFrom.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("value_from", value)

    class BuilderContext(BuilderContextBase["Env.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Env.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Env."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Env", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Env.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the environment variable. Must be a C_IDENTIFIER.
    """
    value: Optional[str] = None
    """
    Variable references $(VAR_NAME) are expanded
    using the previously defined environment variables in the container and
    any service environment variables. If a variable cannot be resolved,
    the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    Escaped references will never be expanded, regardless of whether the variable
    exists or not.
    Defaults to "".
    """
    value_from: Annotated[Optional[ValueFrom], Field(alias="valueFrom")] = None
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """


class ConfigMapRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapRef"]:
            return ConfigMapRef

        def build(self) -> "ConfigMapRef":
            return ConfigMapRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the ConfigMap must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the ConfigMap must be defined
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            Specify whether the Secret must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    Specify whether the Secret must be defined
    """


class EnvFrom(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnvFrom"]:
            return EnvFrom

        def build(self) -> "EnvFrom":
            return EnvFrom(**self._attrs)

        @overload
        def config_map_ref(
            self, value_or_callback: Optional[ConfigMapRef], /
        ) -> "EnvFrom.Builder": ...

        @overload
        def config_map_ref(
            self,
            value_or_callback: Callable[
                [ConfigMapRef.Builder], ConfigMapRef.Builder | ConfigMapRef
            ],
            /,
        ) -> "EnvFrom.Builder": ...

        @overload
        def config_map_ref(
            self, value_or_callback: Never = ...
        ) -> "ConfigMapRef.BuilderContext": ...

        def config_map_ref(self, value_or_callback=None, /):
            """
            The ConfigMap to select from
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapRef.builder())
                if isinstance(output, ConfigMapRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map_ref", value)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
            """
            return self._set("prefix", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "EnvFrom.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "EnvFrom.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            The Secret to select from
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["EnvFrom.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnvFrom.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnvFrom."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnvFrom", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnvFrom.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_ref: Annotated[Optional[ConfigMapRef], Field(alias="configMapRef")] = None
    """
    The ConfigMap to select from
    """
    prefix: Optional[str] = None
    """
    An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    The Secret to select from
    """


class Exec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Exec"]:
            return Exec

        def build(self) -> "Exec":
            return Exec(**self._attrs)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Command is the command line to execute inside the container, the working directory for the
            command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
            not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
            a shell, you need to explicitly call out to that shell.
            Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
            """
            return self._set("command", value)

    class BuilderContext(BuilderContextBase["Exec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Exec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Exec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Exec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Exec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    command: Optional[List[str]] = None
    """
    Command is the command line to execute inside the container, the working directory for the
    command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
    not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
    a shell, you need to explicitly call out to that shell.
    Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
    """


class Grpc(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Grpc"]:
            return Grpc

        def build(self) -> "Grpc":
            return Grpc(**self._attrs)

        def port(self, value: Optional[int], /) -> Self:
            """
            Port number of the gRPC service. Number must be in the range 1 to 65535.
            """
            return self._set("port", value)

        def service(self, value: Optional[str], /) -> Self:
            """
            Service is the name of the service to place in the gRPC HealthCheckRequest
            (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

            If this is not specified, the default behavior is defined by gRPC.
            """
            return self._set("service", value)

    class BuilderContext(BuilderContextBase["Grpc.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Grpc.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Grpc."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Grpc", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Grpc.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    port: Optional[int] = None
    """
    Port number of the gRPC service. Number must be in the range 1 to 65535.
    """
    service: Optional[str] = ""
    """
    Service is the name of the service to place in the gRPC HealthCheckRequest
    (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

    If this is not specified, the default behavior is defined by gRPC.
    """


class HttpHeader(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpHeader"]:
            return HttpHeader

        def build(self) -> "HttpHeader":
            return HttpHeader(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            The header field name.
            This will be canonicalized upon output, so case-variant names will be understood as the same header.
            """
            return self._set("name", value)

        def value(self, value: str, /) -> Self:
            """
            The header field value
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["HttpHeader.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpHeader.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpHeader."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpHeader", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpHeader.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    The header field name.
    This will be canonicalized upon output, so case-variant names will be understood as the same header.
    """
    value: str
    """
    The header field value
    """


class HttpGet(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HttpGet"]:
            return HttpGet

        def build(self) -> "HttpGet":
            return HttpGet(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Host name to connect to, defaults to the pod IP. You probably want to set
            "Host" in httpHeaders instead.
            """
            return self._set("host", value)

        @overload
        def http_headers(self, value_or_callback: List[HttpHeader], /) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[HttpHeader, HttpHeader.Builder]],
                GenericListBuilder[HttpHeader, HttpHeader.Builder] | List[HttpHeader],
            ],
            /,
        ) -> "HttpGet.Builder": ...

        @overload
        def http_headers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[HttpHeader.Builder]: ...

        def http_headers(self, value_or_callback=None, /):
            """
            Custom headers to set in the request. HTTP allows repeated headers.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[HttpHeader.Builder]()
                context._parent_builder = self
                context._field_name = "http_headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpHeader.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_headers", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path to access on the HTTP server.
            """
            return self._set("path", value)

        def port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Name or number of the port to access on the container.
            Number must be in the range 1 to 65535.
            Name must be an IANA_SVC_NAME.
            """
            return self._set("port", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme to use for connecting to the host.
            Defaults to HTTP.
            """
            return self._set("scheme", value)

    class BuilderContext(BuilderContextBase["HttpGet.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HttpGet.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HttpGet."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HttpGet", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HttpGet.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Host name to connect to, defaults to the pod IP. You probably want to set
    "Host" in httpHeaders instead.
    """
    http_headers: Annotated[Optional[List[HttpHeader]], Field(alias="httpHeaders")] = None
    """
    Custom headers to set in the request. HTTP allows repeated headers.
    """
    path: Optional[str] = None
    """
    Path to access on the HTTP server.
    """
    port: Optional[Union[int, str]] = None
    """
    Name or number of the port to access on the container.
    Number must be in the range 1 to 65535.
    Name must be an IANA_SVC_NAME.
    """
    scheme: Optional[str] = None
    """
    Scheme to use for connecting to the host.
    Defaults to HTTP.
    """


class TcpSocket(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TcpSocket"]:
            return TcpSocket

        def build(self) -> "TcpSocket":
            return TcpSocket(**self._attrs)

        def host(self, value: Optional[str], /) -> Self:
            """
            Optional: Host name to connect to, defaults to the pod IP.
            """
            return self._set("host", value)

        def port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Number or name of the port to access on the container.
            Number must be in the range 1 to 65535.
            Name must be an IANA_SVC_NAME.
            """
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["TcpSocket.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TcpSocket.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TcpSocket."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TcpSocket", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TcpSocket.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    host: Optional[str] = None
    """
    Optional: Host name to connect to, defaults to the pod IP.
    """
    port: Optional[Union[int, str]] = None
    """
    Number or name of the port to access on the container.
    Number must be in the range 1 to 65535.
    Name must be an IANA_SVC_NAME.
    """


class LivenessProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["LivenessProbe"]:
            return LivenessProbe

        def build(self) -> "LivenessProbe":
            return LivenessProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "LivenessProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies the action to take.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "LivenessProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies an action involving a GRPC port.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "LivenessProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "LivenessProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies the http request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "LivenessProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "LivenessProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies an action involving a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["LivenessProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LivenessProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LivenessProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["LivenessProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use LivenessProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies the action to take.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies an action involving a GRPC port.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies the http request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies an action involving a TCP port.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class Port(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Port"]:
            return Port

        def build(self) -> "Port":
            return Port(**self._attrs)

        def container_port(self, value: Optional[int], /) -> Self:
            """
            Number of port to expose on the pod's IP address.
            This must be a valid port number, 0 < x < 65536.
            """
            return self._set("container_port", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
            named port in a pod must have a unique name. Name for the port that can be
            referred to by services.
            """
            return self._set("name", value)

        def protocol(self, value: Optional[str], /) -> Self:
            """
            Protocol for port. Must be UDP, TCP, or SCTP.
            Defaults to "TCP".
            """
            return self._set("protocol", value)

    class BuilderContext(BuilderContextBase["Port.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Port.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Port."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Port", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Port.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_port: Annotated[Optional[int], Field(alias="containerPort")] = None
    """
    Number of port to expose on the pod's IP address.
    This must be a valid port number, 0 < x < 65536.
    """
    name: Optional[str] = None
    """
    If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
    named port in a pod must have a unique name. Name for the port that can be
    referred to by services.
    """
    protocol: Optional[str] = "TCP"
    """
    Protocol for port. Must be UDP, TCP, or SCTP.
    Defaults to "TCP".
    """


class ReadinessProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReadinessProbe"]:
            return ReadinessProbe

        def build(self) -> "ReadinessProbe":
            return ReadinessProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "ReadinessProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies the action to take.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "ReadinessProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies an action involving a GRPC port.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "ReadinessProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies the http request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "ReadinessProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies an action involving a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["ReadinessProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadinessProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadinessProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReadinessProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReadinessProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies the action to take.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies an action involving a GRPC port.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies the http request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies an action involving a TCP port.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class Limits(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Limits":
            value = cast(int, self._value)
            return Limits(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Limits.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Limits.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Limits."""
        return cls.BuilderContext()


class LimitsModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel":
            value = cast(str, self._value)
            return LimitsModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel."""
        return cls.BuilderContext()


class Requests(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Requests":
            value = cast(int, self._value)
            return Requests(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["Requests.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Requests.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Requests."""
        return cls.BuilderContext()


class RequestsModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel":
            value = cast(str, self._value)
            return RequestsModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel."""
        return cls.BuilderContext()


class Resources(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Resources"]:
            return Resources

        def build(self) -> "Resources":
            return Resources(**self._attrs)

        def limits(self, value: Optional[Dict[str, Union[Limits, LimitsModel]]], /) -> Self:
            """
            Limits describes the maximum amount of compute resources allowed.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("limits", value)

        def requests(self, value: Optional[Dict[str, Union[Requests, RequestsModel]]], /) -> Self:
            """
            Requests describes the minimum amount of compute resources required.
            If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
            otherwise to an implementation-defined value. Requests cannot exceed Limits.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            return self._set("requests", value)

    class BuilderContext(BuilderContextBase["Resources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Resources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Resources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Resources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Resources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    limits: Optional[Dict[str, Union[Limits, LimitsModel]]] = None
    """
    Limits describes the maximum amount of compute resources allowed.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    requests: Optional[Dict[str, Union[Requests, RequestsModel]]] = None
    """
    Requests describes the minimum amount of compute resources required.
    If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
    otherwise to an implementation-defined value. Requests cannot exceed Limits.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """


class Capabilities(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Capabilities"]:
            return Capabilities

        def build(self) -> "Capabilities":
            return Capabilities(**self._attrs)

        def add(self, value: Optional[List[str]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
            """
            return self._set("add", value)

        def drop(self, value: Optional[List[str]], /) -> Self:
            """
            Removed capabilities
            """
            return self._set("drop", value)

    class BuilderContext(BuilderContextBase["Capabilities.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Capabilities.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Capabilities."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Capabilities", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Capabilities.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add: Optional[List[str]] = None
    """
    This is accessible behind a feature flag - kubernetes.containerspec-addcapabilities
    """
    drop: Optional[List[str]] = None
    """
    Removed capabilities
    """


class SeccompProfile(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SeccompProfile"]:
            return SeccompProfile

        def build(self) -> "SeccompProfile":
            return SeccompProfile(**self._attrs)

        def localhost_profile(self, value: Optional[str], /) -> Self:
            """
            localhostProfile indicates a profile defined in a file on the node should be used.
            The profile must be preconfigured on the node to work.
            Must be a descending path, relative to the kubelet's configured seccomp profile location.
            Must be set if type is "Localhost". Must NOT be set for any other type.
            """
            return self._set("localhost_profile", value)

        def type(self, value: str, /) -> Self:
            """
            type indicates which kind of seccomp profile will be applied.
            Valid options are:

            Localhost - a profile defined in a file on the node should be used.
            RuntimeDefault - the container runtime default profile should be used.
            Unconfined - no profile should be applied.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["SeccompProfile.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SeccompProfile.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SeccompProfile."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SeccompProfile", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SeccompProfile.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    localhost_profile: Annotated[Optional[str], Field(alias="localhostProfile")] = None
    """
    localhostProfile indicates a profile defined in a file on the node should be used.
    The profile must be preconfigured on the node to work.
    Must be a descending path, relative to the kubelet's configured seccomp profile location.
    Must be set if type is "Localhost". Must NOT be set for any other type.
    """
    type: str
    """
    type indicates which kind of seccomp profile will be applied.
    Valid options are:

    Localhost - a profile defined in a file on the node should be used.
    RuntimeDefault - the container runtime default profile should be used.
    Unconfined - no profile should be applied.
    """


class SecurityContext(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecurityContext"]:
            return SecurityContext

        def build(self) -> "SecurityContext":
            return SecurityContext(**self._attrs)

        def allow_privilege_escalation(self, value: Optional[bool], /) -> Self:
            """
            AllowPrivilegeEscalation controls whether a process can gain more
            privileges than its parent process. This bool directly controls if
            the no_new_privs flag will be set on the container process.
            AllowPrivilegeEscalation is true always when the container is:
            1) run as Privileged
            2) has CAP_SYS_ADMIN
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("allow_privilege_escalation", value)

        @overload
        def capabilities(
            self, value_or_callback: Optional[Capabilities], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def capabilities(
            self,
            value_or_callback: Callable[
                [Capabilities.Builder], Capabilities.Builder | Capabilities
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def capabilities(self, value_or_callback: Never = ...) -> "Capabilities.BuilderContext": ...

        def capabilities(self, value_or_callback=None, /):
            """
            The capabilities to add/drop when running containers.
            Defaults to the default set of capabilities granted by the container runtime.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = Capabilities.BuilderContext()
                context._parent_builder = self
                context._field_name = "capabilities"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Capabilities.builder())
                if isinstance(output, Capabilities.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("capabilities", value)

        def privileged(self, value: Optional[bool], /) -> Self:
            """
            Run container in privileged mode. This can only be set to explicitly to 'false'
            """
            return self._set("privileged", value)

        def read_only_root_filesystem(self, value: Optional[bool], /) -> Self:
            """
            Whether this container has a read-only root filesystem.
            Default is false.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("read_only_root_filesystem", value)

        def run_as_group(self, value: Optional[int], /) -> Self:
            """
            The GID to run the entrypoint of the container process.
            Uses runtime default if unset.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_group", value)

        def run_as_non_root(self, value: Optional[bool], /) -> Self:
            """
            Indicates that the container must run as a non-root user.
            If true, the Kubelet will validate the image at runtime to ensure that it
            does not run as UID 0 (root) and fail to start the container if it does.
            If unset or false, no such validation will be performed.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            """
            return self._set("run_as_non_root", value)

        def run_as_user(self, value: Optional[int], /) -> Self:
            """
            The UID to run the entrypoint of the container process.
            Defaults to user specified in image metadata if unspecified.
            May also be set in PodSecurityContext.  If set in both SecurityContext and
            PodSecurityContext, the value specified in SecurityContext takes precedence.
            Note that this field cannot be set when spec.os.name is windows.
            """
            return self._set("run_as_user", value)

        @overload
        def seccomp_profile(
            self, value_or_callback: Optional[SeccompProfile], /
        ) -> "SecurityContext.Builder": ...

        @overload
        def seccomp_profile(
            self,
            value_or_callback: Callable[
                [SeccompProfile.Builder], SeccompProfile.Builder | SeccompProfile
            ],
            /,
        ) -> "SecurityContext.Builder": ...

        @overload
        def seccomp_profile(
            self, value_or_callback: Never = ...
        ) -> "SeccompProfile.BuilderContext": ...

        def seccomp_profile(self, value_or_callback=None, /):
            """
            The seccomp options to use by this container. If seccomp options are
            provided at both the pod & container level, the container options
            override the pod options.
            Note that this field cannot be set when spec.os.name is windows.
            """
            if self._in_context and value_or_callback is None:
                context = SeccompProfile.BuilderContext()
                context._parent_builder = self
                context._field_name = "seccomp_profile"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SeccompProfile.builder())
                if isinstance(output, SeccompProfile.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("seccomp_profile", value)

    class BuilderContext(BuilderContextBase["SecurityContext.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecurityContext.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecurityContext."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecurityContext", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecurityContext.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_privilege_escalation: Annotated[
        Optional[bool], Field(alias="allowPrivilegeEscalation")
    ] = None
    """
    AllowPrivilegeEscalation controls whether a process can gain more
    privileges than its parent process. This bool directly controls if
    the no_new_privs flag will be set on the container process.
    AllowPrivilegeEscalation is true always when the container is:
    1) run as Privileged
    2) has CAP_SYS_ADMIN
    Note that this field cannot be set when spec.os.name is windows.
    """
    capabilities: Optional[Capabilities] = None
    """
    The capabilities to add/drop when running containers.
    Defaults to the default set of capabilities granted by the container runtime.
    Note that this field cannot be set when spec.os.name is windows.
    """
    privileged: Optional[bool] = None
    """
    Run container in privileged mode. This can only be set to explicitly to 'false'
    """
    read_only_root_filesystem: Annotated[Optional[bool], Field(alias="readOnlyRootFilesystem")] = (
        None
    )
    """
    Whether this container has a read-only root filesystem.
    Default is false.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_group: Annotated[Optional[int], Field(alias="runAsGroup")] = None
    """
    The GID to run the entrypoint of the container process.
    Uses runtime default if unset.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    run_as_non_root: Annotated[Optional[bool], Field(alias="runAsNonRoot")] = None
    """
    Indicates that the container must run as a non-root user.
    If true, the Kubelet will validate the image at runtime to ensure that it
    does not run as UID 0 (root) and fail to start the container if it does.
    If unset or false, no such validation will be performed.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    """
    run_as_user: Annotated[Optional[int], Field(alias="runAsUser")] = None
    """
    The UID to run the entrypoint of the container process.
    Defaults to user specified in image metadata if unspecified.
    May also be set in PodSecurityContext.  If set in both SecurityContext and
    PodSecurityContext, the value specified in SecurityContext takes precedence.
    Note that this field cannot be set when spec.os.name is windows.
    """
    seccomp_profile: Annotated[Optional[SeccompProfile], Field(alias="seccompProfile")] = None
    """
    The seccomp options to use by this container. If seccomp options are
    provided at both the pod & container level, the container options
    override the pod options.
    Note that this field cannot be set when spec.os.name is windows.
    """


class StartupProbe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StartupProbe"]:
            return StartupProbe

        def build(self) -> "StartupProbe":
            return StartupProbe(**self._attrs)

        @overload
        def exec(self, value_or_callback: Optional[Exec], /) -> "StartupProbe.Builder": ...

        @overload
        def exec(
            self, value_or_callback: Callable[[Exec.Builder], Exec.Builder | Exec], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def exec(self, value_or_callback: Never = ...) -> "Exec.BuilderContext": ...

        def exec(self, value_or_callback=None, /):
            """
            Exec specifies the action to take.
            """
            if self._in_context and value_or_callback is None:
                context = Exec.BuilderContext()
                context._parent_builder = self
                context._field_name = "exec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Exec.builder())
                if isinstance(output, Exec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("exec", value)

        def failure_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive failures for the probe to be considered failed after having succeeded.
            Defaults to 3. Minimum value is 1.
            """
            return self._set("failure_threshold", value)

        @overload
        def grpc(self, value_or_callback: Optional[Grpc], /) -> "StartupProbe.Builder": ...

        @overload
        def grpc(
            self, value_or_callback: Callable[[Grpc.Builder], Grpc.Builder | Grpc], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def grpc(self, value_or_callback: Never = ...) -> "Grpc.BuilderContext": ...

        def grpc(self, value_or_callback=None, /):
            """
            GRPC specifies an action involving a GRPC port.
            """
            if self._in_context and value_or_callback is None:
                context = Grpc.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Grpc.builder())
                if isinstance(output, Grpc.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc", value)

        @overload
        def http_get(self, value_or_callback: Optional[HttpGet], /) -> "StartupProbe.Builder": ...

        @overload
        def http_get(
            self,
            value_or_callback: Callable[[HttpGet.Builder], HttpGet.Builder | HttpGet],
            /,
        ) -> "StartupProbe.Builder": ...

        @overload
        def http_get(self, value_or_callback: Never = ...) -> "HttpGet.BuilderContext": ...

        def http_get(self, value_or_callback=None, /):
            """
            HTTPGet specifies the http request to perform.
            """
            if self._in_context and value_or_callback is None:
                context = HttpGet.BuilderContext()
                context._parent_builder = self
                context._field_name = "http_get"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HttpGet.builder())
                if isinstance(output, HttpGet.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("http_get", value)

        def initial_delay_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after the container has started before liveness probes are initiated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("initial_delay_seconds", value)

        def period_seconds(self, value: Optional[int], /) -> Self:
            """
            How often (in seconds) to perform the probe.
            """
            return self._set("period_seconds", value)

        def success_threshold(self, value: Optional[int], /) -> Self:
            """
            Minimum consecutive successes for the probe to be considered successful after having failed.
            Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
            """
            return self._set("success_threshold", value)

        @overload
        def tcp_socket(
            self, value_or_callback: Optional[TcpSocket], /
        ) -> "StartupProbe.Builder": ...

        @overload
        def tcp_socket(
            self,
            value_or_callback: Callable[[TcpSocket.Builder], TcpSocket.Builder | TcpSocket],
            /,
        ) -> "StartupProbe.Builder": ...

        @overload
        def tcp_socket(self, value_or_callback: Never = ...) -> "TcpSocket.BuilderContext": ...

        def tcp_socket(self, value_or_callback=None, /):
            """
            TCPSocket specifies an action involving a TCP port.
            """
            if self._in_context and value_or_callback is None:
                context = TcpSocket.BuilderContext()
                context._parent_builder = self
                context._field_name = "tcp_socket"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TcpSocket.builder())
                if isinstance(output, TcpSocket.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tcp_socket", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            Number of seconds after which the probe times out.
            Defaults to 1 second. Minimum value is 1.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            return self._set("timeout_seconds", value)

    class BuilderContext(BuilderContextBase["StartupProbe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StartupProbe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StartupProbe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StartupProbe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StartupProbe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    exec: Optional[Exec] = None
    """
    Exec specifies the action to take.
    """
    failure_threshold: Annotated[Optional[int], Field(alias="failureThreshold")] = None
    """
    Minimum consecutive failures for the probe to be considered failed after having succeeded.
    Defaults to 3. Minimum value is 1.
    """
    grpc: Optional[Grpc] = None
    """
    GRPC specifies an action involving a GRPC port.
    """
    http_get: Annotated[Optional[HttpGet], Field(alias="httpGet")] = None
    """
    HTTPGet specifies the http request to perform.
    """
    initial_delay_seconds: Annotated[Optional[int], Field(alias="initialDelaySeconds")] = None
    """
    Number of seconds after the container has started before liveness probes are initiated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    period_seconds: Annotated[Optional[int], Field(alias="periodSeconds")] = None
    """
    How often (in seconds) to perform the probe.
    """
    success_threshold: Annotated[Optional[int], Field(alias="successThreshold")] = None
    """
    Minimum consecutive successes for the probe to be considered successful after having failed.
    Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
    """
    tcp_socket: Annotated[Optional[TcpSocket], Field(alias="tcpSocket")] = None
    """
    TCPSocket specifies an action involving a TCP port.
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    Number of seconds after which the probe times out.
    Defaults to 1 second. Minimum value is 1.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """


class VolumeMount(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VolumeMount"]:
            return VolumeMount

        def build(self) -> "VolumeMount":
            return VolumeMount(**self._attrs)

        def mount_path(self, value: str, /) -> Self:
            """
            Path within the container at which the volume should be mounted.  Must
            not contain ':'.
            """
            return self._set("mount_path", value)

        def name(self, value: str, /) -> Self:
            """
            This must match the Name of a Volume.
            """
            return self._set("name", value)

        def read_only(self, value: Optional[bool], /) -> Self:
            """
            Mounted read-only if true, read-write otherwise (false or unspecified).
            Defaults to false.
            """
            return self._set("read_only", value)

        def sub_path(self, value: Optional[str], /) -> Self:
            """
            Path within the volume from which the container's volume should be mounted.
            Defaults to "" (volume's root).
            """
            return self._set("sub_path", value)

    class BuilderContext(BuilderContextBase["VolumeMount.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VolumeMount.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VolumeMount."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VolumeMount", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VolumeMount.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mount_path: Annotated[str, Field(alias="mountPath")]
    """
    Path within the container at which the volume should be mounted.  Must
    not contain ':'.
    """
    name: str
    """
    This must match the Name of a Volume.
    """
    read_only: Annotated[Optional[bool], Field(alias="readOnly")] = None
    """
    Mounted read-only if true, read-write otherwise (false or unspecified).
    Defaults to false.
    """
    sub_path: Annotated[Optional[str], Field(alias="subPath")] = None
    """
    Path within the volume from which the container's volume should be mounted.
    Defaults to "" (volume's root).
    """


class Container(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Container"]:
            return Container

        def build(self) -> "Container":
            return Container(**self._attrs)

        def args(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments to the entrypoint.
            The container image's CMD is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("args", value)

        def command(self, value: Optional[List[str]], /) -> Self:
            """
            Entrypoint array. Not executed within a shell.
            The container image's ENTRYPOINT is used if this is not provided.
            Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
            cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
            to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
            produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
            of whether the variable exists or not. Cannot be updated.
            More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
            """
            return self._set("command", value)

        @overload
        def env(self, value_or_callback: List[Env], /) -> "Container.Builder": ...

        @overload
        def env(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Env, Env.Builder]],
                GenericListBuilder[Env, Env.Builder] | List[Env],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def env(self, value_or_callback: Never = ...) -> ListBuilderContext[Env.Builder]: ...

        def env(self, value_or_callback=None, /):
            """
            List of environment variables to set in the container.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Env.Builder]()
                context._parent_builder = self
                context._field_name = "env"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Env.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env", value)

        @overload
        def env_from(self, value_or_callback: List[EnvFrom], /) -> "Container.Builder": ...

        @overload
        def env_from(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnvFrom, EnvFrom.Builder]],
                GenericListBuilder[EnvFrom, EnvFrom.Builder] | List[EnvFrom],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def env_from(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnvFrom.Builder]: ...

        def env_from(self, value_or_callback=None, /):
            """
            List of sources to populate environment variables in the container.
            The keys defined within a source must be a C_IDENTIFIER. All invalid keys
            will be reported as an event when the container is starting. When a key exists in multiple
            sources, the value associated with the last source will take precedence.
            Values defined by an Env with a duplicate key will take precedence.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnvFrom.Builder]()
                context._parent_builder = self
                context._field_name = "env_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnvFrom.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("env_from", value)

        def image(self, value: Optional[str], /) -> Self:
            """
            Container image name.
            More info: https://kubernetes.io/docs/concepts/containers/images
            This field is optional to allow higher level config management to default or override
            container images in workload controllers like Deployments and StatefulSets.
            """
            return self._set("image", value)

        def image_pull_policy(self, value: Optional[str], /) -> Self:
            """
            Image pull policy.
            One of Always, Never, IfNotPresent.
            Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
            """
            return self._set("image_pull_policy", value)

        @overload
        def liveness_probe(
            self, value_or_callback: Optional[LivenessProbe], /
        ) -> "Container.Builder": ...

        @overload
        def liveness_probe(
            self,
            value_or_callback: Callable[
                [LivenessProbe.Builder], LivenessProbe.Builder | LivenessProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def liveness_probe(
            self, value_or_callback: Never = ...
        ) -> "LivenessProbe.BuilderContext": ...

        def liveness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container liveness.
            Container will be restarted if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = LivenessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "liveness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(LivenessProbe.builder())
                if isinstance(output, LivenessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("liveness_probe", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the container specified as a DNS_LABEL.
            Each container in a pod must have a unique name (DNS_LABEL).
            Cannot be updated.
            """
            return self._set("name", value)

        @overload
        def ports(self, value_or_callback: List[Port], /) -> "Container.Builder": ...

        @overload
        def ports(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Port, Port.Builder]],
                GenericListBuilder[Port, Port.Builder] | List[Port],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def ports(self, value_or_callback: Never = ...) -> ListBuilderContext[Port.Builder]: ...

        def ports(self, value_or_callback=None, /):
            """
            List of ports to expose from the container. Not specifying a port here
            DOES NOT prevent that port from being exposed. Any port which is
            listening on the default "0.0.0.0" address inside a container will be
            accessible from the network.
            Modifying this array with strategic merge patch may corrupt the data.
            For more information See https://github.com/kubernetes/kubernetes/issues/108255.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Port.Builder]()
                context._parent_builder = self
                context._field_name = "ports"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Port.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("ports", value)

        @overload
        def readiness_probe(
            self, value_or_callback: Optional[ReadinessProbe], /
        ) -> "Container.Builder": ...

        @overload
        def readiness_probe(
            self,
            value_or_callback: Callable[
                [ReadinessProbe.Builder], ReadinessProbe.Builder | ReadinessProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def readiness_probe(
            self, value_or_callback: Never = ...
        ) -> "ReadinessProbe.BuilderContext": ...

        def readiness_probe(self, value_or_callback=None, /):
            """
            Periodic probe of container service readiness.
            Container will be removed from service endpoints if the probe fails.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = ReadinessProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "readiness_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessProbe.builder())
                if isinstance(output, ReadinessProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_probe", value)

        @overload
        def resources(self, value_or_callback: Optional[Resources], /) -> "Container.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[[Resources.Builder], Resources.Builder | Resources],
            /,
        ) -> "Container.Builder": ...

        @overload
        def resources(self, value_or_callback: Never = ...) -> "Resources.BuilderContext": ...

        def resources(self, value_or_callback=None, /):
            """
            Compute Resources required by this container.
            Cannot be updated.
            More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
            """
            if self._in_context and value_or_callback is None:
                context = Resources.BuilderContext()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Resources.builder())
                if isinstance(output, Resources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        @overload
        def security_context(
            self, value_or_callback: Optional[SecurityContext], /
        ) -> "Container.Builder": ...

        @overload
        def security_context(
            self,
            value_or_callback: Callable[
                [SecurityContext.Builder], SecurityContext.Builder | SecurityContext
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def security_context(
            self, value_or_callback: Never = ...
        ) -> "SecurityContext.BuilderContext": ...

        def security_context(self, value_or_callback=None, /):
            """
            SecurityContext defines the security options the container should be run with.
            If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
            """
            if self._in_context and value_or_callback is None:
                context = SecurityContext.BuilderContext()
                context._parent_builder = self
                context._field_name = "security_context"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecurityContext.builder())
                if isinstance(output, SecurityContext.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("security_context", value)

        @overload
        def startup_probe(
            self, value_or_callback: Optional[StartupProbe], /
        ) -> "Container.Builder": ...

        @overload
        def startup_probe(
            self,
            value_or_callback: Callable[
                [StartupProbe.Builder], StartupProbe.Builder | StartupProbe
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def startup_probe(
            self, value_or_callback: Never = ...
        ) -> "StartupProbe.BuilderContext": ...

        def startup_probe(self, value_or_callback=None, /):
            """
            StartupProbe indicates that the Pod has successfully initialized.
            If specified, no other probes are executed until this completes successfully.
            If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
            This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
            when it might take a long time to load data or warm a cache, than during steady-state operation.
            This cannot be updated.
            More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
            """
            if self._in_context and value_or_callback is None:
                context = StartupProbe.BuilderContext()
                context._parent_builder = self
                context._field_name = "startup_probe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StartupProbe.builder())
                if isinstance(output, StartupProbe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("startup_probe", value)

        def termination_message_path(self, value: Optional[str], /) -> Self:
            """
            Optional: Path at which the file to which the container's termination message
            will be written is mounted into the container's filesystem.
            Message written is intended to be brief final status, such as an assertion failure message.
            Will be truncated by the node if greater than 4096 bytes. The total message length across
            all containers will be limited to 12kb.
            Defaults to /dev/termination-log.
            Cannot be updated.
            """
            return self._set("termination_message_path", value)

        def termination_message_policy(self, value: Optional[str], /) -> Self:
            """
            Indicate how the termination message should be populated. File will use the contents of
            terminationMessagePath to populate the container status message on both success and failure.
            FallbackToLogsOnError will use the last chunk of container log output if the termination
            message file is empty and the container exited with an error.
            The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
            Defaults to File.
            Cannot be updated.
            """
            return self._set("termination_message_policy", value)

        @overload
        def volume_mounts(self, value_or_callback: List[VolumeMount], /) -> "Container.Builder": ...

        @overload
        def volume_mounts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VolumeMount, VolumeMount.Builder]],
                GenericListBuilder[VolumeMount, VolumeMount.Builder] | List[VolumeMount],
            ],
            /,
        ) -> "Container.Builder": ...

        @overload
        def volume_mounts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VolumeMount.Builder]: ...

        def volume_mounts(self, value_or_callback=None, /):
            """
            Pod volumes to mount into the container's filesystem.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VolumeMount.Builder]()
                context._parent_builder = self
                context._field_name = "volume_mounts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VolumeMount.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volume_mounts", value)

        def working_dir(self, value: Optional[str], /) -> Self:
            """
            Container's working directory.
            If not specified, the container runtime's default will be used, which
            might be configured in the container image.
            Cannot be updated.
            """
            return self._set("working_dir", value)

    class BuilderContext(BuilderContextBase["Container.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Container.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Container."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Container", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Container.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    args: Optional[List[str]] = None
    """
    Arguments to the entrypoint.
    The container image's CMD is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    command: Optional[List[str]] = None
    """
    Entrypoint array. Not executed within a shell.
    The container image's ENTRYPOINT is used if this is not provided.
    Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
    cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
    to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
    produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
    of whether the variable exists or not. Cannot be updated.
    More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
    """
    env: Optional[List[Env]] = None
    """
    List of environment variables to set in the container.
    Cannot be updated.
    """
    env_from: Annotated[Optional[List[EnvFrom]], Field(alias="envFrom")] = None
    """
    List of sources to populate environment variables in the container.
    The keys defined within a source must be a C_IDENTIFIER. All invalid keys
    will be reported as an event when the container is starting. When a key exists in multiple
    sources, the value associated with the last source will take precedence.
    Values defined by an Env with a duplicate key will take precedence.
    Cannot be updated.
    """
    image: Optional[str] = None
    """
    Container image name.
    More info: https://kubernetes.io/docs/concepts/containers/images
    This field is optional to allow higher level config management to default or override
    container images in workload controllers like Deployments and StatefulSets.
    """
    image_pull_policy: Annotated[Optional[str], Field(alias="imagePullPolicy")] = None
    """
    Image pull policy.
    One of Always, Never, IfNotPresent.
    Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
    """
    liveness_probe: Annotated[Optional[LivenessProbe], Field(alias="livenessProbe")] = None
    """
    Periodic probe of container liveness.
    Container will be restarted if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    name: Optional[str] = None
    """
    Name of the container specified as a DNS_LABEL.
    Each container in a pod must have a unique name (DNS_LABEL).
    Cannot be updated.
    """
    ports: Optional[List[Port]] = None
    """
    List of ports to expose from the container. Not specifying a port here
    DOES NOT prevent that port from being exposed. Any port which is
    listening on the default "0.0.0.0" address inside a container will be
    accessible from the network.
    Modifying this array with strategic merge patch may corrupt the data.
    For more information See https://github.com/kubernetes/kubernetes/issues/108255.
    Cannot be updated.
    """
    readiness_probe: Annotated[Optional[ReadinessProbe], Field(alias="readinessProbe")] = None
    """
    Periodic probe of container service readiness.
    Container will be removed from service endpoints if the probe fails.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    resources: Optional[Resources] = None
    """
    Compute Resources required by this container.
    Cannot be updated.
    More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    """
    security_context: Annotated[Optional[SecurityContext], Field(alias="securityContext")] = None
    """
    SecurityContext defines the security options the container should be run with.
    If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
    """
    startup_probe: Annotated[Optional[StartupProbe], Field(alias="startupProbe")] = None
    """
    StartupProbe indicates that the Pod has successfully initialized.
    If specified, no other probes are executed until this completes successfully.
    If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
    This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
    when it might take a long time to load data or warm a cache, than during steady-state operation.
    This cannot be updated.
    More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
    """
    termination_message_path: Annotated[Optional[str], Field(alias="terminationMessagePath")] = None
    """
    Optional: Path at which the file to which the container's termination message
    will be written is mounted into the container's filesystem.
    Message written is intended to be brief final status, such as an assertion failure message.
    Will be truncated by the node if greater than 4096 bytes. The total message length across
    all containers will be limited to 12kb.
    Defaults to /dev/termination-log.
    Cannot be updated.
    """
    termination_message_policy: Annotated[
        Optional[str], Field(alias="terminationMessagePolicy")
    ] = None
    """
    Indicate how the termination message should be populated. File will use the contents of
    terminationMessagePath to populate the container status message on both success and failure.
    FallbackToLogsOnError will use the last chunk of container log output if the termination
    message file is empty and the container exited with an error.
    The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
    Defaults to File.
    Cannot be updated.
    """
    volume_mounts: Annotated[Optional[List[VolumeMount]], Field(alias="volumeMounts")] = None
    """
    Pod volumes to mount into the container's filesystem.
    Cannot be updated.
    """
    working_dir: Annotated[Optional[str], Field(alias="workingDir")] = None
    """
    Container's working directory.
    If not specified, the container runtime's default will be used, which
    might be configured in the container image.
    Cannot be updated.
    """


class ImagePullSecret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ImagePullSecret"]:
            return ImagePullSecret

        def build(self) -> "ImagePullSecret":
            return ImagePullSecret(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ImagePullSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ImagePullSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ImagePullSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ImagePullSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ImagePullSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """


class Item(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Item"]:
            return Item

        def build(self) -> "Item":
            return Item(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["Item.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Item.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Item."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Item", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Item.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class ConfigMap(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMap"]:
            return ConfigMap

        def build(self) -> "ConfigMap":
            return ConfigMap(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[Item], /) -> "ConfigMap.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Item, Item.Builder]],
                GenericListBuilder[Item, Item.Builder] | List[Item],
            ],
            /,
        ) -> "ConfigMap.Builder": ...

        @overload
        def items(self, value_or_callback: Never = ...) -> ListBuilderContext[Item.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Item.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Item.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMap.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMap.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMap."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMap", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMap.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[Item]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class ConfigMapModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel"]:
            return ConfigMapModel

        def build(self) -> "ConfigMapModel":
            return ConfigMapModel(**self._attrs)

        @overload
        def items(self, value_or_callback: List[Item], /) -> "ConfigMapModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Item, Item.Builder]],
                GenericListBuilder[Item, Item.Builder] | List[Item],
            ],
            /,
        ) -> "ConfigMapModel.Builder": ...

        @overload
        def items(self, value_or_callback: Never = ...) -> ListBuilderContext[Item.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Item.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Item.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[Item]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class FieldRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FieldRef"]:
            return FieldRef

        def build(self) -> "FieldRef":
            return FieldRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            Version of the schema the FieldPath is written in terms of, defaults to "v1".
            """
            return self._set("api_version", value)

        def field_path(self, value: str, /) -> Self:
            """
            Path of the field to select in the specified API version.
            """
            return self._set("field_path", value)

    class BuilderContext(BuilderContextBase["FieldRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FieldRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FieldRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FieldRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FieldRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    Version of the schema the FieldPath is written in terms of, defaults to "v1".
    """
    field_path: Annotated[str, Field(alias="fieldPath")]
    """
    Path of the field to select in the specified API version.
    """


class Divisor(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "Divisor":
            value = cast(int, self._value)
            return Divisor(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["Divisor.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Divisor.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Divisor."""
        return cls.BuilderContext()


class DivisorModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel":
            value = cast(str, self._value)
            return DivisorModel(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel."""
        return cls.BuilderContext()


class ResourceFieldRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceFieldRef"]:
            return ResourceFieldRef

        def build(self) -> "ResourceFieldRef":
            return ResourceFieldRef(**self._attrs)

        def container_name(self, value: Optional[str], /) -> Self:
            """
            Container name: required for volumes, optional for env vars
            """
            return self._set("container_name", value)

        def divisor(self, value: Optional[Union[Divisor, DivisorModel]], /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            return self._set("divisor", value)

        def resource(self, value: str, /) -> Self:
            """
            Required: resource to select
            """
            return self._set("resource", value)

    class BuilderContext(BuilderContextBase["ResourceFieldRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceFieldRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceFieldRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceFieldRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceFieldRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    container_name: Annotated[Optional[str], Field(alias="containerName")] = None
    """
    Container name: required for volumes, optional for env vars
    """
    divisor: Optional[Union[Divisor, DivisorModel]] = None
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """
    resource: str
    """
    Required: resource to select
    """


class ItemModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel"]:
            return ItemModel

        def build(self) -> "ItemModel":
            return ItemModel(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class DownwardApi(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DownwardApi"]:
            return DownwardApi

        def build(self) -> "DownwardApi":
            return DownwardApi(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel], /) -> "DownwardApi.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel, ItemModel.Builder]],
                GenericListBuilder[ItemModel, ItemModel.Builder] | List[ItemModel],
            ],
            /,
        ) -> "DownwardApi.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            Items is a list of DownwardAPIVolume file
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

    class BuilderContext(BuilderContextBase["DownwardApi.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DownwardApi.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DownwardApi."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DownwardApi", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DownwardApi.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel]] = None
    """
    Items is a list of DownwardAPIVolume file
    """


class ItemModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel1"]:
            return ItemModel1

        def build(self) -> "ItemModel1":
            return ItemModel1(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class Secret(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Secret"]:
            return Secret

        def build(self) -> "Secret":
            return Secret(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel1], /) -> "Secret.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel1, ItemModel1.Builder]],
                GenericListBuilder[ItemModel1, ItemModel1.Builder] | List[ItemModel1],
            ],
            /,
        ) -> "Secret.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel1.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel1.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["Secret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Secret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Secret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Secret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Secret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel1]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class ServiceAccountToken(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountToken"]:
            return ServiceAccountToken

        def build(self) -> "ServiceAccountToken":
            return ServiceAccountToken(**self._attrs)

        def audience(self, value: Optional[str], /) -> Self:
            """
            audience is the intended audience of the token. A recipient of a token
            must identify itself with an identifier specified in the audience of the
            token, and otherwise should reject the token. The audience defaults to the
            identifier of the apiserver.
            """
            return self._set("audience", value)

        def expiration_seconds(self, value: Optional[int], /) -> Self:
            """
            expirationSeconds is the requested duration of validity of the service
            account token. As the token approaches expiration, the kubelet volume
            plugin will proactively rotate the service account token. The kubelet will
            start trying to rotate the token if the token is older than 80 percent of
            its time to live or if the token is older than 24 hours.Defaults to 1 hour
            and must be at least 10 minutes.
            """
            return self._set("expiration_seconds", value)

        def path(self, value: str, /) -> Self:
            """
            path is the path relative to the mount point of the file to project the
            token into.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ServiceAccountToken.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountToken.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountToken."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountToken", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountToken.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    audience: Optional[str] = None
    """
    audience is the intended audience of the token. A recipient of a token
    must identify itself with an identifier specified in the audience of the
    token, and otherwise should reject the token. The audience defaults to the
    identifier of the apiserver.
    """
    expiration_seconds: Annotated[Optional[int], Field(alias="expirationSeconds")] = None
    """
    expirationSeconds is the requested duration of validity of the service
    account token. As the token approaches expiration, the kubelet volume
    plugin will proactively rotate the service account token. The kubelet will
    start trying to rotate the token if the token is older than 80 percent of
    its time to live or if the token is older than 24 hours.Defaults to 1 hour
    and must be at least 10 minutes.
    """
    path: str
    """
    path is the path relative to the mount point of the file to project the
    token into.
    """


class Source(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Source"]:
            return Source

        def build(self) -> "Source":
            return Source(**self._attrs)

        @overload
        def config_map(
            self, value_or_callback: Optional[ConfigMapModel], /
        ) -> "Source.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[
                [ConfigMapModel.Builder], ConfigMapModel.Builder | ConfigMapModel
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMapModel.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            configMap information about the configMap data to project
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMapModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMapModel.builder())
                if isinstance(output, ConfigMapModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        @overload
        def downward_api(self, value_or_callback: Optional[DownwardApi], /) -> "Source.Builder": ...

        @overload
        def downward_api(
            self,
            value_or_callback: Callable[[DownwardApi.Builder], DownwardApi.Builder | DownwardApi],
            /,
        ) -> "Source.Builder": ...

        @overload
        def downward_api(self, value_or_callback: Never = ...) -> "DownwardApi.BuilderContext": ...

        def downward_api(self, value_or_callback=None, /):
            """
            downwardAPI information about the downwardAPI data to project
            """
            if self._in_context and value_or_callback is None:
                context = DownwardApi.BuilderContext()
                context._parent_builder = self
                context._field_name = "downward_api"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DownwardApi.builder())
                if isinstance(output, DownwardApi.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("downward_api", value)

        @overload
        def secret(self, value_or_callback: Optional[Secret], /) -> "Source.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[Secret.Builder], Secret.Builder | Secret],
            /,
        ) -> "Source.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "Secret.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            secret information about the secret data to project
            """
            if self._in_context and value_or_callback is None:
                context = Secret.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Secret.builder())
                if isinstance(output, Secret.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

        @overload
        def service_account_token(
            self, value_or_callback: Optional[ServiceAccountToken], /
        ) -> "Source.Builder": ...

        @overload
        def service_account_token(
            self,
            value_or_callback: Callable[
                [ServiceAccountToken.Builder],
                ServiceAccountToken.Builder | ServiceAccountToken,
            ],
            /,
        ) -> "Source.Builder": ...

        @overload
        def service_account_token(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountToken.BuilderContext": ...

        def service_account_token(self, value_or_callback=None, /):
            """
            serviceAccountToken is information about the serviceAccountToken data to project
            """
            if self._in_context and value_or_callback is None:
                context = ServiceAccountToken.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountToken.builder())
                if isinstance(output, ServiceAccountToken.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_token", value)

    class BuilderContext(BuilderContextBase["Source.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Source.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Source."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Source", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Source.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMapModel], Field(alias="configMap")] = None
    """
    configMap information about the configMap data to project
    """
    downward_api: Annotated[Optional[DownwardApi], Field(alias="downwardAPI")] = None
    """
    downwardAPI information about the downwardAPI data to project
    """
    secret: Optional[Secret] = None
    """
    secret information about the secret data to project
    """
    service_account_token: Annotated[
        Optional[ServiceAccountToken], Field(alias="serviceAccountToken")
    ] = None
    """
    serviceAccountToken is information about the serviceAccountToken data to project
    """


class Projected(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Projected"]:
            return Projected

        def build(self) -> "Projected":
            return Projected(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode are the mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def sources(self, value_or_callback: List[Source], /) -> "Projected.Builder": ...

        @overload
        def sources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Source, Source.Builder]],
                GenericListBuilder[Source, Source.Builder] | List[Source],
            ],
            /,
        ) -> "Projected.Builder": ...

        @overload
        def sources(self, value_or_callback: Never = ...) -> ListBuilderContext[Source.Builder]: ...

        def sources(self, value_or_callback=None, /):
            """
            sources is the list of volume projections. Each entry in this list
            handles one source.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Source.Builder]()
                context._parent_builder = self
                context._field_name = "sources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Source.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("sources", value)

    class BuilderContext(BuilderContextBase["Projected.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Projected.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Projected."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Projected", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Projected.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode are the mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    sources: Optional[List[Source]] = None
    """
    sources is the list of volume projections. Each entry in this list
    handles one source.
    """


class SecretModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel"]:
            return SecretModel

        def build(self) -> "SecretModel":
            return SecretModel(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel1], /) -> "SecretModel.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel1, ItemModel1.Builder]],
                GenericListBuilder[ItemModel1, ItemModel1.Builder] | List[ItemModel1],
            ],
            /,
        ) -> "SecretModel.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel1.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel1.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel1]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class Volume(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Volume"]:
            return Volume

        def build(self) -> "Volume":
            return Volume(**self._attrs)

        @overload
        def config_map(self, value_or_callback: Optional[ConfigMap], /) -> "Volume.Builder": ...

        @overload
        def config_map(
            self,
            value_or_callback: Callable[[ConfigMap.Builder], ConfigMap.Builder | ConfigMap],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def config_map(self, value_or_callback: Never = ...) -> "ConfigMap.BuilderContext": ...

        def config_map(self, value_or_callback=None, /):
            """
            configMap represents a configMap that should populate this volume
            """
            if self._in_context and value_or_callback is None:
                context = ConfigMap.BuilderContext()
                context._parent_builder = self
                context._field_name = "config_map"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigMap.builder())
                if isinstance(output, ConfigMap.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config_map", value)

        def empty_dir(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-volumes-emptydir
            """
            return self._set("empty_dir", value)

        def host_path(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-volumes-hostpath
            """
            return self._set("host_path", value)

        def name(self, value: str, /) -> Self:
            """
            name of the volume.
            Must be a DNS_LABEL and unique within the pod.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def persistent_volume_claim(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
            """
            return self._set("persistent_volume_claim", value)

        @overload
        def projected(self, value_or_callback: Optional[Projected], /) -> "Volume.Builder": ...

        @overload
        def projected(
            self,
            value_or_callback: Callable[[Projected.Builder], Projected.Builder | Projected],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def projected(self, value_or_callback: Never = ...) -> "Projected.BuilderContext": ...

        def projected(self, value_or_callback=None, /):
            """
            projected items for all in one resources secrets, configmaps, and downward API
            """
            if self._in_context and value_or_callback is None:
                context = Projected.BuilderContext()
                context._parent_builder = self
                context._field_name = "projected"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Projected.builder())
                if isinstance(output, Projected.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("projected", value)

        @overload
        def secret(self, value_or_callback: Optional[SecretModel], /) -> "Volume.Builder": ...

        @overload
        def secret(
            self,
            value_or_callback: Callable[[SecretModel.Builder], SecretModel.Builder | SecretModel],
            /,
        ) -> "Volume.Builder": ...

        @overload
        def secret(self, value_or_callback: Never = ...) -> "SecretModel.BuilderContext": ...

        def secret(self, value_or_callback=None, /):
            """
            secret represents a secret that should populate this volume.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            if self._in_context and value_or_callback is None:
                context = SecretModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretModel.builder())
                if isinstance(output, SecretModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["Volume.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Volume.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Volume."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Volume", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Volume.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[ConfigMap], Field(alias="configMap")] = None
    """
    configMap represents a configMap that should populate this volume
    """
    empty_dir: Annotated[Optional[Dict[str, Any]], Field(alias="emptyDir")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-volumes-emptydir
    """
    host_path: Annotated[Optional[Dict[str, Any]], Field(alias="hostPath")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-volumes-hostpath
    """
    name: str
    """
    name of the volume.
    Must be a DNS_LABEL and unique within the pod.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    persistent_volume_claim: Annotated[
        Optional[Dict[str, Any]], Field(alias="persistentVolumeClaim")
    ] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-persistent-volume-claim
    """
    projected: Optional[Projected] = None
    """
    projected items for all in one resources secrets, configmaps, and downward API
    """
    secret: Optional[SecretModel] = None
    """
    secret represents a secret that should populate this volume.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class Spec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spec"]:
            return Spec

        def build(self) -> "Spec":
            return Spec(**self._attrs)

        def affinity(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-affinity
            """
            return self._set("affinity", value)

        def automount_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
            """
            return self._set("automount_service_account_token", value)

        def container_concurrency(self, value: Optional[int], /) -> Self:
            """
            ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
            requests per container of the Revision.  Defaults to `0` which means
            concurrency to the application is not limited, and the system decides the
            target concurrency for the autoscaler.
            """
            return self._set("container_concurrency", value)

        @overload
        def containers(self, value_or_callback: List[Container], /) -> "Spec.Builder": ...

        @overload
        def containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Container, Container.Builder]],
                GenericListBuilder[Container, Container.Builder] | List[Container],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Container.Builder]: ...

        def containers(self, value_or_callback=None, /):
            """
            List of containers belonging to the pod.
            Containers cannot currently be added or removed.
            There must be at least one container in a Pod.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Container.Builder]()
                context._parent_builder = self
                context._field_name = "containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Container.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("containers", value)

        def dns_config(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
            """
            return self._set("dns_config", value)

        def dns_policy(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
            """
            return self._set("dns_policy", value)

        def enable_service_links(self, value: Optional[bool], /) -> Self:
            """
            EnableServiceLinks indicates whether information aboutservices should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
            """
            return self._set("enable_service_links", value)

        def host_aliases(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostaliases
            """
            return self._set("host_aliases", value)

        def host_ipc(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostipc
            """
            return self._set("host_ipc", value)

        def host_network(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostnetwork
            """
            return self._set("host_network", value)

        def host_pid(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostpid
            """
            return self._set("host_pid", value)

        def idle_timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
            to stay open while not receiving any bytes from the user's application. If
            unspecified, a system default will be provided.
            """
            return self._set("idle_timeout_seconds", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[ImagePullSecret], /
        ) -> "Spec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]],
                GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]
                | List[ImagePullSecret],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ImagePullSecret.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            """
            ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
            If specified, these secrets will be passed to individual puller implementations for them to use.
            More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ImagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        def init_containers(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-init-containers
            """
            return self._set("init_containers", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-nodeselector
            """
            return self._set("node_selector", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
            """
            return self._set("priority_class_name", value)

        def response_start_timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
            routing layer will wait for a request delivered to a container to begin
            sending any network traffic.
            """
            return self._set("response_start_timeout_seconds", value)

        def runtime_class_name(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
            """
            return self._set("runtime_class_name", value)

        def scheduler_name(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-schedulername
            """
            return self._set("scheduler_name", value)

        def security_context(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-securitycontext
            """
            return self._set("security_context", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run this pod.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
            """
            return self._set("service_account_name", value)

        def share_process_namespace(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-shareprocessnamespace
            """
            return self._set("share_process_namespace", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            TimeoutSeconds is the maximum duration in seconds that the request instance
            is allowed to respond to a request. If unspecified, a system default will
            be provided.
            """
            return self._set("timeout_seconds", value)

        def tolerations(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-tolerations
            """
            return self._set("tolerations", value)

        def topology_spread_constraints(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
            """
            return self._set("topology_spread_constraints", value)

        @overload
        def volumes(self, value_or_callback: List[Volume], /) -> "Spec.Builder": ...

        @overload
        def volumes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Volume, Volume.Builder]],
                GenericListBuilder[Volume, Volume.Builder] | List[Volume],
            ],
            /,
        ) -> "Spec.Builder": ...

        @overload
        def volumes(self, value_or_callback: Never = ...) -> ListBuilderContext[Volume.Builder]: ...

        def volumes(self, value_or_callback=None, /):
            """
            List of volumes that can be mounted by containers belonging to the pod.
            More info: https://kubernetes.io/docs/concepts/storage/volumes
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Volume.Builder]()
                context._parent_builder = self
                context._field_name = "volumes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Volume.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volumes", value)

    class BuilderContext(BuilderContextBase["Spec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    affinity: Optional[Dict[str, Any]] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-affinity
    """
    automount_service_account_token: Annotated[
        Optional[bool], Field(alias="automountServiceAccountToken")
    ] = None
    """
    AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
    """
    container_concurrency: Annotated[Optional[int], Field(alias="containerConcurrency")] = None
    """
    ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
    requests per container of the Revision.  Defaults to `0` which means
    concurrency to the application is not limited, and the system decides the
    target concurrency for the autoscaler.
    """
    containers: List[Container]
    """
    List of containers belonging to the pod.
    Containers cannot currently be added or removed.
    There must be at least one container in a Pod.
    Cannot be updated.
    """
    dns_config: Annotated[Optional[Dict[str, Any]], Field(alias="dnsConfig")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
    """
    dns_policy: Annotated[Optional[str], Field(alias="dnsPolicy")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
    """
    enable_service_links: Annotated[Optional[bool], Field(alias="enableServiceLinks")] = None
    """
    EnableServiceLinks indicates whether information aboutservices should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
    """
    host_aliases: Annotated[Optional[List[Dict[str, Any]]], Field(alias="hostAliases")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostaliases
    """
    host_ipc: Annotated[Optional[bool], Field(alias="hostIPC")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostipc
    """
    host_network: Annotated[Optional[bool], Field(alias="hostNetwork")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostnetwork
    """
    host_pid: Annotated[Optional[bool], Field(alias="hostPID")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostpid
    """
    idle_timeout_seconds: Annotated[Optional[int], Field(alias="idleTimeoutSeconds")] = None
    """
    IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
    to stay open while not receiving any bytes from the user's application. If
    unspecified, a system default will be provided.
    """
    image_pull_secrets: Annotated[
        Optional[List[ImagePullSecret]], Field(alias="imagePullSecrets")
    ] = None
    """
    ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
    If specified, these secrets will be passed to individual puller implementations for them to use.
    More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
    """
    init_containers: Annotated[Optional[List[Dict[str, Any]]], Field(alias="initContainers")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-init-containers
    """
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-nodeselector
    """
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
    """
    response_start_timeout_seconds: Annotated[
        Optional[int], Field(alias="responseStartTimeoutSeconds")
    ] = None
    """
    ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
    routing layer will wait for a request delivered to a container to begin
    sending any network traffic.
    """
    runtime_class_name: Annotated[Optional[str], Field(alias="runtimeClassName")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
    """
    scheduler_name: Annotated[Optional[str], Field(alias="schedulerName")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-schedulername
    """
    security_context: Annotated[Optional[Dict[str, Any]], Field(alias="securityContext")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-securitycontext
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run this pod.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
    """
    share_process_namespace: Annotated[Optional[bool], Field(alias="shareProcessNamespace")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-shareprocessnamespace
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    TimeoutSeconds is the maximum duration in seconds that the request instance
    is allowed to respond to a request. If unspecified, a system default will
    be provided.
    """
    tolerations: Optional[List[Dict[str, Any]]] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-tolerations
    """
    topology_spread_constraints: Annotated[
        Optional[List[Dict[str, Any]]], Field(alias="topologySpreadConstraints")
    ] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
    """
    volumes: Optional[List[Volume]] = None
    """
    List of volumes that can be mounted by containers belonging to the pod.
    More info: https://kubernetes.io/docs/concepts/storage/volumes
    """


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        @overload
        def metadata(self, value_or_callback: Optional[Metadata], /) -> "Template.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "Template.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[Spec], /) -> "Template.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Callable[[Spec.Builder], Spec.Builder | Spec], /
        ) -> "Template.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "Spec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            RevisionSpec holds the desired state of the Revision (from the client).
            """
            if self._in_context and value_or_callback is None:
                context = Spec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spec.builder())
                if isinstance(output, Spec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[Metadata] = None
    spec: Optional[Spec] = None
    """
    RevisionSpec holds the desired state of the Revision (from the client).
    """


class ConfigurationSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationSpec"]:
            return ConfigurationSpec

        def build(self) -> "ConfigurationSpec":
            return ConfigurationSpec(**self._attrs)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ConfigurationSpec.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ConfigurationSpec.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            Template holds the latest specification for the Revision to be stamped out.
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ConfigurationSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    template: Optional[Template] = None
    """
    Template holds the latest specification for the Revision to be stamped out.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another.
            We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
            differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition.
            When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another.
    We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
    differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition.
    When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class ConfigurationStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigurationStatus"]:
            return ConfigurationStatus

        def build(self) -> "ConfigurationStatus":
            return ConfigurationStatus(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "ConfigurationStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ConfigurationStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_created_revision_name(self, value: Optional[str], /) -> Self:
            """
            LatestCreatedRevisionName is the last revision that was created from this
            Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
            """
            return self._set("latest_created_revision_name", value)

        def latest_ready_revision_name(self, value: Optional[str], /) -> Self:
            """
            LatestReadyRevisionName holds the name of the latest Revision stamped out
            from this Configuration that has had its "Ready" condition become "True".
            """
            return self._set("latest_ready_revision_name", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["ConfigurationStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigurationStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigurationStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigurationStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigurationStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_created_revision_name: Annotated[
        Optional[str], Field(alias="latestCreatedRevisionName")
    ] = None
    """
    LatestCreatedRevisionName is the last revision that was created from this
    Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
    """
    latest_ready_revision_name: Annotated[Optional[str], Field(alias="latestReadyRevisionName")] = (
        None
    )
    """
    LatestReadyRevisionName holds the name of the latest Revision stamped out
    from this Configuration that has had its "Ready" condition become "True".
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """


class LimitsModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel1":
            value = cast(int, self._value)
            return LimitsModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel1."""
        return cls.BuilderContext()


class LimitsModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel2":
            value = cast(str, self._value)
            return LimitsModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel2."""
        return cls.BuilderContext()


class RequestsModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel1":
            value = cast(int, self._value)
            return RequestsModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel1."""
        return cls.BuilderContext()


class RequestsModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel2":
            value = cast(str, self._value)
            return RequestsModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel2."""
        return cls.BuilderContext()


class ConfigMapModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel1"]:
            return ConfigMapModel1

        def build(self) -> "ConfigMapModel1":
            return ConfigMapModel1(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel1], /) -> "ConfigMapModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel1, ItemModel1.Builder]],
                GenericListBuilder[ItemModel1, ItemModel1.Builder] | List[ItemModel1],
            ],
            /,
        ) -> "ConfigMapModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel1.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel1.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel1]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class ConfigMapModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel2"]:
            return ConfigMapModel2

        def build(self) -> "ConfigMapModel2":
            return ConfigMapModel2(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel1], /) -> "ConfigMapModel2.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel1, ItemModel1.Builder]],
                GenericListBuilder[ItemModel1, ItemModel1.Builder] | List[ItemModel1],
            ],
            /,
        ) -> "ConfigMapModel2.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel1.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel1.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel1]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel1":
            value = cast(int, self._value)
            return DivisorModel1(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel1."""
        return cls.BuilderContext()


class DivisorModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel2":
            value = cast(str, self._value)
            return DivisorModel2(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel2."""
        return cls.BuilderContext()


class ItemModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel2"]:
            return ItemModel2

        def build(self) -> "ItemModel2":
            return ItemModel2(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel2.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel2.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel2.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel2.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class ItemModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel3"]:
            return ItemModel3

        def build(self) -> "ItemModel3":
            return ItemModel3(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class SecretModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel1"]:
            return SecretModel1

        def build(self) -> "SecretModel1":
            return SecretModel1(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "SecretModel1.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "SecretModel1.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel3]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class SecretModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel2"]:
            return SecretModel2

        def build(self) -> "SecretModel2":
            return SecretModel2(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "SecretModel2.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "SecretModel2.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel3]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class RevisionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RevisionSpec"]:
            return RevisionSpec

        def build(self) -> "RevisionSpec":
            return RevisionSpec(**self._attrs)

        def affinity(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-affinity
            """
            return self._set("affinity", value)

        def automount_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
            """
            return self._set("automount_service_account_token", value)

        def container_concurrency(self, value: Optional[int], /) -> Self:
            """
            ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
            requests per container of the Revision.  Defaults to `0` which means
            concurrency to the application is not limited, and the system decides the
            target concurrency for the autoscaler.
            """
            return self._set("container_concurrency", value)

        @overload
        def containers(self, value_or_callback: List[Container], /) -> "RevisionSpec.Builder": ...

        @overload
        def containers(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Container, Container.Builder]],
                GenericListBuilder[Container, Container.Builder] | List[Container],
            ],
            /,
        ) -> "RevisionSpec.Builder": ...

        @overload
        def containers(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Container.Builder]: ...

        def containers(self, value_or_callback=None, /):
            """
            List of containers belonging to the pod.
            Containers cannot currently be added or removed.
            There must be at least one container in a Pod.
            Cannot be updated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Container.Builder]()
                context._parent_builder = self
                context._field_name = "containers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Container.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("containers", value)

        def dns_config(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
            """
            return self._set("dns_config", value)

        def dns_policy(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
            """
            return self._set("dns_policy", value)

        def enable_service_links(self, value: Optional[bool], /) -> Self:
            """
            EnableServiceLinks indicates whether information aboutservices should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
            """
            return self._set("enable_service_links", value)

        def host_aliases(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostaliases
            """
            return self._set("host_aliases", value)

        def host_ipc(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostipc
            """
            return self._set("host_ipc", value)

        def host_network(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostnetwork
            """
            return self._set("host_network", value)

        def host_pid(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-hostpid
            """
            return self._set("host_pid", value)

        def idle_timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
            to stay open while not receiving any bytes from the user's application. If
            unspecified, a system default will be provided.
            """
            return self._set("idle_timeout_seconds", value)

        @overload
        def image_pull_secrets(
            self, value_or_callback: List[ImagePullSecret], /
        ) -> "RevisionSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]],
                GenericListBuilder[ImagePullSecret, ImagePullSecret.Builder]
                | List[ImagePullSecret],
            ],
            /,
        ) -> "RevisionSpec.Builder": ...

        @overload
        def image_pull_secrets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ImagePullSecret.Builder]: ...

        def image_pull_secrets(self, value_or_callback=None, /):
            """
            ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
            If specified, these secrets will be passed to individual puller implementations for them to use.
            More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ImagePullSecret.Builder]()
                context._parent_builder = self
                context._field_name = "image_pull_secrets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ImagePullSecret.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("image_pull_secrets", value)

        def init_containers(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-init-containers
            """
            return self._set("init_containers", value)

        def node_selector(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-nodeselector
            """
            return self._set("node_selector", value)

        def priority_class_name(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
            """
            return self._set("priority_class_name", value)

        def response_start_timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
            routing layer will wait for a request delivered to a container to begin
            sending any network traffic.
            """
            return self._set("response_start_timeout_seconds", value)

        def runtime_class_name(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
            """
            return self._set("runtime_class_name", value)

        def scheduler_name(self, value: Optional[str], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-schedulername
            """
            return self._set("scheduler_name", value)

        def security_context(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-securitycontext
            """
            return self._set("security_context", value)

        def service_account_name(self, value: Optional[str], /) -> Self:
            """
            ServiceAccountName is the name of the ServiceAccount to use to run this pod.
            More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
            """
            return self._set("service_account_name", value)

        def share_process_namespace(self, value: Optional[bool], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-shareprocessnamespace
            """
            return self._set("share_process_namespace", value)

        def timeout_seconds(self, value: Optional[int], /) -> Self:
            """
            TimeoutSeconds is the maximum duration in seconds that the request instance
            is allowed to respond to a request. If unspecified, a system default will
            be provided.
            """
            return self._set("timeout_seconds", value)

        def tolerations(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-tolerations
            """
            return self._set("tolerations", value)

        def topology_spread_constraints(self, value: Optional[List[Dict[str, Any]]], /) -> Self:
            """
            This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
            """
            return self._set("topology_spread_constraints", value)

        @overload
        def volumes(self, value_or_callback: List[Volume], /) -> "RevisionSpec.Builder": ...

        @overload
        def volumes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Volume, Volume.Builder]],
                GenericListBuilder[Volume, Volume.Builder] | List[Volume],
            ],
            /,
        ) -> "RevisionSpec.Builder": ...

        @overload
        def volumes(self, value_or_callback: Never = ...) -> ListBuilderContext[Volume.Builder]: ...

        def volumes(self, value_or_callback=None, /):
            """
            List of volumes that can be mounted by containers belonging to the pod.
            More info: https://kubernetes.io/docs/concepts/storage/volumes
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Volume.Builder]()
                context._parent_builder = self
                context._field_name = "volumes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Volume.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("volumes", value)

    class BuilderContext(BuilderContextBase["RevisionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RevisionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RevisionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RevisionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RevisionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    affinity: Optional[Dict[str, Any]] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-affinity
    """
    automount_service_account_token: Annotated[
        Optional[bool], Field(alias="automountServiceAccountToken")
    ] = None
    """
    AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
    """
    container_concurrency: Annotated[Optional[int], Field(alias="containerConcurrency")] = None
    """
    ContainerConcurrency specifies the maximum allowed in-flight (concurrent)
    requests per container of the Revision.  Defaults to `0` which means
    concurrency to the application is not limited, and the system decides the
    target concurrency for the autoscaler.
    """
    containers: List[Container]
    """
    List of containers belonging to the pod.
    Containers cannot currently be added or removed.
    There must be at least one container in a Pod.
    Cannot be updated.
    """
    dns_config: Annotated[Optional[Dict[str, Any]], Field(alias="dnsConfig")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-dnsconfig
    """
    dns_policy: Annotated[Optional[str], Field(alias="dnsPolicy")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-dnspolicy
    """
    enable_service_links: Annotated[Optional[bool], Field(alias="enableServiceLinks")] = None
    """
    EnableServiceLinks indicates whether information aboutservices should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Knative defaults this to false.
    """
    host_aliases: Annotated[Optional[List[Dict[str, Any]]], Field(alias="hostAliases")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostaliases
    """
    host_ipc: Annotated[Optional[bool], Field(alias="hostIPC")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostipc
    """
    host_network: Annotated[Optional[bool], Field(alias="hostNetwork")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostnetwork
    """
    host_pid: Annotated[Optional[bool], Field(alias="hostPID")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-hostpid
    """
    idle_timeout_seconds: Annotated[Optional[int], Field(alias="idleTimeoutSeconds")] = None
    """
    IdleTimeoutSeconds is the maximum duration in seconds a request will be allowed
    to stay open while not receiving any bytes from the user's application. If
    unspecified, a system default will be provided.
    """
    image_pull_secrets: Annotated[
        Optional[List[ImagePullSecret]], Field(alias="imagePullSecrets")
    ] = None
    """
    ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
    If specified, these secrets will be passed to individual puller implementations for them to use.
    More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
    """
    init_containers: Annotated[Optional[List[Dict[str, Any]]], Field(alias="initContainers")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-init-containers
    """
    node_selector: Annotated[Optional[Dict[str, str]], Field(alias="nodeSelector")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-nodeselector
    """
    priority_class_name: Annotated[Optional[str], Field(alias="priorityClassName")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-priorityclassname
    """
    response_start_timeout_seconds: Annotated[
        Optional[int], Field(alias="responseStartTimeoutSeconds")
    ] = None
    """
    ResponseStartTimeoutSeconds is the maximum duration in seconds that the request
    routing layer will wait for a request delivered to a container to begin
    sending any network traffic.
    """
    runtime_class_name: Annotated[Optional[str], Field(alias="runtimeClassName")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-runtimeclassname
    """
    scheduler_name: Annotated[Optional[str], Field(alias="schedulerName")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-schedulername
    """
    security_context: Annotated[Optional[Dict[str, Any]], Field(alias="securityContext")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-securitycontext
    """
    service_account_name: Annotated[Optional[str], Field(alias="serviceAccountName")] = None
    """
    ServiceAccountName is the name of the ServiceAccount to use to run this pod.
    More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
    """
    share_process_namespace: Annotated[Optional[bool], Field(alias="shareProcessNamespace")] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-shareprocessnamespace
    """
    timeout_seconds: Annotated[Optional[int], Field(alias="timeoutSeconds")] = None
    """
    TimeoutSeconds is the maximum duration in seconds that the request instance
    is allowed to respond to a request. If unspecified, a system default will
    be provided.
    """
    tolerations: Optional[List[Dict[str, Any]]] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-tolerations
    """
    topology_spread_constraints: Annotated[
        Optional[List[Dict[str, Any]]], Field(alias="topologySpreadConstraints")
    ] = None
    """
    This is accessible behind a feature flag - kubernetes.podspec-topologyspreadconstraints
    """
    volumes: Optional[List[Volume]] = None
    """
    List of volumes that can be mounted by containers belonging to the pod.
    More info: https://kubernetes.io/docs/concepts/storage/volumes
    """


class ContainerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ContainerStatus"]:
            return ContainerStatus

        def build(self) -> "ContainerStatus":
            return ContainerStatus(**self._attrs)

        def image_digest(self, value: Optional[str], /) -> Self:
            return self._set("image_digest", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ContainerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ContainerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ContainerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ContainerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ContainerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image_digest: Annotated[Optional[str], Field(alias="imageDigest")] = None
    name: Optional[str] = None


class InitContainerStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InitContainerStatus"]:
            return InitContainerStatus

        def build(self) -> "InitContainerStatus":
            return InitContainerStatus(**self._attrs)

        def image_digest(self, value: Optional[str], /) -> Self:
            return self._set("image_digest", value)

        def name(self, value: Optional[str], /) -> Self:
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["InitContainerStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitContainerStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitContainerStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InitContainerStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InitContainerStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    image_digest: Annotated[Optional[str], Field(alias="imageDigest")] = None
    name: Optional[str] = None


class RevisionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RevisionStatus"]:
            return RevisionStatus

        def build(self) -> "RevisionStatus":
            return RevisionStatus(**self._attrs)

        def actual_replicas(self, value: Optional[int], /) -> Self:
            """
            ActualReplicas reflects the amount of ready pods running this revision.
            """
            return self._set("actual_replicas", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "RevisionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "RevisionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def container_statuses(
            self, value_or_callback: List[ContainerStatus], /
        ) -> "RevisionStatus.Builder": ...

        @overload
        def container_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ContainerStatus, ContainerStatus.Builder]],
                GenericListBuilder[ContainerStatus, ContainerStatus.Builder]
                | List[ContainerStatus],
            ],
            /,
        ) -> "RevisionStatus.Builder": ...

        @overload
        def container_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ContainerStatus.Builder]: ...

        def container_statuses(self, value_or_callback=None, /):
            """
            ContainerStatuses is a slice of images present in .Spec.Container[*].Image
            to their respective digests and their container name.
            The digests are resolved during the creation of Revision.
            ContainerStatuses holds the container name and image digests
            for both serving and non serving containers.
            ref: http://bit.ly/image-digests
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ContainerStatus.Builder]()
                context._parent_builder = self
                context._field_name = "container_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ContainerStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("container_statuses", value)

        def desired_replicas(self, value: Optional[int], /) -> Self:
            """
            DesiredReplicas reflects the desired amount of pods running this revision.
            """
            return self._set("desired_replicas", value)

        @overload
        def init_container_statuses(
            self, value_or_callback: List[InitContainerStatus], /
        ) -> "RevisionStatus.Builder": ...

        @overload
        def init_container_statuses(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[InitContainerStatus, InitContainerStatus.Builder]],
                GenericListBuilder[InitContainerStatus, InitContainerStatus.Builder]
                | List[InitContainerStatus],
            ],
            /,
        ) -> "RevisionStatus.Builder": ...

        @overload
        def init_container_statuses(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[InitContainerStatus.Builder]: ...

        def init_container_statuses(self, value_or_callback=None, /):
            """
            InitContainerStatuses is a slice of images present in .Spec.InitContainer[*].Image
            to their respective digests and their container name.
            The digests are resolved during the creation of Revision.
            ContainerStatuses holds the container name and image digests
            for both serving and non serving containers.
            ref: http://bit.ly/image-digests
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[InitContainerStatus.Builder]()
                context._parent_builder = self
                context._field_name = "init_container_statuses"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InitContainerStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("init_container_statuses", value)

        def log_url(self, value: Optional[str], /) -> Self:
            """
            LogURL specifies the generated logging url for this particular revision
            based on the revision url template specified in the controller's config.
            """
            return self._set("log_url", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

    class BuilderContext(BuilderContextBase["RevisionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RevisionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RevisionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RevisionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RevisionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    actual_replicas: Annotated[Optional[int], Field(alias="actualReplicas")] = None
    """
    ActualReplicas reflects the amount of ready pods running this revision.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    container_statuses: Annotated[
        Optional[List[ContainerStatus]], Field(alias="containerStatuses")
    ] = None
    """
    ContainerStatuses is a slice of images present in .Spec.Container[*].Image
    to their respective digests and their container name.
    The digests are resolved during the creation of Revision.
    ContainerStatuses holds the container name and image digests
    for both serving and non serving containers.
    ref: http://bit.ly/image-digests
    """
    desired_replicas: Annotated[Optional[int], Field(alias="desiredReplicas")] = None
    """
    DesiredReplicas reflects the desired amount of pods running this revision.
    """
    init_container_statuses: Annotated[
        Optional[List[InitContainerStatus]], Field(alias="initContainerStatuses")
    ] = None
    """
    InitContainerStatuses is a slice of images present in .Spec.InitContainer[*].Image
    to their respective digests and their container name.
    The digests are resolved during the creation of Revision.
    ContainerStatuses holds the container name and image digests
    for both serving and non serving containers.
    ref: http://bit.ly/image-digests
    """
    log_url: Annotated[Optional[str], Field(alias="logUrl")] = None
    """
    LogURL specifies the generated logging url for this particular revision
    based on the revision url template specified in the controller's config.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """


class Traffic(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Traffic"]:
            return Traffic

        def build(self) -> "Traffic":
            return Traffic(**self._attrs)

        def configuration_name(self, value: Optional[str], /) -> Self:
            """
            ConfigurationName of a configuration to whose latest revision we will send
            this portion of traffic. When the "status.latestReadyRevisionName" of the
            referenced configuration changes, we will automatically migrate traffic
            from the prior "latest ready" revision to the new one.  This field is never
            set in Route's status, only its spec.  This is mutually exclusive with
            RevisionName.
            """
            return self._set("configuration_name", value)

        def latest_revision(self, value: Optional[bool], /) -> Self:
            """
            LatestRevision may be optionally provided to indicate that the latest
            ready Revision of the Configuration should be used for this traffic
            target.  When provided LatestRevision must be true if RevisionName is
            empty; it must be false when RevisionName is non-empty.
            """
            return self._set("latest_revision", value)

        def percent(self, value: Optional[int], /) -> Self:
            """
            Percent indicates that percentage based routing should be used and
            the value indicates the percent of traffic that is be routed to this
            Revision or Configuration. `0` (zero) mean no traffic, `100` means all
            traffic.
            When percentage based routing is being used the follow rules apply:
            - the sum of all percent values must equal 100
            - when not specified, the implied value for `percent` is zero for
              that particular Revision or Configuration
            """
            return self._set("percent", value)

        def revision_name(self, value: Optional[str], /) -> Self:
            """
            RevisionName of a specific revision to which to send this portion of
            traffic.  This is mutually exclusive with ConfigurationName.
            """
            return self._set("revision_name", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Tag is optionally used to expose a dedicated url for referencing
            this target exclusively.
            """
            return self._set("tag", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL displays the URL for accessing named traffic targets. URL is displayed in
            status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
            a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Traffic.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Traffic.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Traffic."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Traffic", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Traffic.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    configuration_name: Annotated[Optional[str], Field(alias="configurationName")] = None
    """
    ConfigurationName of a configuration to whose latest revision we will send
    this portion of traffic. When the "status.latestReadyRevisionName" of the
    referenced configuration changes, we will automatically migrate traffic
    from the prior "latest ready" revision to the new one.  This field is never
    set in Route's status, only its spec.  This is mutually exclusive with
    RevisionName.
    """
    latest_revision: Annotated[Optional[bool], Field(alias="latestRevision")] = None
    """
    LatestRevision may be optionally provided to indicate that the latest
    ready Revision of the Configuration should be used for this traffic
    target.  When provided LatestRevision must be true if RevisionName is
    empty; it must be false when RevisionName is non-empty.
    """
    percent: Optional[int] = None
    """
    Percent indicates that percentage based routing should be used and
    the value indicates the percent of traffic that is be routed to this
    Revision or Configuration. `0` (zero) mean no traffic, `100` means all
    traffic.
    When percentage based routing is being used the follow rules apply:
    - the sum of all percent values must equal 100
    - when not specified, the implied value for `percent` is zero for
      that particular Revision or Configuration
    """
    revision_name: Annotated[Optional[str], Field(alias="revisionName")] = None
    """
    RevisionName of a specific revision to which to send this portion of
    traffic.  This is mutually exclusive with ConfigurationName.
    """
    tag: Optional[str] = None
    """
    Tag is optionally used to expose a dedicated url for referencing
    this target exclusively.
    """
    url: Optional[str] = None
    """
    URL displays the URL for accessing named traffic targets. URL is displayed in
    status, and is disallowed on spec. URL must contain a scheme (e.g. http://) and
    a hostname, but may not contain anything else (e.g. basic auth, url path, etc.)
    """


class RouteSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RouteSpec"]:
            return RouteSpec

        def build(self) -> "RouteSpec":
            return RouteSpec(**self._attrs)

        @overload
        def traffic(self, value_or_callback: List[Traffic], /) -> "RouteSpec.Builder": ...

        @overload
        def traffic(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Traffic, Traffic.Builder]],
                GenericListBuilder[Traffic, Traffic.Builder] | List[Traffic],
            ],
            /,
        ) -> "RouteSpec.Builder": ...

        @overload
        def traffic(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Traffic.Builder]: ...

        def traffic(self, value_or_callback=None, /):
            """
            Traffic specifies how to distribute traffic over a collection of
            revisions and configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Traffic.Builder]()
                context._parent_builder = self
                context._field_name = "traffic"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Traffic.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("traffic", value)

    class BuilderContext(BuilderContextBase["RouteSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RouteSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RouteSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RouteSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RouteSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    traffic: Optional[List[Traffic]] = None
    """
    Traffic specifies how to distribute traffic over a collection of
    revisions and configurations.
    """


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format
            according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience for this address.
            """
            return self._set("audience", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the name of the address.
            """
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format
    according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience for this address.
    """
    name: Optional[str] = None
    """
    Name is the name of the address.
    """
    url: Optional[str] = None


class RouteStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RouteStatus"]:
            return RouteStatus

        def build(self) -> "RouteStatus":
            return RouteStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "RouteStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "RouteStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Address holds the information needed for a Route to be the target of an event.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "RouteStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "RouteStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def traffic(self, value_or_callback: List[Traffic], /) -> "RouteStatus.Builder": ...

        @overload
        def traffic(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Traffic, Traffic.Builder]],
                GenericListBuilder[Traffic, Traffic.Builder] | List[Traffic],
            ],
            /,
        ) -> "RouteStatus.Builder": ...

        @overload
        def traffic(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Traffic.Builder]: ...

        def traffic(self, value_or_callback=None, /):
            """
            Traffic holds the configured traffic distribution.
            These entries will always contain RevisionName references.
            When ConfigurationName appears in the spec, this will hold the
            LatestReadyRevisionName that we last observed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Traffic.Builder]()
                context._parent_builder = self
                context._field_name = "traffic"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Traffic.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("traffic", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL holds the url that will distribute traffic over the provided traffic targets.
            It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["RouteStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RouteStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RouteStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RouteStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RouteStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Address holds the information needed for a Route to be the target of an event.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """
    traffic: Optional[List[Traffic]] = None
    """
    Traffic holds the configured traffic distribution.
    These entries will always contain RevisionName references.
    When ConfigurationName appears in the spec, this will hold the
    LatestReadyRevisionName that we last observed.
    """
    url: Optional[str] = None
    """
    URL holds the url that will distribute traffic over the provided traffic targets.
    It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
    """


class LimitsModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel3":
            value = cast(int, self._value)
            return LimitsModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel3."""
        return cls.BuilderContext()


class LimitsModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "LimitsModel4":
            value = cast(str, self._value)
            return LimitsModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["LimitsModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = LimitsModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for LimitsModel4."""
        return cls.BuilderContext()


class RequestsModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel3":
            value = cast(int, self._value)
            return RequestsModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel3."""
        return cls.BuilderContext()


class RequestsModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "RequestsModel4":
            value = cast(str, self._value)
            return RequestsModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]

    class BuilderContext(BuilderContextBase["RequestsModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RequestsModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RequestsModel4."""
        return cls.BuilderContext()


class ConfigMapModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel3"]:
            return ConfigMapModel3

        def build(self) -> "ConfigMapModel3":
            return ConfigMapModel3(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "ConfigMapModel3.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "ConfigMapModel3.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel3]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class ConfigMapModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConfigMapModel4"]:
            return ConfigMapModel4

        def build(self) -> "ConfigMapModel4":
            return ConfigMapModel4(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel3], /) -> "ConfigMapModel4.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel3, ItemModel3.Builder]],
                GenericListBuilder[ItemModel3, ItemModel3.Builder] | List[ItemModel3],
            ],
            /,
        ) -> "ConfigMapModel4.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel3.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            ConfigMap will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the ConfigMap,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel3.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel3.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional specify whether the ConfigMap or its keys must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["ConfigMapModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConfigMapModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConfigMapModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConfigMapModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConfigMapModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel3]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    ConfigMap will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the ConfigMap,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional specify whether the ConfigMap or its keys must be defined
    """


class DivisorModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel3":
            value = cast(int, self._value)
            return DivisorModel3(value)

    root: Annotated[
        int,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel3."""
        return cls.BuilderContext()


class DivisorModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            Specifies the output format of the exposed resources, defaults to "1"
            """
            self._value = value
            return self

        def build(self) -> "DivisorModel4":
            value = cast(str, self._value)
            return DivisorModel4(value)

    root: Annotated[
        str,
        Field(
            pattern="^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
        ),
    ]
    """
    Specifies the output format of the exposed resources, defaults to "1"
    """

    class BuilderContext(BuilderContextBase["DivisorModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DivisorModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DivisorModel4."""
        return cls.BuilderContext()


class ItemModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel4"]:
            return ItemModel4

        def build(self) -> "ItemModel4":
            return ItemModel4(**self._attrs)

        @overload
        def field_ref(self, value_or_callback: Optional[FieldRef], /) -> "ItemModel4.Builder": ...

        @overload
        def field_ref(
            self,
            value_or_callback: Callable[[FieldRef.Builder], FieldRef.Builder | FieldRef],
            /,
        ) -> "ItemModel4.Builder": ...

        @overload
        def field_ref(self, value_or_callback: Never = ...) -> "FieldRef.BuilderContext": ...

        def field_ref(self, value_or_callback=None, /):
            """
            Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
            """
            if self._in_context and value_or_callback is None:
                context = FieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FieldRef.builder())
                if isinstance(output, FieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("field_ref", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            Optional: mode bits used to set permissions on this file, must be an octal value
            between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
            """
            return self._set("path", value)

        @overload
        def resource_field_ref(
            self, value_or_callback: Optional[ResourceFieldRef], /
        ) -> "ItemModel4.Builder": ...

        @overload
        def resource_field_ref(
            self,
            value_or_callback: Callable[
                [ResourceFieldRef.Builder], ResourceFieldRef.Builder | ResourceFieldRef
            ],
            /,
        ) -> "ItemModel4.Builder": ...

        @overload
        def resource_field_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceFieldRef.BuilderContext": ...

        def resource_field_ref(self, value_or_callback=None, /):
            """
            Selects a resource of the container: only resources limits and requests
            (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceFieldRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "resource_field_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFieldRef.builder())
                if isinstance(output, ResourceFieldRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_field_ref", value)

    class BuilderContext(BuilderContextBase["ItemModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_ref: Annotated[Optional[FieldRef], Field(alias="fieldRef")] = None
    """
    Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
    """
    mode: Optional[int] = None
    """
    Optional: mode bits used to set permissions on this file, must be an octal value
    between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
    """
    resource_field_ref: Annotated[Optional[ResourceFieldRef], Field(alias="resourceFieldRef")] = (
        None
    )
    """
    Selects a resource of the container: only resources limits and requests
    (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
    """


class ItemModel5(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ItemModel5"]:
            return ItemModel5

        def build(self) -> "ItemModel5":
            return ItemModel5(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            key is the key to project.
            """
            return self._set("key", value)

        def mode(self, value: Optional[int], /) -> Self:
            """
            mode is Optional: mode bits used to set permissions on this file.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
            If not specified, the volume defaultMode will be used.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("mode", value)

        def path(self, value: str, /) -> Self:
            """
            path is the relative path of the file to map the key to.
            May not be an absolute path.
            May not contain the path element '..'.
            May not start with the string '..'.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ItemModel5.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ItemModel5.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ItemModel5."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ItemModel5", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ItemModel5.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    key is the key to project.
    """
    mode: Optional[int] = None
    """
    mode is Optional: mode bits used to set permissions on this file.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
    If not specified, the volume defaultMode will be used.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    path: str
    """
    path is the relative path of the file to map the key to.
    May not be an absolute path.
    May not contain the path element '..'.
    May not start with the string '..'.
    """


class SecretModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel3"]:
            return SecretModel3

        def build(self) -> "SecretModel3":
            return SecretModel3(**self._attrs)

        @overload
        def items(self, value_or_callback: List[ItemModel5], /) -> "SecretModel3.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel5, ItemModel5.Builder]],
                GenericListBuilder[ItemModel5, ItemModel5.Builder] | List[ItemModel5],
            ],
            /,
        ) -> "SecretModel3.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel5.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items if unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel5.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel5.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the referent.
            This field is effectively required, but due to backwards compatibility is
            allowed to be empty. Instances of this type with an empty value here are
            almost certainly wrong.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its key must be defined
            """
            return self._set("optional", value)

    class BuilderContext(BuilderContextBase["SecretModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    items: Optional[List[ItemModel5]] = None
    """
    items if unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    name: Optional[str] = ""
    """
    Name of the referent.
    This field is effectively required, but due to backwards compatibility is
    allowed to be empty. Instances of this type with an empty value here are
    almost certainly wrong.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its key must be defined
    """


class SecretModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretModel4"]:
            return SecretModel4

        def build(self) -> "SecretModel4":
            return SecretModel4(**self._attrs)

        def default_mode(self, value: Optional[int], /) -> Self:
            """
            defaultMode is Optional: mode bits used to set permissions on created files by default.
            Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
            YAML accepts both octal and decimal values, JSON requires decimal values
            for mode bits. Defaults to 0644.
            Directories within the path are not affected by this setting.
            This might be in conflict with other options that affect the file
            mode, like fsGroup, and the result can be other mode bits set.
            """
            return self._set("default_mode", value)

        @overload
        def items(self, value_or_callback: List[ItemModel5], /) -> "SecretModel4.Builder": ...

        @overload
        def items(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ItemModel5, ItemModel5.Builder]],
                GenericListBuilder[ItemModel5, ItemModel5.Builder] | List[ItemModel5],
            ],
            /,
        ) -> "SecretModel4.Builder": ...

        @overload
        def items(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ItemModel5.Builder]: ...

        def items(self, value_or_callback=None, /):
            """
            items If unspecified, each key-value pair in the Data field of the referenced
            Secret will be projected into the volume as a file whose name is the
            key and content is the value. If specified, the listed keys will be
            projected into the specified paths, and unlisted keys will not be
            present. If a key is specified which is not present in the Secret,
            the volume setup will error unless it is marked optional. Paths must be
            relative and may not contain the '..' path or start with '..'.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ItemModel5.Builder]()
                context._parent_builder = self
                context._field_name = "items"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ItemModel5.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("items", value)

        def optional(self, value: Optional[bool], /) -> Self:
            """
            optional field specify whether the Secret or its keys must be defined
            """
            return self._set("optional", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            secretName is the name of the secret in the pod's namespace to use.
            More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["SecretModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_mode: Annotated[Optional[int], Field(alias="defaultMode")] = None
    """
    defaultMode is Optional: mode bits used to set permissions on created files by default.
    Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
    YAML accepts both octal and decimal values, JSON requires decimal values
    for mode bits. Defaults to 0644.
    Directories within the path are not affected by this setting.
    This might be in conflict with other options that affect the file
    mode, like fsGroup, and the result can be other mode bits set.
    """
    items: Optional[List[ItemModel5]] = None
    """
    items If unspecified, each key-value pair in the Data field of the referenced
    Secret will be projected into the volume as a file whose name is the
    key and content is the value. If specified, the listed keys will be
    projected into the specified paths, and unlisted keys will not be
    present. If a key is specified which is not present in the Secret,
    the volume setup will error unless it is marked optional. Paths must be
    relative and may not contain the '..' path or start with '..'.
    """
    optional: Optional[bool] = None
    """
    optional field specify whether the Secret or its keys must be defined
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    secretName is the name of the secret in the pod's namespace to use.
    More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """


class ServiceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceSpec"]:
            return ServiceSpec

        def build(self) -> "ServiceSpec":
            return ServiceSpec(**self._attrs)

        @overload
        def template(self, value_or_callback: Optional[Template], /) -> "ServiceSpec.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ServiceSpec.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            Template holds the latest specification for the Revision to be stamped out.
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

        @overload
        def traffic(self, value_or_callback: List[Traffic], /) -> "ServiceSpec.Builder": ...

        @overload
        def traffic(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Traffic, Traffic.Builder]],
                GenericListBuilder[Traffic, Traffic.Builder] | List[Traffic],
            ],
            /,
        ) -> "ServiceSpec.Builder": ...

        @overload
        def traffic(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Traffic.Builder]: ...

        def traffic(self, value_or_callback=None, /):
            """
            Traffic specifies how to distribute traffic over a collection of
            revisions and configurations.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Traffic.Builder]()
                context._parent_builder = self
                context._field_name = "traffic"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Traffic.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("traffic", value)

    class BuilderContext(BuilderContextBase["ServiceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    template: Optional[Template] = None
    """
    Template holds the latest specification for the Revision to be stamped out.
    """
    traffic: Optional[List[Traffic]] = None
    """
    Traffic specifies how to distribute traffic over a collection of
    revisions and configurations.
    """


class ServiceStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceStatus"]:
            return ServiceStatus

        def build(self) -> "ServiceStatus":
            return ServiceStatus(**self._attrs)

        @overload
        def address(self, value_or_callback: Optional[Address], /) -> "ServiceStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "ServiceStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Address holds the information needed for a Route to be the target of an event.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(self, value_or_callback: List[Condition], /) -> "ServiceStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "ServiceStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def latest_created_revision_name(self, value: Optional[str], /) -> Self:
            """
            LatestCreatedRevisionName is the last revision that was created from this
            Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
            """
            return self._set("latest_created_revision_name", value)

        def latest_ready_revision_name(self, value: Optional[str], /) -> Self:
            """
            LatestReadyRevisionName holds the name of the latest Revision stamped out
            from this Configuration that has had its "Ready" condition become "True".
            """
            return self._set("latest_ready_revision_name", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

        @overload
        def traffic(self, value_or_callback: List[Traffic], /) -> "ServiceStatus.Builder": ...

        @overload
        def traffic(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Traffic, Traffic.Builder]],
                GenericListBuilder[Traffic, Traffic.Builder] | List[Traffic],
            ],
            /,
        ) -> "ServiceStatus.Builder": ...

        @overload
        def traffic(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Traffic.Builder]: ...

        def traffic(self, value_or_callback=None, /):
            """
            Traffic holds the configured traffic distribution.
            These entries will always contain RevisionName references.
            When ConfigurationName appears in the spec, this will hold the
            LatestReadyRevisionName that we last observed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Traffic.Builder]()
                context._parent_builder = self
                context._field_name = "traffic"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Traffic.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("traffic", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL holds the url that will distribute traffic over the provided traffic targets.
            It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["ServiceStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Address holds the information needed for a Route to be the target of an event.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    latest_created_revision_name: Annotated[
        Optional[str], Field(alias="latestCreatedRevisionName")
    ] = None
    """
    LatestCreatedRevisionName is the last revision that was created from this
    Configuration. It might not be ready yet, for that use LatestReadyRevisionName.
    """
    latest_ready_revision_name: Annotated[Optional[str], Field(alias="latestReadyRevisionName")] = (
        None
    )
    """
    LatestReadyRevisionName holds the name of the latest Revision stamped out
    from this Configuration that has had its "Ready" condition become "True".
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """
    traffic: Optional[List[Traffic]] = None
    """
    Traffic holds the configured traffic distribution.
    These entries will always contain RevisionName references.
    When ConfigurationName appears in the spec, this will hold the
    LatestReadyRevisionName that we last observed.
    """
    url: Optional[str] = None
    """
    URL holds the url that will distribute traffic over the provided traffic targets.
    It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}
    """


class Configuration(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Configuration"]:
            return Configuration

        def build(self) -> "Configuration":
            return Configuration(**self._attrs)

        def api_version(self, value: Optional[Literal["serving.knative.dev/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Configuration"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Configuration.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Configuration.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[ConfigurationSpec], /
        ) -> "Configuration.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ConfigurationSpec.Builder],
                ConfigurationSpec.Builder | ConfigurationSpec,
            ],
            /,
        ) -> "Configuration.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ConfigurationSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConfigurationSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigurationSpec.builder())
                if isinstance(output, ConfigurationSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ConfigurationStatus], /
        ) -> "Configuration.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ConfigurationStatus.Builder],
                ConfigurationStatus.Builder | ConfigurationStatus,
            ],
            /,
        ) -> "Configuration.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ConfigurationStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ConfigurationStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConfigurationStatus.builder())
                if isinstance(output, ConfigurationStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Configuration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Configuration.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Configuration."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Configuration", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Configuration.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["serving.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "serving.knative.dev/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Configuration"]] = "Configuration"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ConfigurationSpec] = None
    status: Optional[ConfigurationStatus] = None


class Revision(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Revision"]:
            return Revision

        def build(self) -> "Revision":
            return Revision(**self._attrs)

        def api_version(self, value: Optional[Literal["serving.knative.dev/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Revision"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Revision.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Revision.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[RevisionSpec], /) -> "Revision.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [RevisionSpec.Builder], RevisionSpec.Builder | RevisionSpec
            ],
            /,
        ) -> "Revision.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "RevisionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RevisionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RevisionSpec.builder())
                if isinstance(output, RevisionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[RevisionStatus], /) -> "Revision.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [RevisionStatus.Builder], RevisionStatus.Builder | RevisionStatus
            ],
            /,
        ) -> "Revision.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "RevisionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RevisionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RevisionStatus.builder())
                if isinstance(output, RevisionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Revision.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Revision.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Revision."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Revision", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Revision.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["serving.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "serving.knative.dev/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Revision"]] = "Revision"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[RevisionSpec] = None
    status: Optional[RevisionStatus] = None


class Route(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Route"]:
            return Route

        def build(self) -> "Route":
            return Route(**self._attrs)

        def api_version(self, value: Optional[Literal["serving.knative.dev/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Route"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Route.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Route.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[RouteSpec], /) -> "Route.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[RouteSpec.Builder], RouteSpec.Builder | RouteSpec],
            /,
        ) -> "Route.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "RouteSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RouteSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RouteSpec.builder())
                if isinstance(output, RouteSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[RouteStatus], /) -> "Route.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[[RouteStatus.Builder], RouteStatus.Builder | RouteStatus],
            /,
        ) -> "Route.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "RouteStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = RouteStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RouteStatus.builder())
                if isinstance(output, RouteStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Route.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Route.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Route."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Route", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Route.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["serving.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "serving.knative.dev/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Route"]] = "Route"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[RouteSpec] = None
    status: Optional[RouteStatus] = None


class Service(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

        def api_version(self, value: Optional[Literal["serving.knative.dev/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Service"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "Service.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[ServiceSpec], /) -> "Service.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[[ServiceSpec.Builder], ServiceSpec.Builder | ServiceSpec],
            /,
        ) -> "Service.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ServiceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceSpec.builder())
                if isinstance(output, ServiceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(self, value_or_callback: Optional[ServiceStatus], /) -> "Service.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ServiceStatus.Builder], ServiceStatus.Builder | ServiceStatus
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "ServiceStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceStatus.builder())
                if isinstance(output, ServiceStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["serving.knative.dev/v1"]], Field(alias="apiVersion")
    ] = "serving.knative.dev/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Service"]] = "Service"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[ServiceSpec] = None
    status: Optional[ServiceStatus] = None
