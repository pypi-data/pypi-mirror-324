# Generated by cloudcoil-model-codegen v0.4.1
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def address(self, value: Optional[str], /) -> Self:
            """
            Address points to a specific Address Name.
            """
            return self._set("address", value)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            API version of the referent.
            """
            return self._set("api_version", value)

        def group(self, value: Optional[str], /) -> Self:
            """
            Group of the API, without the version of the group. This can be used as an alternative to the APIVersion, and then resolved using ResolveGroup.
            Note: This API is EXPERIMENTAL and might break anytime. For more details: https://github.com/knative/eventing/issues/5086
            """
            return self._set("group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the referent.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace of the referent.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            This is optional field, it gets defaulted to the object holding it if left out.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[str] = None
    """
    Address points to a specific Address Name.
    """
    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    API version of the referent.
    """
    group: Optional[str] = None
    """
    Group of the API, without the version of the group. This can be used as an alternative to the APIVersion, and then resolved using ResolveGroup.
    Note: This API is EXPERIMENTAL and might break anytime. For more details: https://github.com/knative/eventing/issues/5086
    """
    kind: str
    """
    Kind of the referent.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    name: str
    """
    Name of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    """
    namespace: Optional[str] = None
    """
    Namespace of the referent.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    This is optional field, it gets defaulted to the object holding it if left out.
    """


class Tls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tls"]:
            return Tls

        def build(self) -> "Tls":
            return Tls(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            SecretName is the name of the existing secret used to terminate TLS traffic.
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["Tls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    SecretName is the name of the existing secret used to terminate TLS traffic.
    """


class DomainMappingSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DomainMappingSpec"]:
            return DomainMappingSpec

        def build(self) -> "DomainMappingSpec":
            return DomainMappingSpec(**self._attrs)

        @overload
        def ref(self, value_or_callback: Ref, /) -> "DomainMappingSpec.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "DomainMappingSpec.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref specifies the target of the Domain Mapping.

            The object identified by the Ref must be an Addressable with a URL of the
            form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain,
            and `{name}` and `{namespace}` are the name and namespace of a Kubernetes
            Service.

            This contract is satisfied by Knative types such as Knative Services and
            Knative Routes, and by Kubernetes Services.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "DomainMappingSpec.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "DomainMappingSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
            """
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["DomainMappingSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DomainMappingSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DomainMappingSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DomainMappingSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DomainMappingSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Ref
    """
    Ref specifies the target of the Domain Mapping.

    The object identified by the Ref must be an Addressable with a URL of the
    form `{name}.{namespace}.{domain}` where `{domain}` is the cluster domain,
    and `{name}` and `{namespace}` are the name and namespace of a Kubernetes
    Service.

    This contract is satisfied by Knative types such as Knative Services and
    Knative Routes, and by Kubernetes Services.
    """
    tls: Optional[Tls] = None
    """
    TLS allows the DomainMapping to terminate TLS traffic with an existing secret.
    """


class Address(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Address"]:
            return Address

        def build(self) -> "Address":
            return Address(**self._attrs)

        def ca_certs(self, value: Optional[str], /) -> Self:
            """
            CACerts is the Certification Authority (CA) certificates in PEM format
            according to https://www.rfc-editor.org/rfc/rfc7468.
            """
            return self._set("ca_certs", value)

        def audience(self, value: Optional[str], /) -> Self:
            """
            Audience is the OIDC audience for this address.
            """
            return self._set("audience", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name is the name of the address.
            """
            return self._set("name", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Address.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Address.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Address."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Address", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Address.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_certs: Annotated[Optional[str], Field(alias="CACerts")] = None
    """
    CACerts is the Certification Authority (CA) certificates in PEM format
    according to https://www.rfc-editor.org/rfc/rfc7468.
    """
    audience: Optional[str] = None
    """
    Audience is the OIDC audience for this address.
    """
    name: Optional[str] = None
    """
    Name is the name of the address.
    """
    url: Optional[str] = None


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: Optional[str], /) -> Self:
            """
            LastTransitionTime is the last time the condition transitioned from one status to another.
            We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
            differences (all other things held constant).
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A human readable message indicating details about the transition.
            """
            return self._set("message", value)

        def reason(self, value: Optional[str], /) -> Self:
            """
            The reason for the condition's last transition.
            """
            return self._set("reason", value)

        def severity(self, value: Optional[str], /) -> Self:
            """
            Severity with which to treat failures of this type of condition.
            When this is not specified, it defaults to Error.
            """
            return self._set("severity", value)

        def status(self, value: str, /) -> Self:
            """
            Status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of condition.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[Optional[str], Field(alias="lastTransitionTime")] = None
    """
    LastTransitionTime is the last time the condition transitioned from one status to another.
    We use VolatileTime in place of metav1.Time to exclude this from creating equality.Semantic
    differences (all other things held constant).
    """
    message: Optional[str] = None
    """
    A human readable message indicating details about the transition.
    """
    reason: Optional[str] = None
    """
    The reason for the condition's last transition.
    """
    severity: Optional[str] = None
    """
    Severity with which to treat failures of this type of condition.
    When this is not specified, it defaults to Error.
    """
    status: str
    """
    Status of the condition, one of True, False, Unknown.
    """
    type: str
    """
    Type of condition.
    """


class DomainMappingStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DomainMappingStatus"]:
            return DomainMappingStatus

        def build(self) -> "DomainMappingStatus":
            return DomainMappingStatus(**self._attrs)

        @overload
        def address(
            self, value_or_callback: Optional[Address], /
        ) -> "DomainMappingStatus.Builder": ...

        @overload
        def address(
            self,
            value_or_callback: Callable[[Address.Builder], Address.Builder | Address],
            /,
        ) -> "DomainMappingStatus.Builder": ...

        @overload
        def address(self, value_or_callback: Never = ...) -> "Address.BuilderContext": ...

        def address(self, value_or_callback=None, /):
            """
            Address holds the information needed for a DomainMapping to be the target of an event.
            """
            if self._in_context and value_or_callback is None:
                context = Address.BuilderContext()
                context._parent_builder = self
                context._field_name = "address"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Address.builder())
                if isinstance(output, Address.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("address", value)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is additional Status fields for the Resource to save some
            additional State as well as convey more information to the user. This is
            roughly akin to Annotations on any k8s resource, just the reconciler conveying
            richer information outwards.
            """
            return self._set("annotations", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "DomainMappingStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "DomainMappingStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions the latest available observations of a resource's current state.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the 'Generation' of the Service that
            was last processed by the controller.
            """
            return self._set("observed_generation", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the URL of this DomainMapping.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["DomainMappingStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DomainMappingStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DomainMappingStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DomainMappingStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DomainMappingStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    address: Optional[Address] = None
    """
    Address holds the information needed for a DomainMapping to be the target of an event.
    """
    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is additional Status fields for the Resource to save some
    additional State as well as convey more information to the user. This is
    roughly akin to Annotations on any k8s resource, just the reconciler conveying
    richer information outwards.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions the latest available observations of a resource's current state.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the 'Generation' of the Service that
    was last processed by the controller.
    """
    url: Optional[str] = None
    """
    URL is the URL of this DomainMapping.
    """


class DomainMapping(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DomainMapping"]:
            return DomainMapping

        def build(self) -> "DomainMapping":
            return DomainMapping(**self._attrs)

        def api_version(self, value: Optional[Literal["serving.knative.dev/v1beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["DomainMapping"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "DomainMapping.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "DomainMapping.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[DomainMappingSpec], /
        ) -> "DomainMapping.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [DomainMappingSpec.Builder],
                DomainMappingSpec.Builder | DomainMappingSpec,
            ],
            /,
        ) -> "DomainMapping.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "DomainMappingSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DomainMappingSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DomainMappingSpec.builder())
                if isinstance(output, DomainMappingSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[DomainMappingStatus], /
        ) -> "DomainMapping.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [DomainMappingStatus.Builder],
                DomainMappingStatus.Builder | DomainMappingStatus,
            ],
            /,
        ) -> "DomainMapping.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "DomainMappingStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = DomainMappingStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DomainMappingStatus.builder())
                if isinstance(output, DomainMappingStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["DomainMapping.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DomainMapping.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DomainMapping."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DomainMapping", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DomainMapping.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["serving.knative.dev/v1beta1"]], Field(alias="apiVersion")
    ] = "serving.knative.dev/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["DomainMapping"]] = "DomainMapping"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    spec: Optional[DomainMappingSpec] = None
    status: Optional[DomainMappingStatus] = None
