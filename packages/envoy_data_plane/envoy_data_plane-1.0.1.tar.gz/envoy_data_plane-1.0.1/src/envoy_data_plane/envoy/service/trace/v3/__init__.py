# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: envoy/service/trace/v3/trace_service.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "StreamTracesMessage",
    "StreamTracesMessageIdentifier",
    "StreamTracesResponse",
    "TraceServiceStub",
    "TraceServiceBase",
)

from collections.abc import AsyncIterable, AsyncIterator, Iterable
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto2
import grpclib
from betterproto2.grpc.grpclib_server import ServiceBase

from .....message_pool import default_message_pool

if TYPE_CHECKING:
    import grpclib.server
    from betterproto2.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

betterproto2.check_compiler_version("0.2.4")


@dataclass(eq=False, repr=False)
class StreamTracesMessage(betterproto2.Message):
    identifier: "StreamTracesMessageIdentifier | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Identifier data effectively is a structured metadata.
    As a performance optimization this will only be sent in the first message
    on the stream.
    """

    spans: "list[____opencensus__proto__trace__v1__.Span]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of Span entries
    """


default_message_pool.register_message(
    "envoy.service.trace.v3", "StreamTracesMessage", StreamTracesMessage
)


@dataclass(eq=False, repr=False)
class StreamTracesMessageIdentifier(betterproto2.Message):
    node: "___config__core__v3__.Node | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The node sending the access log messages over the stream.
    """


default_message_pool.register_message(
    "envoy.service.trace.v3",
    "StreamTracesMessage.Identifier",
    StreamTracesMessageIdentifier,
)


@dataclass(eq=False, repr=False)
class StreamTracesResponse(betterproto2.Message):
    pass


default_message_pool.register_message(
    "envoy.service.trace.v3", "StreamTracesResponse", StreamTracesResponse
)


class TraceServiceStub(betterproto2.ServiceStub):
    """
    [#protodoc-title: Trace service]

    Service for streaming traces to server that consumes the trace data. It
    uses OpenCensus data model as a standard to represent trace information.
    """

    async def stream_traces(
        self,
        messages: "AsyncIterable[StreamTracesMessage] | Iterable[StreamTracesMessage]",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "StreamTracesResponse":
        """
        Envoy will connect and send StreamTracesMessage messages forever. It does
        not expect any response to be sent as nothing would be done in the case
        of failure.
        """

        return await self._stream_unary(
            "/envoy.service.trace.v3.TraceService/StreamTraces",
            messages,
            StreamTracesMessage,
            StreamTracesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from .....opencensus.proto.trace import v1 as ____opencensus__proto__trace__v1__
from ....config.core import v3 as ___config__core__v3__


class TraceServiceBase(ServiceBase):
    """
    [#protodoc-title: Trace service]

    Service for streaming traces to server that consumes the trace data. It
    uses OpenCensus data model as a standard to represent trace information.
    """

    async def stream_traces(
        self, messages: "AsyncIterator[StreamTracesMessage]"
    ) -> "StreamTracesResponse":
        """
        Envoy will connect and send StreamTracesMessage messages forever. It does
        not expect any response to be sent as nothing would be done in the case
        of failure.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_stream_traces(
        self, stream: "grpclib.server.Stream[StreamTracesMessage, StreamTracesResponse]"
    ) -> None:
        request = stream.__aiter__()
        response = await self.stream_traces(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler":
        return {
            "/envoy.service.trace.v3.TraceService/StreamTraces": grpclib.const.Handler(
                self.__rpc_stream_traces,
                grpclib.const.Cardinality.STREAM_UNARY,
                StreamTracesMessage,
                StreamTracesResponse,
            ),
        }
